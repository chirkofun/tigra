
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

00200200 <Reset_Handler>:
  200200:	b672      	cpsid	i
  200202:	4826      	ldr	r0, [pc, #152]	; (20029c <endfiniloop+0x6>)
  200204:	f380 8809 	msr	PSP, r0
  200208:	4825      	ldr	r0, [pc, #148]	; (2002a0 <endfiniloop+0xa>)
  20020a:	f64e 5108 	movw	r1, #60680	; 0xed08
  20020e:	f2ce 0100 	movt	r1, #57344	; 0xe000
  200212:	6008      	str	r0, [r1, #0]
  200214:	2002      	movs	r0, #2
  200216:	f380 8814 	msr	CONTROL, r0
  20021a:	f3bf 8f6f 	isb	sy
  20021e:	f002 ff47 	bl	2030b0 <__core_init>
  200222:	f003 fb2d 	bl	203880 <__early_init>
  200226:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
  20022a:	491e      	ldr	r1, [pc, #120]	; (2002a4 <endfiniloop+0xe>)
  20022c:	4a1e      	ldr	r2, [pc, #120]	; (2002a8 <endfiniloop+0x12>)

0020022e <msloop>:
  20022e:	4291      	cmp	r1, r2
  200230:	bf3c      	itt	cc
  200232:	f841 0b04 	strcc.w	r0, [r1], #4
  200236:	e7fa      	bcc.n	20022e <msloop>
  200238:	491c      	ldr	r1, [pc, #112]	; (2002ac <endfiniloop+0x16>)
  20023a:	4a18      	ldr	r2, [pc, #96]	; (20029c <endfiniloop+0x6>)

0020023c <psloop>:
  20023c:	4291      	cmp	r1, r2
  20023e:	bf3c      	itt	cc
  200240:	f841 0b04 	strcc.w	r0, [r1], #4
  200244:	e7fa      	bcc.n	20023c <psloop>
  200246:	491a      	ldr	r1, [pc, #104]	; (2002b0 <endfiniloop+0x1a>)
  200248:	4a1a      	ldr	r2, [pc, #104]	; (2002b4 <endfiniloop+0x1e>)
  20024a:	4b1b      	ldr	r3, [pc, #108]	; (2002b8 <endfiniloop+0x22>)

0020024c <dloop>:
  20024c:	429a      	cmp	r2, r3
  20024e:	bf3e      	ittt	cc
  200250:	f851 0b04 	ldrcc.w	r0, [r1], #4
  200254:	f842 0b04 	strcc.w	r0, [r2], #4
  200258:	e7f8      	bcc.n	20024c <dloop>
  20025a:	2000      	movs	r0, #0
  20025c:	4917      	ldr	r1, [pc, #92]	; (2002bc <endfiniloop+0x26>)
  20025e:	4a18      	ldr	r2, [pc, #96]	; (2002c0 <endfiniloop+0x2a>)

00200260 <bloop>:
  200260:	4291      	cmp	r1, r2
  200262:	bf3c      	itt	cc
  200264:	f841 0b04 	strcc.w	r0, [r1], #4
  200268:	e7fa      	bcc.n	200260 <bloop>
  20026a:	f002 fee1 	bl	203030 <__init_ram_areas>
  20026e:	f002 ff17 	bl	2030a0 <__late_init>
  200272:	4c14      	ldr	r4, [pc, #80]	; (2002c4 <endfiniloop+0x2e>)
  200274:	4d14      	ldr	r5, [pc, #80]	; (2002c8 <endfiniloop+0x32>)

00200276 <initloop>:
  200276:	42ac      	cmp	r4, r5
  200278:	da03      	bge.n	200282 <endinitloop>
  20027a:	f854 1b04 	ldr.w	r1, [r4], #4
  20027e:	4788      	blx	r1
  200280:	e7f9      	b.n	200276 <initloop>

00200282 <endinitloop>:
  200282:	f001 f845 	bl	201310 <main>
  200286:	4c11      	ldr	r4, [pc, #68]	; (2002cc <endfiniloop+0x36>)
  200288:	4d11      	ldr	r5, [pc, #68]	; (2002d0 <endfiniloop+0x3a>)

0020028a <finiloop>:
  20028a:	42ac      	cmp	r4, r5
  20028c:	da03      	bge.n	200296 <endfiniloop>
  20028e:	f854 1b04 	ldr.w	r1, [r4], #4
  200292:	4788      	blx	r1
  200294:	e7f9      	b.n	20028a <finiloop>

00200296 <endfiniloop>:
  200296:	f002 befb 	b.w	203090 <__default_exit>
  20029a:	0000      	.short	0x0000
  20029c:	20000800 	.word	0x20000800
  2002a0:	00200000 	.word	0x00200000
  2002a4:	20000000 	.word	0x20000000
  2002a8:	20000400 	.word	0x20000400
  2002ac:	20000400 	.word	0x20000400
  2002b0:	080052a8 	.word	0x080052a8
  2002b4:	20020000 	.word	0x20020000
  2002b8:	20020664 	.word	0x20020664
  2002bc:	20000800 	.word	0x20000800
  2002c0:	20000ec0 	.word	0x20000ec0
  2002c4:	00200200 	.word	0x00200200
  2002c8:	00200200 	.word	0x00200200
  2002cc:	00200200 	.word	0x00200200
  2002d0:	00200200 	.word	0x00200200

002002d4 <_port_switch>:
  2002d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  2002d8:	f8c1 d00c 	str.w	sp, [r1, #12]
  2002dc:	f8d0 d00c 	ldr.w	sp, [r0, #12]
  2002e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

002002e4 <_port_thread_start>:
  2002e4:	2300      	movs	r3, #0
  2002e6:	f383 8811 	msr	BASEPRI, r3
  2002ea:	4628      	mov	r0, r5
  2002ec:	47a0      	blx	r4
  2002ee:	2000      	movs	r0, #0
  2002f0:	f002 fe6e 	bl	202fd0 <chThdExit>

002002f4 <_port_switch_from_isr>:
  2002f4:	f002 fba4 	bl	202a40 <chSchDoReschedule>

002002f8 <_port_exit_from_isr>:
  2002f8:	df00      	svc	0
  2002fa:	e7fe      	b.n	2002fa <_port_exit_from_isr+0x2>

002002fc <__aeabi_drsub>:
  2002fc:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  200300:	e002      	b.n	200308 <__adddf3>
  200302:	bf00      	nop

00200304 <__aeabi_dsub>:
  200304:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00200308 <__adddf3>:
  200308:	b530      	push	{r4, r5, lr}
  20030a:	ea4f 0441 	mov.w	r4, r1, lsl #1
  20030e:	ea4f 0543 	mov.w	r5, r3, lsl #1
  200312:	ea94 0f05 	teq	r4, r5
  200316:	bf08      	it	eq
  200318:	ea90 0f02 	teqeq	r0, r2
  20031c:	bf1f      	itttt	ne
  20031e:	ea54 0c00 	orrsne.w	ip, r4, r0
  200322:	ea55 0c02 	orrsne.w	ip, r5, r2
  200326:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
  20032a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  20032e:	f000 80e2 	beq.w	2004f6 <__adddf3+0x1ee>
  200332:	ea4f 5454 	mov.w	r4, r4, lsr #21
  200336:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  20033a:	bfb8      	it	lt
  20033c:	426d      	neglt	r5, r5
  20033e:	dd0c      	ble.n	20035a <__adddf3+0x52>
  200340:	442c      	add	r4, r5
  200342:	ea80 0202 	eor.w	r2, r0, r2
  200346:	ea81 0303 	eor.w	r3, r1, r3
  20034a:	ea82 0000 	eor.w	r0, r2, r0
  20034e:	ea83 0101 	eor.w	r1, r3, r1
  200352:	ea80 0202 	eor.w	r2, r0, r2
  200356:	ea81 0303 	eor.w	r3, r1, r3
  20035a:	2d36      	cmp	r5, #54	; 0x36
  20035c:	bf88      	it	hi
  20035e:	bd30      	pophi	{r4, r5, pc}
  200360:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  200364:	ea4f 3101 	mov.w	r1, r1, lsl #12
  200368:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
  20036c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
  200370:	d002      	beq.n	200378 <__adddf3+0x70>
  200372:	4240      	negs	r0, r0
  200374:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  200378:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  20037c:	ea4f 3303 	mov.w	r3, r3, lsl #12
  200380:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
  200384:	d002      	beq.n	20038c <__adddf3+0x84>
  200386:	4252      	negs	r2, r2
  200388:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  20038c:	ea94 0f05 	teq	r4, r5
  200390:	f000 80a7 	beq.w	2004e2 <__adddf3+0x1da>
  200394:	f1a4 0401 	sub.w	r4, r4, #1
  200398:	f1d5 0e20 	rsbs	lr, r5, #32
  20039c:	db0d      	blt.n	2003ba <__adddf3+0xb2>
  20039e:	fa02 fc0e 	lsl.w	ip, r2, lr
  2003a2:	fa22 f205 	lsr.w	r2, r2, r5
  2003a6:	1880      	adds	r0, r0, r2
  2003a8:	f141 0100 	adc.w	r1, r1, #0
  2003ac:	fa03 f20e 	lsl.w	r2, r3, lr
  2003b0:	1880      	adds	r0, r0, r2
  2003b2:	fa43 f305 	asr.w	r3, r3, r5
  2003b6:	4159      	adcs	r1, r3
  2003b8:	e00e      	b.n	2003d8 <__adddf3+0xd0>
  2003ba:	f1a5 0520 	sub.w	r5, r5, #32
  2003be:	f10e 0e20 	add.w	lr, lr, #32
  2003c2:	2a01      	cmp	r2, #1
  2003c4:	fa03 fc0e 	lsl.w	ip, r3, lr
  2003c8:	bf28      	it	cs
  2003ca:	f04c 0c02 	orrcs.w	ip, ip, #2
  2003ce:	fa43 f305 	asr.w	r3, r3, r5
  2003d2:	18c0      	adds	r0, r0, r3
  2003d4:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  2003d8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  2003dc:	d507      	bpl.n	2003ee <__adddf3+0xe6>
  2003de:	f04f 0e00 	mov.w	lr, #0
  2003e2:	f1dc 0c00 	rsbs	ip, ip, #0
  2003e6:	eb7e 0000 	sbcs.w	r0, lr, r0
  2003ea:	eb6e 0101 	sbc.w	r1, lr, r1
  2003ee:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  2003f2:	d31b      	bcc.n	20042c <__adddf3+0x124>
  2003f4:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  2003f8:	d30c      	bcc.n	200414 <__adddf3+0x10c>
  2003fa:	0849      	lsrs	r1, r1, #1
  2003fc:	ea5f 0030 	movs.w	r0, r0, rrx
  200400:	ea4f 0c3c 	mov.w	ip, ip, rrx
  200404:	f104 0401 	add.w	r4, r4, #1
  200408:	ea4f 5244 	mov.w	r2, r4, lsl #21
  20040c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  200410:	f080 809a 	bcs.w	200548 <__adddf3+0x240>
  200414:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  200418:	bf08      	it	eq
  20041a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  20041e:	f150 0000 	adcs.w	r0, r0, #0
  200422:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  200426:	ea41 0105 	orr.w	r1, r1, r5
  20042a:	bd30      	pop	{r4, r5, pc}
  20042c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
  200430:	4140      	adcs	r0, r0
  200432:	eb41 0101 	adc.w	r1, r1, r1
  200436:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  20043a:	f1a4 0401 	sub.w	r4, r4, #1
  20043e:	d1e9      	bne.n	200414 <__adddf3+0x10c>
  200440:	f091 0f00 	teq	r1, #0
  200444:	bf04      	itt	eq
  200446:	4601      	moveq	r1, r0
  200448:	2000      	moveq	r0, #0
  20044a:	fab1 f381 	clz	r3, r1
  20044e:	bf08      	it	eq
  200450:	3320      	addeq	r3, #32
  200452:	f1a3 030b 	sub.w	r3, r3, #11
  200456:	f1b3 0220 	subs.w	r2, r3, #32
  20045a:	da0c      	bge.n	200476 <__adddf3+0x16e>
  20045c:	320c      	adds	r2, #12
  20045e:	dd08      	ble.n	200472 <__adddf3+0x16a>
  200460:	f102 0c14 	add.w	ip, r2, #20
  200464:	f1c2 020c 	rsb	r2, r2, #12
  200468:	fa01 f00c 	lsl.w	r0, r1, ip
  20046c:	fa21 f102 	lsr.w	r1, r1, r2
  200470:	e00c      	b.n	20048c <__adddf3+0x184>
  200472:	f102 0214 	add.w	r2, r2, #20
  200476:	bfd8      	it	le
  200478:	f1c2 0c20 	rsble	ip, r2, #32
  20047c:	fa01 f102 	lsl.w	r1, r1, r2
  200480:	fa20 fc0c 	lsr.w	ip, r0, ip
  200484:	bfdc      	itt	le
  200486:	ea41 010c 	orrle.w	r1, r1, ip
  20048a:	4090      	lslle	r0, r2
  20048c:	1ae4      	subs	r4, r4, r3
  20048e:	bfa2      	ittt	ge
  200490:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  200494:	4329      	orrge	r1, r5
  200496:	bd30      	popge	{r4, r5, pc}
  200498:	ea6f 0404 	mvn.w	r4, r4
  20049c:	3c1f      	subs	r4, #31
  20049e:	da1c      	bge.n	2004da <__adddf3+0x1d2>
  2004a0:	340c      	adds	r4, #12
  2004a2:	dc0e      	bgt.n	2004c2 <__adddf3+0x1ba>
  2004a4:	f104 0414 	add.w	r4, r4, #20
  2004a8:	f1c4 0220 	rsb	r2, r4, #32
  2004ac:	fa20 f004 	lsr.w	r0, r0, r4
  2004b0:	fa01 f302 	lsl.w	r3, r1, r2
  2004b4:	ea40 0003 	orr.w	r0, r0, r3
  2004b8:	fa21 f304 	lsr.w	r3, r1, r4
  2004bc:	ea45 0103 	orr.w	r1, r5, r3
  2004c0:	bd30      	pop	{r4, r5, pc}
  2004c2:	f1c4 040c 	rsb	r4, r4, #12
  2004c6:	f1c4 0220 	rsb	r2, r4, #32
  2004ca:	fa20 f002 	lsr.w	r0, r0, r2
  2004ce:	fa01 f304 	lsl.w	r3, r1, r4
  2004d2:	ea40 0003 	orr.w	r0, r0, r3
  2004d6:	4629      	mov	r1, r5
  2004d8:	bd30      	pop	{r4, r5, pc}
  2004da:	fa21 f004 	lsr.w	r0, r1, r4
  2004de:	4629      	mov	r1, r5
  2004e0:	bd30      	pop	{r4, r5, pc}
  2004e2:	f094 0f00 	teq	r4, #0
  2004e6:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  2004ea:	bf06      	itte	eq
  2004ec:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  2004f0:	3401      	addeq	r4, #1
  2004f2:	3d01      	subne	r5, #1
  2004f4:	e74e      	b.n	200394 <__adddf3+0x8c>
  2004f6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  2004fa:	bf18      	it	ne
  2004fc:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  200500:	d029      	beq.n	200556 <__adddf3+0x24e>
  200502:	ea94 0f05 	teq	r4, r5
  200506:	bf08      	it	eq
  200508:	ea90 0f02 	teqeq	r0, r2
  20050c:	d005      	beq.n	20051a <__adddf3+0x212>
  20050e:	ea54 0c00 	orrs.w	ip, r4, r0
  200512:	bf04      	itt	eq
  200514:	4619      	moveq	r1, r3
  200516:	4610      	moveq	r0, r2
  200518:	bd30      	pop	{r4, r5, pc}
  20051a:	ea91 0f03 	teq	r1, r3
  20051e:	bf1e      	ittt	ne
  200520:	2100      	movne	r1, #0
  200522:	2000      	movne	r0, #0
  200524:	bd30      	popne	{r4, r5, pc}
  200526:	ea5f 5c54 	movs.w	ip, r4, lsr #21
  20052a:	d105      	bne.n	200538 <__adddf3+0x230>
  20052c:	0040      	lsls	r0, r0, #1
  20052e:	4149      	adcs	r1, r1
  200530:	bf28      	it	cs
  200532:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  200536:	bd30      	pop	{r4, r5, pc}
  200538:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  20053c:	bf3c      	itt	cc
  20053e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  200542:	bd30      	popcc	{r4, r5, pc}
  200544:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  200548:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  20054c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  200550:	f04f 0000 	mov.w	r0, #0
  200554:	bd30      	pop	{r4, r5, pc}
  200556:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  20055a:	bf1a      	itte	ne
  20055c:	4619      	movne	r1, r3
  20055e:	4610      	movne	r0, r2
  200560:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
  200564:	bf1c      	itt	ne
  200566:	460b      	movne	r3, r1
  200568:	4602      	movne	r2, r0
  20056a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  20056e:	bf06      	itte	eq
  200570:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  200574:	ea91 0f03 	teqeq	r1, r3
  200578:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  20057c:	bd30      	pop	{r4, r5, pc}
  20057e:	bf00      	nop

00200580 <__aeabi_ui2d>:
  200580:	f090 0f00 	teq	r0, #0
  200584:	bf04      	itt	eq
  200586:	2100      	moveq	r1, #0
  200588:	4770      	bxeq	lr
  20058a:	b530      	push	{r4, r5, lr}
  20058c:	f44f 6480 	mov.w	r4, #1024	; 0x400
  200590:	f104 0432 	add.w	r4, r4, #50	; 0x32
  200594:	f04f 0500 	mov.w	r5, #0
  200598:	f04f 0100 	mov.w	r1, #0
  20059c:	e750      	b.n	200440 <__adddf3+0x138>
  20059e:	bf00      	nop

002005a0 <__aeabi_i2d>:
  2005a0:	f090 0f00 	teq	r0, #0
  2005a4:	bf04      	itt	eq
  2005a6:	2100      	moveq	r1, #0
  2005a8:	4770      	bxeq	lr
  2005aa:	b530      	push	{r4, r5, lr}
  2005ac:	f44f 6480 	mov.w	r4, #1024	; 0x400
  2005b0:	f104 0432 	add.w	r4, r4, #50	; 0x32
  2005b4:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  2005b8:	bf48      	it	mi
  2005ba:	4240      	negmi	r0, r0
  2005bc:	f04f 0100 	mov.w	r1, #0
  2005c0:	e73e      	b.n	200440 <__adddf3+0x138>
  2005c2:	bf00      	nop

002005c4 <__aeabi_f2d>:
  2005c4:	0042      	lsls	r2, r0, #1
  2005c6:	ea4f 01e2 	mov.w	r1, r2, asr #3
  2005ca:	ea4f 0131 	mov.w	r1, r1, rrx
  2005ce:	ea4f 7002 	mov.w	r0, r2, lsl #28
  2005d2:	bf1f      	itttt	ne
  2005d4:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  2005d8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  2005dc:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  2005e0:	4770      	bxne	lr
  2005e2:	f092 0f00 	teq	r2, #0
  2005e6:	bf14      	ite	ne
  2005e8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  2005ec:	4770      	bxeq	lr
  2005ee:	b530      	push	{r4, r5, lr}
  2005f0:	f44f 7460 	mov.w	r4, #896	; 0x380
  2005f4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  2005f8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  2005fc:	e720      	b.n	200440 <__adddf3+0x138>
  2005fe:	bf00      	nop

00200600 <__aeabi_ul2d>:
  200600:	ea50 0201 	orrs.w	r2, r0, r1
  200604:	bf08      	it	eq
  200606:	4770      	bxeq	lr
  200608:	b530      	push	{r4, r5, lr}
  20060a:	f04f 0500 	mov.w	r5, #0
  20060e:	e00a      	b.n	200626 <__aeabi_l2d+0x16>

00200610 <__aeabi_l2d>:
  200610:	ea50 0201 	orrs.w	r2, r0, r1
  200614:	bf08      	it	eq
  200616:	4770      	bxeq	lr
  200618:	b530      	push	{r4, r5, lr}
  20061a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  20061e:	d502      	bpl.n	200626 <__aeabi_l2d+0x16>
  200620:	4240      	negs	r0, r0
  200622:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  200626:	f44f 6480 	mov.w	r4, #1024	; 0x400
  20062a:	f104 0432 	add.w	r4, r4, #50	; 0x32
  20062e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
  200632:	f43f aedc 	beq.w	2003ee <__adddf3+0xe6>
  200636:	f04f 0203 	mov.w	r2, #3
  20063a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  20063e:	bf18      	it	ne
  200640:	3203      	addne	r2, #3
  200642:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  200646:	bf18      	it	ne
  200648:	3203      	addne	r2, #3
  20064a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
  20064e:	f1c2 0320 	rsb	r3, r2, #32
  200652:	fa00 fc03 	lsl.w	ip, r0, r3
  200656:	fa20 f002 	lsr.w	r0, r0, r2
  20065a:	fa01 fe03 	lsl.w	lr, r1, r3
  20065e:	ea40 000e 	orr.w	r0, r0, lr
  200662:	fa21 f102 	lsr.w	r1, r1, r2
  200666:	4414      	add	r4, r2
  200668:	e6c1      	b.n	2003ee <__adddf3+0xe6>
  20066a:	bf00      	nop

0020066c <__aeabi_dmul>:
  20066c:	b570      	push	{r4, r5, r6, lr}
  20066e:	f04f 0cff 	mov.w	ip, #255	; 0xff
  200672:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  200676:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  20067a:	bf1d      	ittte	ne
  20067c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  200680:	ea94 0f0c 	teqne	r4, ip
  200684:	ea95 0f0c 	teqne	r5, ip
  200688:	f000 f8de 	bleq	200848 <__aeabi_dmul+0x1dc>
  20068c:	442c      	add	r4, r5
  20068e:	ea81 0603 	eor.w	r6, r1, r3
  200692:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
  200696:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
  20069a:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
  20069e:	bf18      	it	ne
  2006a0:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
  2006a4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  2006a8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  2006ac:	d038      	beq.n	200720 <__aeabi_dmul+0xb4>
  2006ae:	fba0 ce02 	umull	ip, lr, r0, r2
  2006b2:	f04f 0500 	mov.w	r5, #0
  2006b6:	fbe1 e502 	umlal	lr, r5, r1, r2
  2006ba:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
  2006be:	fbe0 e503 	umlal	lr, r5, r0, r3
  2006c2:	f04f 0600 	mov.w	r6, #0
  2006c6:	fbe1 5603 	umlal	r5, r6, r1, r3
  2006ca:	f09c 0f00 	teq	ip, #0
  2006ce:	bf18      	it	ne
  2006d0:	f04e 0e01 	orrne.w	lr, lr, #1
  2006d4:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
  2006d8:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
  2006dc:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
  2006e0:	d204      	bcs.n	2006ec <__aeabi_dmul+0x80>
  2006e2:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
  2006e6:	416d      	adcs	r5, r5
  2006e8:	eb46 0606 	adc.w	r6, r6, r6
  2006ec:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
  2006f0:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  2006f4:	ea4f 20c5 	mov.w	r0, r5, lsl #11
  2006f8:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
  2006fc:	ea4f 2ece 	mov.w	lr, lr, lsl #11
  200700:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  200704:	bf88      	it	hi
  200706:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  20070a:	d81e      	bhi.n	20074a <__aeabi_dmul+0xde>
  20070c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
  200710:	bf08      	it	eq
  200712:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
  200716:	f150 0000 	adcs.w	r0, r0, #0
  20071a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  20071e:	bd70      	pop	{r4, r5, r6, pc}
  200720:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
  200724:	ea46 0101 	orr.w	r1, r6, r1
  200728:	ea40 0002 	orr.w	r0, r0, r2
  20072c:	ea81 0103 	eor.w	r1, r1, r3
  200730:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
  200734:	bfc2      	ittt	gt
  200736:	ebd4 050c 	rsbsgt	r5, r4, ip
  20073a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  20073e:	bd70      	popgt	{r4, r5, r6, pc}
  200740:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  200744:	f04f 0e00 	mov.w	lr, #0
  200748:	3c01      	subs	r4, #1
  20074a:	f300 80ab 	bgt.w	2008a4 <__aeabi_dmul+0x238>
  20074e:	f114 0f36 	cmn.w	r4, #54	; 0x36
  200752:	bfde      	ittt	le
  200754:	2000      	movle	r0, #0
  200756:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
  20075a:	bd70      	pople	{r4, r5, r6, pc}
  20075c:	f1c4 0400 	rsb	r4, r4, #0
  200760:	3c20      	subs	r4, #32
  200762:	da35      	bge.n	2007d0 <__aeabi_dmul+0x164>
  200764:	340c      	adds	r4, #12
  200766:	dc1b      	bgt.n	2007a0 <__aeabi_dmul+0x134>
  200768:	f104 0414 	add.w	r4, r4, #20
  20076c:	f1c4 0520 	rsb	r5, r4, #32
  200770:	fa00 f305 	lsl.w	r3, r0, r5
  200774:	fa20 f004 	lsr.w	r0, r0, r4
  200778:	fa01 f205 	lsl.w	r2, r1, r5
  20077c:	ea40 0002 	orr.w	r0, r0, r2
  200780:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
  200784:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  200788:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  20078c:	fa21 f604 	lsr.w	r6, r1, r4
  200790:	eb42 0106 	adc.w	r1, r2, r6
  200794:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  200798:	bf08      	it	eq
  20079a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  20079e:	bd70      	pop	{r4, r5, r6, pc}
  2007a0:	f1c4 040c 	rsb	r4, r4, #12
  2007a4:	f1c4 0520 	rsb	r5, r4, #32
  2007a8:	fa00 f304 	lsl.w	r3, r0, r4
  2007ac:	fa20 f005 	lsr.w	r0, r0, r5
  2007b0:	fa01 f204 	lsl.w	r2, r1, r4
  2007b4:	ea40 0002 	orr.w	r0, r0, r2
  2007b8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  2007bc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  2007c0:	f141 0100 	adc.w	r1, r1, #0
  2007c4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  2007c8:	bf08      	it	eq
  2007ca:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  2007ce:	bd70      	pop	{r4, r5, r6, pc}
  2007d0:	f1c4 0520 	rsb	r5, r4, #32
  2007d4:	fa00 f205 	lsl.w	r2, r0, r5
  2007d8:	ea4e 0e02 	orr.w	lr, lr, r2
  2007dc:	fa20 f304 	lsr.w	r3, r0, r4
  2007e0:	fa01 f205 	lsl.w	r2, r1, r5
  2007e4:	ea43 0302 	orr.w	r3, r3, r2
  2007e8:	fa21 f004 	lsr.w	r0, r1, r4
  2007ec:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  2007f0:	fa21 f204 	lsr.w	r2, r1, r4
  2007f4:	ea20 0002 	bic.w	r0, r0, r2
  2007f8:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
  2007fc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  200800:	bf08      	it	eq
  200802:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  200806:	bd70      	pop	{r4, r5, r6, pc}
  200808:	f094 0f00 	teq	r4, #0
  20080c:	d10f      	bne.n	20082e <__aeabi_dmul+0x1c2>
  20080e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
  200812:	0040      	lsls	r0, r0, #1
  200814:	eb41 0101 	adc.w	r1, r1, r1
  200818:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  20081c:	bf08      	it	eq
  20081e:	3c01      	subeq	r4, #1
  200820:	d0f7      	beq.n	200812 <__aeabi_dmul+0x1a6>
  200822:	ea41 0106 	orr.w	r1, r1, r6
  200826:	f095 0f00 	teq	r5, #0
  20082a:	bf18      	it	ne
  20082c:	4770      	bxne	lr
  20082e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
  200832:	0052      	lsls	r2, r2, #1
  200834:	eb43 0303 	adc.w	r3, r3, r3
  200838:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  20083c:	bf08      	it	eq
  20083e:	3d01      	subeq	r5, #1
  200840:	d0f7      	beq.n	200832 <__aeabi_dmul+0x1c6>
  200842:	ea43 0306 	orr.w	r3, r3, r6
  200846:	4770      	bx	lr
  200848:	ea94 0f0c 	teq	r4, ip
  20084c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  200850:	bf18      	it	ne
  200852:	ea95 0f0c 	teqne	r5, ip
  200856:	d00c      	beq.n	200872 <__aeabi_dmul+0x206>
  200858:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  20085c:	bf18      	it	ne
  20085e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  200862:	d1d1      	bne.n	200808 <__aeabi_dmul+0x19c>
  200864:	ea81 0103 	eor.w	r1, r1, r3
  200868:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  20086c:	f04f 0000 	mov.w	r0, #0
  200870:	bd70      	pop	{r4, r5, r6, pc}
  200872:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  200876:	bf06      	itte	eq
  200878:	4610      	moveq	r0, r2
  20087a:	4619      	moveq	r1, r3
  20087c:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  200880:	d019      	beq.n	2008b6 <__aeabi_dmul+0x24a>
  200882:	ea94 0f0c 	teq	r4, ip
  200886:	d102      	bne.n	20088e <__aeabi_dmul+0x222>
  200888:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
  20088c:	d113      	bne.n	2008b6 <__aeabi_dmul+0x24a>
  20088e:	ea95 0f0c 	teq	r5, ip
  200892:	d105      	bne.n	2008a0 <__aeabi_dmul+0x234>
  200894:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
  200898:	bf1c      	itt	ne
  20089a:	4610      	movne	r0, r2
  20089c:	4619      	movne	r1, r3
  20089e:	d10a      	bne.n	2008b6 <__aeabi_dmul+0x24a>
  2008a0:	ea81 0103 	eor.w	r1, r1, r3
  2008a4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  2008a8:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  2008ac:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  2008b0:	f04f 0000 	mov.w	r0, #0
  2008b4:	bd70      	pop	{r4, r5, r6, pc}
  2008b6:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  2008ba:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
  2008be:	bd70      	pop	{r4, r5, r6, pc}

002008c0 <__aeabi_ddiv>:
  2008c0:	b570      	push	{r4, r5, r6, lr}
  2008c2:	f04f 0cff 	mov.w	ip, #255	; 0xff
  2008c6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  2008ca:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  2008ce:	bf1d      	ittte	ne
  2008d0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  2008d4:	ea94 0f0c 	teqne	r4, ip
  2008d8:	ea95 0f0c 	teqne	r5, ip
  2008dc:	f000 f8a7 	bleq	200a2e <__aeabi_ddiv+0x16e>
  2008e0:	eba4 0405 	sub.w	r4, r4, r5
  2008e4:	ea81 0e03 	eor.w	lr, r1, r3
  2008e8:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  2008ec:	ea4f 3101 	mov.w	r1, r1, lsl #12
  2008f0:	f000 8088 	beq.w	200a04 <__aeabi_ddiv+0x144>
  2008f4:	ea4f 3303 	mov.w	r3, r3, lsl #12
  2008f8:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  2008fc:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
  200900:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
  200904:	ea4f 2202 	mov.w	r2, r2, lsl #8
  200908:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
  20090c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
  200910:	ea4f 2600 	mov.w	r6, r0, lsl #8
  200914:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
  200918:	429d      	cmp	r5, r3
  20091a:	bf08      	it	eq
  20091c:	4296      	cmpeq	r6, r2
  20091e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
  200922:	f504 7440 	add.w	r4, r4, #768	; 0x300
  200926:	d202      	bcs.n	20092e <__aeabi_ddiv+0x6e>
  200928:	085b      	lsrs	r3, r3, #1
  20092a:	ea4f 0232 	mov.w	r2, r2, rrx
  20092e:	1ab6      	subs	r6, r6, r2
  200930:	eb65 0503 	sbc.w	r5, r5, r3
  200934:	085b      	lsrs	r3, r3, #1
  200936:	ea4f 0232 	mov.w	r2, r2, rrx
  20093a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  20093e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
  200942:	ebb6 0e02 	subs.w	lr, r6, r2
  200946:	eb75 0e03 	sbcs.w	lr, r5, r3
  20094a:	bf22      	ittt	cs
  20094c:	1ab6      	subcs	r6, r6, r2
  20094e:	4675      	movcs	r5, lr
  200950:	ea40 000c 	orrcs.w	r0, r0, ip
  200954:	085b      	lsrs	r3, r3, #1
  200956:	ea4f 0232 	mov.w	r2, r2, rrx
  20095a:	ebb6 0e02 	subs.w	lr, r6, r2
  20095e:	eb75 0e03 	sbcs.w	lr, r5, r3
  200962:	bf22      	ittt	cs
  200964:	1ab6      	subcs	r6, r6, r2
  200966:	4675      	movcs	r5, lr
  200968:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  20096c:	085b      	lsrs	r3, r3, #1
  20096e:	ea4f 0232 	mov.w	r2, r2, rrx
  200972:	ebb6 0e02 	subs.w	lr, r6, r2
  200976:	eb75 0e03 	sbcs.w	lr, r5, r3
  20097a:	bf22      	ittt	cs
  20097c:	1ab6      	subcs	r6, r6, r2
  20097e:	4675      	movcs	r5, lr
  200980:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  200984:	085b      	lsrs	r3, r3, #1
  200986:	ea4f 0232 	mov.w	r2, r2, rrx
  20098a:	ebb6 0e02 	subs.w	lr, r6, r2
  20098e:	eb75 0e03 	sbcs.w	lr, r5, r3
  200992:	bf22      	ittt	cs
  200994:	1ab6      	subcs	r6, r6, r2
  200996:	4675      	movcs	r5, lr
  200998:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  20099c:	ea55 0e06 	orrs.w	lr, r5, r6
  2009a0:	d018      	beq.n	2009d4 <__aeabi_ddiv+0x114>
  2009a2:	ea4f 1505 	mov.w	r5, r5, lsl #4
  2009a6:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
  2009aa:	ea4f 1606 	mov.w	r6, r6, lsl #4
  2009ae:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  2009b2:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
  2009b6:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  2009ba:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
  2009be:	d1c0      	bne.n	200942 <__aeabi_ddiv+0x82>
  2009c0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  2009c4:	d10b      	bne.n	2009de <__aeabi_ddiv+0x11e>
  2009c6:	ea41 0100 	orr.w	r1, r1, r0
  2009ca:	f04f 0000 	mov.w	r0, #0
  2009ce:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  2009d2:	e7b6      	b.n	200942 <__aeabi_ddiv+0x82>
  2009d4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  2009d8:	bf04      	itt	eq
  2009da:	4301      	orreq	r1, r0
  2009dc:	2000      	moveq	r0, #0
  2009de:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  2009e2:	bf88      	it	hi
  2009e4:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  2009e8:	f63f aeaf 	bhi.w	20074a <__aeabi_dmul+0xde>
  2009ec:	ebb5 0c03 	subs.w	ip, r5, r3
  2009f0:	bf04      	itt	eq
  2009f2:	ebb6 0c02 	subseq.w	ip, r6, r2
  2009f6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  2009fa:	f150 0000 	adcs.w	r0, r0, #0
  2009fe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  200a02:	bd70      	pop	{r4, r5, r6, pc}
  200a04:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
  200a08:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
  200a0c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
  200a10:	bfc2      	ittt	gt
  200a12:	ebd4 050c 	rsbsgt	r5, r4, ip
  200a16:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  200a1a:	bd70      	popgt	{r4, r5, r6, pc}
  200a1c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  200a20:	f04f 0e00 	mov.w	lr, #0
  200a24:	3c01      	subs	r4, #1
  200a26:	e690      	b.n	20074a <__aeabi_dmul+0xde>
  200a28:	ea45 0e06 	orr.w	lr, r5, r6
  200a2c:	e68d      	b.n	20074a <__aeabi_dmul+0xde>
  200a2e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  200a32:	ea94 0f0c 	teq	r4, ip
  200a36:	bf08      	it	eq
  200a38:	ea95 0f0c 	teqeq	r5, ip
  200a3c:	f43f af3b 	beq.w	2008b6 <__aeabi_dmul+0x24a>
  200a40:	ea94 0f0c 	teq	r4, ip
  200a44:	d10a      	bne.n	200a5c <__aeabi_ddiv+0x19c>
  200a46:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  200a4a:	f47f af34 	bne.w	2008b6 <__aeabi_dmul+0x24a>
  200a4e:	ea95 0f0c 	teq	r5, ip
  200a52:	f47f af25 	bne.w	2008a0 <__aeabi_dmul+0x234>
  200a56:	4610      	mov	r0, r2
  200a58:	4619      	mov	r1, r3
  200a5a:	e72c      	b.n	2008b6 <__aeabi_dmul+0x24a>
  200a5c:	ea95 0f0c 	teq	r5, ip
  200a60:	d106      	bne.n	200a70 <__aeabi_ddiv+0x1b0>
  200a62:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  200a66:	f43f aefd 	beq.w	200864 <__aeabi_dmul+0x1f8>
  200a6a:	4610      	mov	r0, r2
  200a6c:	4619      	mov	r1, r3
  200a6e:	e722      	b.n	2008b6 <__aeabi_dmul+0x24a>
  200a70:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  200a74:	bf18      	it	ne
  200a76:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  200a7a:	f47f aec5 	bne.w	200808 <__aeabi_dmul+0x19c>
  200a7e:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
  200a82:	f47f af0d 	bne.w	2008a0 <__aeabi_dmul+0x234>
  200a86:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
  200a8a:	f47f aeeb 	bne.w	200864 <__aeabi_dmul+0x1f8>
  200a8e:	e712      	b.n	2008b6 <__aeabi_dmul+0x24a>

00200a90 <__gedf2>:
  200a90:	f04f 3cff 	mov.w	ip, #4294967295
  200a94:	e006      	b.n	200aa4 <__cmpdf2+0x4>
  200a96:	bf00      	nop

00200a98 <__ledf2>:
  200a98:	f04f 0c01 	mov.w	ip, #1
  200a9c:	e002      	b.n	200aa4 <__cmpdf2+0x4>
  200a9e:	bf00      	nop

00200aa0 <__cmpdf2>:
  200aa0:	f04f 0c01 	mov.w	ip, #1
  200aa4:	f84d cd04 	str.w	ip, [sp, #-4]!
  200aa8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  200aac:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  200ab0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  200ab4:	bf18      	it	ne
  200ab6:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
  200aba:	d01b      	beq.n	200af4 <__cmpdf2+0x54>
  200abc:	b001      	add	sp, #4
  200abe:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
  200ac2:	bf0c      	ite	eq
  200ac4:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
  200ac8:	ea91 0f03 	teqne	r1, r3
  200acc:	bf02      	ittt	eq
  200ace:	ea90 0f02 	teqeq	r0, r2
  200ad2:	2000      	moveq	r0, #0
  200ad4:	4770      	bxeq	lr
  200ad6:	f110 0f00 	cmn.w	r0, #0
  200ada:	ea91 0f03 	teq	r1, r3
  200ade:	bf58      	it	pl
  200ae0:	4299      	cmppl	r1, r3
  200ae2:	bf08      	it	eq
  200ae4:	4290      	cmpeq	r0, r2
  200ae6:	bf2c      	ite	cs
  200ae8:	17d8      	asrcs	r0, r3, #31
  200aea:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
  200aee:	f040 0001 	orr.w	r0, r0, #1
  200af2:	4770      	bx	lr
  200af4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  200af8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  200afc:	d102      	bne.n	200b04 <__cmpdf2+0x64>
  200afe:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  200b02:	d107      	bne.n	200b14 <__cmpdf2+0x74>
  200b04:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  200b08:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  200b0c:	d1d6      	bne.n	200abc <__cmpdf2+0x1c>
  200b0e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  200b12:	d0d3      	beq.n	200abc <__cmpdf2+0x1c>
  200b14:	f85d 0b04 	ldr.w	r0, [sp], #4
  200b18:	4770      	bx	lr
  200b1a:	bf00      	nop

00200b1c <__aeabi_cdrcmple>:
  200b1c:	4684      	mov	ip, r0
  200b1e:	4610      	mov	r0, r2
  200b20:	4662      	mov	r2, ip
  200b22:	468c      	mov	ip, r1
  200b24:	4619      	mov	r1, r3
  200b26:	4663      	mov	r3, ip
  200b28:	e000      	b.n	200b2c <__aeabi_cdcmpeq>
  200b2a:	bf00      	nop

00200b2c <__aeabi_cdcmpeq>:
  200b2c:	b501      	push	{r0, lr}
  200b2e:	f7ff ffb7 	bl	200aa0 <__cmpdf2>
  200b32:	2800      	cmp	r0, #0
  200b34:	bf48      	it	mi
  200b36:	f110 0f00 	cmnmi.w	r0, #0
  200b3a:	bd01      	pop	{r0, pc}

00200b3c <__aeabi_dcmpeq>:
  200b3c:	f84d ed08 	str.w	lr, [sp, #-8]!
  200b40:	f7ff fff4 	bl	200b2c <__aeabi_cdcmpeq>
  200b44:	bf0c      	ite	eq
  200b46:	2001      	moveq	r0, #1
  200b48:	2000      	movne	r0, #0
  200b4a:	f85d fb08 	ldr.w	pc, [sp], #8
  200b4e:	bf00      	nop

00200b50 <__aeabi_dcmplt>:
  200b50:	f84d ed08 	str.w	lr, [sp, #-8]!
  200b54:	f7ff ffea 	bl	200b2c <__aeabi_cdcmpeq>
  200b58:	bf34      	ite	cc
  200b5a:	2001      	movcc	r0, #1
  200b5c:	2000      	movcs	r0, #0
  200b5e:	f85d fb08 	ldr.w	pc, [sp], #8
  200b62:	bf00      	nop

00200b64 <__aeabi_dcmple>:
  200b64:	f84d ed08 	str.w	lr, [sp, #-8]!
  200b68:	f7ff ffe0 	bl	200b2c <__aeabi_cdcmpeq>
  200b6c:	bf94      	ite	ls
  200b6e:	2001      	movls	r0, #1
  200b70:	2000      	movhi	r0, #0
  200b72:	f85d fb08 	ldr.w	pc, [sp], #8
  200b76:	bf00      	nop

00200b78 <__aeabi_dcmpge>:
  200b78:	f84d ed08 	str.w	lr, [sp, #-8]!
  200b7c:	f7ff ffce 	bl	200b1c <__aeabi_cdrcmple>
  200b80:	bf94      	ite	ls
  200b82:	2001      	movls	r0, #1
  200b84:	2000      	movhi	r0, #0
  200b86:	f85d fb08 	ldr.w	pc, [sp], #8
  200b8a:	bf00      	nop

00200b8c <__aeabi_dcmpgt>:
  200b8c:	f84d ed08 	str.w	lr, [sp, #-8]!
  200b90:	f7ff ffc4 	bl	200b1c <__aeabi_cdrcmple>
  200b94:	bf34      	ite	cc
  200b96:	2001      	movcc	r0, #1
  200b98:	2000      	movcs	r0, #0
  200b9a:	f85d fb08 	ldr.w	pc, [sp], #8
  200b9e:	bf00      	nop

00200ba0 <__aeabi_d2iz>:
  200ba0:	ea4f 0241 	mov.w	r2, r1, lsl #1
  200ba4:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  200ba8:	d215      	bcs.n	200bd6 <__aeabi_d2iz+0x36>
  200baa:	d511      	bpl.n	200bd0 <__aeabi_d2iz+0x30>
  200bac:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  200bb0:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  200bb4:	d912      	bls.n	200bdc <__aeabi_d2iz+0x3c>
  200bb6:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  200bba:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  200bbe:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  200bc2:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  200bc6:	fa23 f002 	lsr.w	r0, r3, r2
  200bca:	bf18      	it	ne
  200bcc:	4240      	negne	r0, r0
  200bce:	4770      	bx	lr
  200bd0:	f04f 0000 	mov.w	r0, #0
  200bd4:	4770      	bx	lr
  200bd6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  200bda:	d105      	bne.n	200be8 <__aeabi_d2iz+0x48>
  200bdc:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
  200be0:	bf08      	it	eq
  200be2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  200be6:	4770      	bx	lr
  200be8:	f04f 0000 	mov.w	r0, #0
  200bec:	4770      	bx	lr
  200bee:	bf00      	nop

00200bf0 <__aeabi_d2uiz>:
  200bf0:	004a      	lsls	r2, r1, #1
  200bf2:	d211      	bcs.n	200c18 <__aeabi_d2uiz+0x28>
  200bf4:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  200bf8:	d211      	bcs.n	200c1e <__aeabi_d2uiz+0x2e>
  200bfa:	d50d      	bpl.n	200c18 <__aeabi_d2uiz+0x28>
  200bfc:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  200c00:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  200c04:	d40e      	bmi.n	200c24 <__aeabi_d2uiz+0x34>
  200c06:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  200c0a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  200c0e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  200c12:	fa23 f002 	lsr.w	r0, r3, r2
  200c16:	4770      	bx	lr
  200c18:	f04f 0000 	mov.w	r0, #0
  200c1c:	4770      	bx	lr
  200c1e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  200c22:	d102      	bne.n	200c2a <__aeabi_d2uiz+0x3a>
  200c24:	f04f 30ff 	mov.w	r0, #4294967295
  200c28:	4770      	bx	lr
  200c2a:	f04f 0000 	mov.w	r0, #0
  200c2e:	4770      	bx	lr

00200c30 <__aeabi_d2f>:
  200c30:	ea4f 0241 	mov.w	r2, r1, lsl #1
  200c34:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
  200c38:	bf24      	itt	cs
  200c3a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
  200c3e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
  200c42:	d90d      	bls.n	200c60 <__aeabi_d2f+0x30>
  200c44:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
  200c48:	ea4f 02c0 	mov.w	r2, r0, lsl #3
  200c4c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
  200c50:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
  200c54:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
  200c58:	bf08      	it	eq
  200c5a:	f020 0001 	biceq.w	r0, r0, #1
  200c5e:	4770      	bx	lr
  200c60:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
  200c64:	d121      	bne.n	200caa <__aeabi_d2f+0x7a>
  200c66:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
  200c6a:	bfbc      	itt	lt
  200c6c:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
  200c70:	4770      	bxlt	lr
  200c72:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  200c76:	ea4f 5252 	mov.w	r2, r2, lsr #21
  200c7a:	f1c2 0218 	rsb	r2, r2, #24
  200c7e:	f1c2 0c20 	rsb	ip, r2, #32
  200c82:	fa10 f30c 	lsls.w	r3, r0, ip
  200c86:	fa20 f002 	lsr.w	r0, r0, r2
  200c8a:	bf18      	it	ne
  200c8c:	f040 0001 	orrne.w	r0, r0, #1
  200c90:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  200c94:	ea4f 23d3 	mov.w	r3, r3, lsr #11
  200c98:	fa03 fc0c 	lsl.w	ip, r3, ip
  200c9c:	ea40 000c 	orr.w	r0, r0, ip
  200ca0:	fa23 f302 	lsr.w	r3, r3, r2
  200ca4:	ea4f 0343 	mov.w	r3, r3, lsl #1
  200ca8:	e7cc      	b.n	200c44 <__aeabi_d2f+0x14>
  200caa:	ea7f 5362 	mvns.w	r3, r2, asr #21
  200cae:	d107      	bne.n	200cc0 <__aeabi_d2f+0x90>
  200cb0:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
  200cb4:	bf1e      	ittt	ne
  200cb6:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
  200cba:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
  200cbe:	4770      	bxne	lr
  200cc0:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
  200cc4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
  200cc8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  200ccc:	4770      	bx	lr
  200cce:	bf00      	nop

00200cd0 <__aeabi_frsub>:
  200cd0:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
  200cd4:	e002      	b.n	200cdc <__addsf3>
  200cd6:	bf00      	nop

00200cd8 <__aeabi_fsub>:
  200cd8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

00200cdc <__addsf3>:
  200cdc:	0042      	lsls	r2, r0, #1
  200cde:	bf1f      	itttt	ne
  200ce0:	ea5f 0341 	movsne.w	r3, r1, lsl #1
  200ce4:	ea92 0f03 	teqne	r2, r3
  200ce8:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
  200cec:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
  200cf0:	d06a      	beq.n	200dc8 <__addsf3+0xec>
  200cf2:	ea4f 6212 	mov.w	r2, r2, lsr #24
  200cf6:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
  200cfa:	bfc1      	itttt	gt
  200cfc:	18d2      	addgt	r2, r2, r3
  200cfe:	4041      	eorgt	r1, r0
  200d00:	4048      	eorgt	r0, r1
  200d02:	4041      	eorgt	r1, r0
  200d04:	bfb8      	it	lt
  200d06:	425b      	neglt	r3, r3
  200d08:	2b19      	cmp	r3, #25
  200d0a:	bf88      	it	hi
  200d0c:	4770      	bxhi	lr
  200d0e:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
  200d12:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  200d16:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
  200d1a:	bf18      	it	ne
  200d1c:	4240      	negne	r0, r0
  200d1e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  200d22:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
  200d26:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  200d2a:	bf18      	it	ne
  200d2c:	4249      	negne	r1, r1
  200d2e:	ea92 0f03 	teq	r2, r3
  200d32:	d03f      	beq.n	200db4 <__addsf3+0xd8>
  200d34:	f1a2 0201 	sub.w	r2, r2, #1
  200d38:	fa41 fc03 	asr.w	ip, r1, r3
  200d3c:	eb10 000c 	adds.w	r0, r0, ip
  200d40:	f1c3 0320 	rsb	r3, r3, #32
  200d44:	fa01 f103 	lsl.w	r1, r1, r3
  200d48:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
  200d4c:	d502      	bpl.n	200d54 <__addsf3+0x78>
  200d4e:	4249      	negs	r1, r1
  200d50:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
  200d54:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
  200d58:	d313      	bcc.n	200d82 <__addsf3+0xa6>
  200d5a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
  200d5e:	d306      	bcc.n	200d6e <__addsf3+0x92>
  200d60:	0840      	lsrs	r0, r0, #1
  200d62:	ea4f 0131 	mov.w	r1, r1, rrx
  200d66:	f102 0201 	add.w	r2, r2, #1
  200d6a:	2afe      	cmp	r2, #254	; 0xfe
  200d6c:	d251      	bcs.n	200e12 <__addsf3+0x136>
  200d6e:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
  200d72:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
  200d76:	bf08      	it	eq
  200d78:	f020 0001 	biceq.w	r0, r0, #1
  200d7c:	ea40 0003 	orr.w	r0, r0, r3
  200d80:	4770      	bx	lr
  200d82:	0049      	lsls	r1, r1, #1
  200d84:	eb40 0000 	adc.w	r0, r0, r0
  200d88:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
  200d8c:	f1a2 0201 	sub.w	r2, r2, #1
  200d90:	d1ed      	bne.n	200d6e <__addsf3+0x92>
  200d92:	fab0 fc80 	clz	ip, r0
  200d96:	f1ac 0c08 	sub.w	ip, ip, #8
  200d9a:	ebb2 020c 	subs.w	r2, r2, ip
  200d9e:	fa00 f00c 	lsl.w	r0, r0, ip
  200da2:	bfaa      	itet	ge
  200da4:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
  200da8:	4252      	neglt	r2, r2
  200daa:	4318      	orrge	r0, r3
  200dac:	bfbc      	itt	lt
  200dae:	40d0      	lsrlt	r0, r2
  200db0:	4318      	orrlt	r0, r3
  200db2:	4770      	bx	lr
  200db4:	f092 0f00 	teq	r2, #0
  200db8:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
  200dbc:	bf06      	itte	eq
  200dbe:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
  200dc2:	3201      	addeq	r2, #1
  200dc4:	3b01      	subne	r3, #1
  200dc6:	e7b5      	b.n	200d34 <__addsf3+0x58>
  200dc8:	ea4f 0341 	mov.w	r3, r1, lsl #1
  200dcc:	ea7f 6c22 	mvns.w	ip, r2, asr #24
  200dd0:	bf18      	it	ne
  200dd2:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
  200dd6:	d021      	beq.n	200e1c <__addsf3+0x140>
  200dd8:	ea92 0f03 	teq	r2, r3
  200ddc:	d004      	beq.n	200de8 <__addsf3+0x10c>
  200dde:	f092 0f00 	teq	r2, #0
  200de2:	bf08      	it	eq
  200de4:	4608      	moveq	r0, r1
  200de6:	4770      	bx	lr
  200de8:	ea90 0f01 	teq	r0, r1
  200dec:	bf1c      	itt	ne
  200dee:	2000      	movne	r0, #0
  200df0:	4770      	bxne	lr
  200df2:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
  200df6:	d104      	bne.n	200e02 <__addsf3+0x126>
  200df8:	0040      	lsls	r0, r0, #1
  200dfa:	bf28      	it	cs
  200dfc:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
  200e00:	4770      	bx	lr
  200e02:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
  200e06:	bf3c      	itt	cc
  200e08:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
  200e0c:	4770      	bxcc	lr
  200e0e:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
  200e12:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
  200e16:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  200e1a:	4770      	bx	lr
  200e1c:	ea7f 6222 	mvns.w	r2, r2, asr #24
  200e20:	bf16      	itet	ne
  200e22:	4608      	movne	r0, r1
  200e24:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
  200e28:	4601      	movne	r1, r0
  200e2a:	0242      	lsls	r2, r0, #9
  200e2c:	bf06      	itte	eq
  200e2e:	ea5f 2341 	movseq.w	r3, r1, lsl #9
  200e32:	ea90 0f01 	teqeq	r0, r1
  200e36:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
  200e3a:	4770      	bx	lr

00200e3c <__aeabi_ui2f>:
  200e3c:	f04f 0300 	mov.w	r3, #0
  200e40:	e004      	b.n	200e4c <__aeabi_i2f+0x8>
  200e42:	bf00      	nop

00200e44 <__aeabi_i2f>:
  200e44:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
  200e48:	bf48      	it	mi
  200e4a:	4240      	negmi	r0, r0
  200e4c:	ea5f 0c00 	movs.w	ip, r0
  200e50:	bf08      	it	eq
  200e52:	4770      	bxeq	lr
  200e54:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
  200e58:	4601      	mov	r1, r0
  200e5a:	f04f 0000 	mov.w	r0, #0
  200e5e:	e01c      	b.n	200e9a <__aeabi_l2f+0x2a>

00200e60 <__aeabi_ul2f>:
  200e60:	ea50 0201 	orrs.w	r2, r0, r1
  200e64:	bf08      	it	eq
  200e66:	4770      	bxeq	lr
  200e68:	f04f 0300 	mov.w	r3, #0
  200e6c:	e00a      	b.n	200e84 <__aeabi_l2f+0x14>
  200e6e:	bf00      	nop

00200e70 <__aeabi_l2f>:
  200e70:	ea50 0201 	orrs.w	r2, r0, r1
  200e74:	bf08      	it	eq
  200e76:	4770      	bxeq	lr
  200e78:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
  200e7c:	d502      	bpl.n	200e84 <__aeabi_l2f+0x14>
  200e7e:	4240      	negs	r0, r0
  200e80:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  200e84:	ea5f 0c01 	movs.w	ip, r1
  200e88:	bf02      	ittt	eq
  200e8a:	4684      	moveq	ip, r0
  200e8c:	4601      	moveq	r1, r0
  200e8e:	2000      	moveq	r0, #0
  200e90:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
  200e94:	bf08      	it	eq
  200e96:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
  200e9a:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
  200e9e:	fabc f28c 	clz	r2, ip
  200ea2:	3a08      	subs	r2, #8
  200ea4:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
  200ea8:	db10      	blt.n	200ecc <__aeabi_l2f+0x5c>
  200eaa:	fa01 fc02 	lsl.w	ip, r1, r2
  200eae:	4463      	add	r3, ip
  200eb0:	fa00 fc02 	lsl.w	ip, r0, r2
  200eb4:	f1c2 0220 	rsb	r2, r2, #32
  200eb8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  200ebc:	fa20 f202 	lsr.w	r2, r0, r2
  200ec0:	eb43 0002 	adc.w	r0, r3, r2
  200ec4:	bf08      	it	eq
  200ec6:	f020 0001 	biceq.w	r0, r0, #1
  200eca:	4770      	bx	lr
  200ecc:	f102 0220 	add.w	r2, r2, #32
  200ed0:	fa01 fc02 	lsl.w	ip, r1, r2
  200ed4:	f1c2 0220 	rsb	r2, r2, #32
  200ed8:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
  200edc:	fa21 f202 	lsr.w	r2, r1, r2
  200ee0:	eb43 0002 	adc.w	r0, r3, r2
  200ee4:	bf08      	it	eq
  200ee6:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
  200eea:	4770      	bx	lr

00200eec <__aeabi_fmul>:
  200eec:	f04f 0cff 	mov.w	ip, #255	; 0xff
  200ef0:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
  200ef4:	bf1e      	ittt	ne
  200ef6:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
  200efa:	ea92 0f0c 	teqne	r2, ip
  200efe:	ea93 0f0c 	teqne	r3, ip
  200f02:	d06f      	beq.n	200fe4 <__aeabi_fmul+0xf8>
  200f04:	441a      	add	r2, r3
  200f06:	ea80 0c01 	eor.w	ip, r0, r1
  200f0a:	0240      	lsls	r0, r0, #9
  200f0c:	bf18      	it	ne
  200f0e:	ea5f 2141 	movsne.w	r1, r1, lsl #9
  200f12:	d01e      	beq.n	200f52 <__aeabi_fmul+0x66>
  200f14:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
  200f18:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
  200f1c:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
  200f20:	fba0 3101 	umull	r3, r1, r0, r1
  200f24:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
  200f28:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
  200f2c:	bf3e      	ittt	cc
  200f2e:	0049      	lslcc	r1, r1, #1
  200f30:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
  200f34:	005b      	lslcc	r3, r3, #1
  200f36:	ea40 0001 	orr.w	r0, r0, r1
  200f3a:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
  200f3e:	2afd      	cmp	r2, #253	; 0xfd
  200f40:	d81d      	bhi.n	200f7e <__aeabi_fmul+0x92>
  200f42:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
  200f46:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
  200f4a:	bf08      	it	eq
  200f4c:	f020 0001 	biceq.w	r0, r0, #1
  200f50:	4770      	bx	lr
  200f52:	f090 0f00 	teq	r0, #0
  200f56:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
  200f5a:	bf08      	it	eq
  200f5c:	0249      	lsleq	r1, r1, #9
  200f5e:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
  200f62:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
  200f66:	3a7f      	subs	r2, #127	; 0x7f
  200f68:	bfc2      	ittt	gt
  200f6a:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
  200f6e:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
  200f72:	4770      	bxgt	lr
  200f74:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  200f78:	f04f 0300 	mov.w	r3, #0
  200f7c:	3a01      	subs	r2, #1
  200f7e:	dc5d      	bgt.n	20103c <__aeabi_fmul+0x150>
  200f80:	f112 0f19 	cmn.w	r2, #25
  200f84:	bfdc      	itt	le
  200f86:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
  200f8a:	4770      	bxle	lr
  200f8c:	f1c2 0200 	rsb	r2, r2, #0
  200f90:	0041      	lsls	r1, r0, #1
  200f92:	fa21 f102 	lsr.w	r1, r1, r2
  200f96:	f1c2 0220 	rsb	r2, r2, #32
  200f9a:	fa00 fc02 	lsl.w	ip, r0, r2
  200f9e:	ea5f 0031 	movs.w	r0, r1, rrx
  200fa2:	f140 0000 	adc.w	r0, r0, #0
  200fa6:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
  200faa:	bf08      	it	eq
  200fac:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
  200fb0:	4770      	bx	lr
  200fb2:	f092 0f00 	teq	r2, #0
  200fb6:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
  200fba:	bf02      	ittt	eq
  200fbc:	0040      	lsleq	r0, r0, #1
  200fbe:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
  200fc2:	3a01      	subeq	r2, #1
  200fc4:	d0f9      	beq.n	200fba <__aeabi_fmul+0xce>
  200fc6:	ea40 000c 	orr.w	r0, r0, ip
  200fca:	f093 0f00 	teq	r3, #0
  200fce:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
  200fd2:	bf02      	ittt	eq
  200fd4:	0049      	lsleq	r1, r1, #1
  200fd6:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
  200fda:	3b01      	subeq	r3, #1
  200fdc:	d0f9      	beq.n	200fd2 <__aeabi_fmul+0xe6>
  200fde:	ea41 010c 	orr.w	r1, r1, ip
  200fe2:	e78f      	b.n	200f04 <__aeabi_fmul+0x18>
  200fe4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
  200fe8:	ea92 0f0c 	teq	r2, ip
  200fec:	bf18      	it	ne
  200fee:	ea93 0f0c 	teqne	r3, ip
  200ff2:	d00a      	beq.n	20100a <__aeabi_fmul+0x11e>
  200ff4:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
  200ff8:	bf18      	it	ne
  200ffa:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
  200ffe:	d1d8      	bne.n	200fb2 <__aeabi_fmul+0xc6>
  201000:	ea80 0001 	eor.w	r0, r0, r1
  201004:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
  201008:	4770      	bx	lr
  20100a:	f090 0f00 	teq	r0, #0
  20100e:	bf17      	itett	ne
  201010:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
  201014:	4608      	moveq	r0, r1
  201016:	f091 0f00 	teqne	r1, #0
  20101a:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
  20101e:	d014      	beq.n	20104a <__aeabi_fmul+0x15e>
  201020:	ea92 0f0c 	teq	r2, ip
  201024:	d101      	bne.n	20102a <__aeabi_fmul+0x13e>
  201026:	0242      	lsls	r2, r0, #9
  201028:	d10f      	bne.n	20104a <__aeabi_fmul+0x15e>
  20102a:	ea93 0f0c 	teq	r3, ip
  20102e:	d103      	bne.n	201038 <__aeabi_fmul+0x14c>
  201030:	024b      	lsls	r3, r1, #9
  201032:	bf18      	it	ne
  201034:	4608      	movne	r0, r1
  201036:	d108      	bne.n	20104a <__aeabi_fmul+0x15e>
  201038:	ea80 0001 	eor.w	r0, r0, r1
  20103c:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
  201040:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
  201044:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  201048:	4770      	bx	lr
  20104a:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
  20104e:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
  201052:	4770      	bx	lr

00201054 <__aeabi_fdiv>:
  201054:	f04f 0cff 	mov.w	ip, #255	; 0xff
  201058:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
  20105c:	bf1e      	ittt	ne
  20105e:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
  201062:	ea92 0f0c 	teqne	r2, ip
  201066:	ea93 0f0c 	teqne	r3, ip
  20106a:	d069      	beq.n	201140 <__aeabi_fdiv+0xec>
  20106c:	eba2 0203 	sub.w	r2, r2, r3
  201070:	ea80 0c01 	eor.w	ip, r0, r1
  201074:	0249      	lsls	r1, r1, #9
  201076:	ea4f 2040 	mov.w	r0, r0, lsl #9
  20107a:	d037      	beq.n	2010ec <__aeabi_fdiv+0x98>
  20107c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  201080:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
  201084:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
  201088:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
  20108c:	428b      	cmp	r3, r1
  20108e:	bf38      	it	cc
  201090:	005b      	lslcc	r3, r3, #1
  201092:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
  201096:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
  20109a:	428b      	cmp	r3, r1
  20109c:	bf24      	itt	cs
  20109e:	1a5b      	subcs	r3, r3, r1
  2010a0:	ea40 000c 	orrcs.w	r0, r0, ip
  2010a4:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
  2010a8:	bf24      	itt	cs
  2010aa:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
  2010ae:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  2010b2:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
  2010b6:	bf24      	itt	cs
  2010b8:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
  2010bc:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  2010c0:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
  2010c4:	bf24      	itt	cs
  2010c6:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
  2010ca:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  2010ce:	011b      	lsls	r3, r3, #4
  2010d0:	bf18      	it	ne
  2010d2:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
  2010d6:	d1e0      	bne.n	20109a <__aeabi_fdiv+0x46>
  2010d8:	2afd      	cmp	r2, #253	; 0xfd
  2010da:	f63f af50 	bhi.w	200f7e <__aeabi_fmul+0x92>
  2010de:	428b      	cmp	r3, r1
  2010e0:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
  2010e4:	bf08      	it	eq
  2010e6:	f020 0001 	biceq.w	r0, r0, #1
  2010ea:	4770      	bx	lr
  2010ec:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
  2010f0:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
  2010f4:	327f      	adds	r2, #127	; 0x7f
  2010f6:	bfc2      	ittt	gt
  2010f8:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
  2010fc:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
  201100:	4770      	bxgt	lr
  201102:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  201106:	f04f 0300 	mov.w	r3, #0
  20110a:	3a01      	subs	r2, #1
  20110c:	e737      	b.n	200f7e <__aeabi_fmul+0x92>
  20110e:	f092 0f00 	teq	r2, #0
  201112:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
  201116:	bf02      	ittt	eq
  201118:	0040      	lsleq	r0, r0, #1
  20111a:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
  20111e:	3a01      	subeq	r2, #1
  201120:	d0f9      	beq.n	201116 <__aeabi_fdiv+0xc2>
  201122:	ea40 000c 	orr.w	r0, r0, ip
  201126:	f093 0f00 	teq	r3, #0
  20112a:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
  20112e:	bf02      	ittt	eq
  201130:	0049      	lsleq	r1, r1, #1
  201132:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
  201136:	3b01      	subeq	r3, #1
  201138:	d0f9      	beq.n	20112e <__aeabi_fdiv+0xda>
  20113a:	ea41 010c 	orr.w	r1, r1, ip
  20113e:	e795      	b.n	20106c <__aeabi_fdiv+0x18>
  201140:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
  201144:	ea92 0f0c 	teq	r2, ip
  201148:	d108      	bne.n	20115c <__aeabi_fdiv+0x108>
  20114a:	0242      	lsls	r2, r0, #9
  20114c:	f47f af7d 	bne.w	20104a <__aeabi_fmul+0x15e>
  201150:	ea93 0f0c 	teq	r3, ip
  201154:	f47f af70 	bne.w	201038 <__aeabi_fmul+0x14c>
  201158:	4608      	mov	r0, r1
  20115a:	e776      	b.n	20104a <__aeabi_fmul+0x15e>
  20115c:	ea93 0f0c 	teq	r3, ip
  201160:	d104      	bne.n	20116c <__aeabi_fdiv+0x118>
  201162:	024b      	lsls	r3, r1, #9
  201164:	f43f af4c 	beq.w	201000 <__aeabi_fmul+0x114>
  201168:	4608      	mov	r0, r1
  20116a:	e76e      	b.n	20104a <__aeabi_fmul+0x15e>
  20116c:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
  201170:	bf18      	it	ne
  201172:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
  201176:	d1ca      	bne.n	20110e <__aeabi_fdiv+0xba>
  201178:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
  20117c:	f47f af5c 	bne.w	201038 <__aeabi_fmul+0x14c>
  201180:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
  201184:	f47f af3c 	bne.w	201000 <__aeabi_fmul+0x114>
  201188:	e75f      	b.n	20104a <__aeabi_fmul+0x15e>
  20118a:	bf00      	nop

0020118c <__gesf2>:
  20118c:	f04f 3cff 	mov.w	ip, #4294967295
  201190:	e006      	b.n	2011a0 <__cmpsf2+0x4>
  201192:	bf00      	nop

00201194 <__lesf2>:
  201194:	f04f 0c01 	mov.w	ip, #1
  201198:	e002      	b.n	2011a0 <__cmpsf2+0x4>
  20119a:	bf00      	nop

0020119c <__cmpsf2>:
  20119c:	f04f 0c01 	mov.w	ip, #1
  2011a0:	f84d cd04 	str.w	ip, [sp, #-4]!
  2011a4:	ea4f 0240 	mov.w	r2, r0, lsl #1
  2011a8:	ea4f 0341 	mov.w	r3, r1, lsl #1
  2011ac:	ea7f 6c22 	mvns.w	ip, r2, asr #24
  2011b0:	bf18      	it	ne
  2011b2:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
  2011b6:	d011      	beq.n	2011dc <__cmpsf2+0x40>
  2011b8:	b001      	add	sp, #4
  2011ba:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
  2011be:	bf18      	it	ne
  2011c0:	ea90 0f01 	teqne	r0, r1
  2011c4:	bf58      	it	pl
  2011c6:	ebb2 0003 	subspl.w	r0, r2, r3
  2011ca:	bf88      	it	hi
  2011cc:	17c8      	asrhi	r0, r1, #31
  2011ce:	bf38      	it	cc
  2011d0:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
  2011d4:	bf18      	it	ne
  2011d6:	f040 0001 	orrne.w	r0, r0, #1
  2011da:	4770      	bx	lr
  2011dc:	ea7f 6c22 	mvns.w	ip, r2, asr #24
  2011e0:	d102      	bne.n	2011e8 <__cmpsf2+0x4c>
  2011e2:	ea5f 2c40 	movs.w	ip, r0, lsl #9
  2011e6:	d105      	bne.n	2011f4 <__cmpsf2+0x58>
  2011e8:	ea7f 6c23 	mvns.w	ip, r3, asr #24
  2011ec:	d1e4      	bne.n	2011b8 <__cmpsf2+0x1c>
  2011ee:	ea5f 2c41 	movs.w	ip, r1, lsl #9
  2011f2:	d0e1      	beq.n	2011b8 <__cmpsf2+0x1c>
  2011f4:	f85d 0b04 	ldr.w	r0, [sp], #4
  2011f8:	4770      	bx	lr
  2011fa:	bf00      	nop

002011fc <__aeabi_cfrcmple>:
  2011fc:	4684      	mov	ip, r0
  2011fe:	4608      	mov	r0, r1
  201200:	4661      	mov	r1, ip
  201202:	e7ff      	b.n	201204 <__aeabi_cfcmpeq>

00201204 <__aeabi_cfcmpeq>:
  201204:	b50f      	push	{r0, r1, r2, r3, lr}
  201206:	f7ff ffc9 	bl	20119c <__cmpsf2>
  20120a:	2800      	cmp	r0, #0
  20120c:	bf48      	it	mi
  20120e:	f110 0f00 	cmnmi.w	r0, #0
  201212:	bd0f      	pop	{r0, r1, r2, r3, pc}

00201214 <__aeabi_fcmpeq>:
  201214:	f84d ed08 	str.w	lr, [sp, #-8]!
  201218:	f7ff fff4 	bl	201204 <__aeabi_cfcmpeq>
  20121c:	bf0c      	ite	eq
  20121e:	2001      	moveq	r0, #1
  201220:	2000      	movne	r0, #0
  201222:	f85d fb08 	ldr.w	pc, [sp], #8
  201226:	bf00      	nop

00201228 <__aeabi_fcmplt>:
  201228:	f84d ed08 	str.w	lr, [sp, #-8]!
  20122c:	f7ff ffea 	bl	201204 <__aeabi_cfcmpeq>
  201230:	bf34      	ite	cc
  201232:	2001      	movcc	r0, #1
  201234:	2000      	movcs	r0, #0
  201236:	f85d fb08 	ldr.w	pc, [sp], #8
  20123a:	bf00      	nop

0020123c <__aeabi_fcmple>:
  20123c:	f84d ed08 	str.w	lr, [sp, #-8]!
  201240:	f7ff ffe0 	bl	201204 <__aeabi_cfcmpeq>
  201244:	bf94      	ite	ls
  201246:	2001      	movls	r0, #1
  201248:	2000      	movhi	r0, #0
  20124a:	f85d fb08 	ldr.w	pc, [sp], #8
  20124e:	bf00      	nop

00201250 <__aeabi_fcmpge>:
  201250:	f84d ed08 	str.w	lr, [sp, #-8]!
  201254:	f7ff ffd2 	bl	2011fc <__aeabi_cfrcmple>
  201258:	bf94      	ite	ls
  20125a:	2001      	movls	r0, #1
  20125c:	2000      	movhi	r0, #0
  20125e:	f85d fb08 	ldr.w	pc, [sp], #8
  201262:	bf00      	nop

00201264 <__aeabi_fcmpgt>:
  201264:	f84d ed08 	str.w	lr, [sp, #-8]!
  201268:	f7ff ffc8 	bl	2011fc <__aeabi_cfrcmple>
  20126c:	bf34      	ite	cc
  20126e:	2001      	movcc	r0, #1
  201270:	2000      	movcs	r0, #0
  201272:	f85d fb08 	ldr.w	pc, [sp], #8
  201276:	bf00      	nop

00201278 <__aeabi_f2iz>:
  201278:	ea4f 0240 	mov.w	r2, r0, lsl #1
  20127c:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
  201280:	d30f      	bcc.n	2012a2 <__aeabi_f2iz+0x2a>
  201282:	f04f 039e 	mov.w	r3, #158	; 0x9e
  201286:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
  20128a:	d90d      	bls.n	2012a8 <__aeabi_f2iz+0x30>
  20128c:	ea4f 2300 	mov.w	r3, r0, lsl #8
  201290:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  201294:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
  201298:	fa23 f002 	lsr.w	r0, r3, r2
  20129c:	bf18      	it	ne
  20129e:	4240      	negne	r0, r0
  2012a0:	4770      	bx	lr
  2012a2:	f04f 0000 	mov.w	r0, #0
  2012a6:	4770      	bx	lr
  2012a8:	f112 0f61 	cmn.w	r2, #97	; 0x61
  2012ac:	d101      	bne.n	2012b2 <__aeabi_f2iz+0x3a>
  2012ae:	0242      	lsls	r2, r0, #9
  2012b0:	d105      	bne.n	2012be <__aeabi_f2iz+0x46>
  2012b2:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
  2012b6:	bf08      	it	eq
  2012b8:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  2012bc:	4770      	bx	lr
  2012be:	f04f 0000 	mov.w	r0, #0
  2012c2:	4770      	bx	lr

002012c4 <__aeabi_f2uiz>:
  2012c4:	0042      	lsls	r2, r0, #1
  2012c6:	d20e      	bcs.n	2012e6 <__aeabi_f2uiz+0x22>
  2012c8:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
  2012cc:	d30b      	bcc.n	2012e6 <__aeabi_f2uiz+0x22>
  2012ce:	f04f 039e 	mov.w	r3, #158	; 0x9e
  2012d2:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
  2012d6:	d409      	bmi.n	2012ec <__aeabi_f2uiz+0x28>
  2012d8:	ea4f 2300 	mov.w	r3, r0, lsl #8
  2012dc:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  2012e0:	fa23 f002 	lsr.w	r0, r3, r2
  2012e4:	4770      	bx	lr
  2012e6:	f04f 0000 	mov.w	r0, #0
  2012ea:	4770      	bx	lr
  2012ec:	f112 0f61 	cmn.w	r2, #97	; 0x61
  2012f0:	d101      	bne.n	2012f6 <__aeabi_f2uiz+0x32>
  2012f2:	0242      	lsls	r2, r0, #9
  2012f4:	d102      	bne.n	2012fc <__aeabi_f2uiz+0x38>
  2012f6:	f04f 30ff 	mov.w	r0, #4294967295
  2012fa:	4770      	bx	lr
  2012fc:	f04f 0000 	mov.w	r0, #0
  201300:	4770      	bx	lr
  201302:	bf00      	nop
	...

00201310 <main>:


bool parking_enable = false;

int main(void)
{
  201310:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  201314:	4b81      	ldr	r3, [pc, #516]	; (20151c <main+0x20c>)
  201316:	b091      	sub	sp, #68	; 0x44
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
  201318:	2500      	movs	r5, #0
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
  20131a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
  20131e:	4619      	mov	r1, r3
  201320:	af00      	add	r7, sp, #0
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  201322:	331c      	adds	r3, #28
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  201324:	f04f 36ff 	mov.w	r6, #4294967295
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
  201328:	f04f 0800 	mov.w	r8, #0
  20132c:	f04f 0900 	mov.w	r9, #0
  201330:	f843 1c1c 	str.w	r1, [r3, #-28]
  chTMStartMeasurementX(&tm);
  201334:	f107 0028 	add.w	r0, r7, #40	; 0x28
  tqp->prev = (thread_t *)tqp;
  201338:	6049      	str	r1, [r1, #4]
  tqp->next = (thread_t *)tqp;
  20133a:	460c      	mov	r4, r1
  ch.vtlist.delta = (systime_t)-1;
  20133c:	848a      	strh	r2, [r1, #36]	; 0x24
  20133e:	608d      	str	r5, [r1, #8]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
  201340:	84cd      	strh	r5, [r1, #38]	; 0x26
  ch.tm.offset = (rtcnt_t)0;
  201342:	670d      	str	r5, [r1, #112]	; 0x70
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  201344:	61cb      	str	r3, [r1, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  201346:	620b      	str	r3, [r1, #32]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
  201348:	6109      	str	r1, [r1, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
  20134a:	6149      	str	r1, [r1, #20]
  tmp->worst      = (rtcnt_t)0;
  20134c:	62fd      	str	r5, [r7, #44]	; 0x2c
  tmp->last       = (rtcnt_t)0;
  20134e:	633d      	str	r5, [r7, #48]	; 0x30
  tmp->n          = (ucnt_t)0;
  201350:	637d      	str	r5, [r7, #52]	; 0x34
  tmp->best       = (rtcnt_t)-1;
  201352:	62be      	str	r6, [r7, #40]	; 0x28
  tmp->cumulative = (rttime_t)0;
  201354:	e9c7 890e 	strd	r8, r9, [r7, #56]	; 0x38
  chTMStartMeasurementX(&tm);
  201358:	f002 ffba 	bl	2042d0 <chTMStartMeasurementX.constprop.30>
  chTMStopMeasurementX(&tm);
  20135c:	f107 0028 	add.w	r0, r7, #40	; 0x28
  201360:	f001 fb46 	bl	2029f0 <chTMStopMeasurementX>
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
  201364:	4b6e      	ldr	r3, [pc, #440]	; (201520 <main+0x210>)
  201366:	496f      	ldr	r1, [pc, #444]	; (201524 <main+0x214>)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  201368:	f64f 09ff 	movw	r9, #63743	; 0xf8ff
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
  20136c:	4a6e      	ldr	r2, [pc, #440]	; (201528 <main+0x218>)
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  20136e:	f04f 0c80 	mov.w	ip, #128	; 0x80
  201372:	6019      	str	r1, [r3, #0]
  201374:	f103 0810 	add.w	r8, r3, #16
  201378:	496c      	ldr	r1, [pc, #432]	; (20152c <main+0x21c>)
  ch.tm.offset = tm.last;
  20137a:	6b38      	ldr	r0, [r7, #48]	; 0x30
  20137c:	6011      	str	r1, [r2, #0]
  endmem  = __heap_end__;
  20137e:	4a6c      	ldr	r2, [pc, #432]	; (201530 <main+0x220>)
  201380:	496c      	ldr	r1, [pc, #432]	; (201534 <main+0x224>)
  201382:	6238      	str	r0, [r7, #32]
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
  201384:	4620      	mov	r0, r4
  201386:	6011      	str	r1, [r2, #0]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  201388:	2201      	movs	r2, #1
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  20138a:	496b      	ldr	r1, [pc, #428]	; (201538 <main+0x228>)
  tp->flags     = CH_FLAG_MODE_STATIC;
  20138c:	f884 504d 	strb.w	r5, [r4, #77]	; 0x4d
  tp->mtxlist   = NULL;
  201390:	6665      	str	r5, [r4, #100]	; 0x64
  201392:	f8d1 e00c 	ldr.w	lr, [r1, #12]
  tp->epending  = (eventmask_t)0;
  201396:	6625      	str	r5, [r4, #96]	; 0x60
  tp->name      = name;
  REG_INSERT(tp);
  201398:	63e4      	str	r4, [r4, #60]	; 0x3c
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  20139a:	ea0e 0e09 	and.w	lr, lr, r9
  20139e:	6a3c      	ldr	r4, [r7, #32]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
  2013a0:	619d      	str	r5, [r3, #24]
  2013a2:	6704      	str	r4, [r0, #112]	; 0x70
  tp->name      = name;
  2013a4:	4c5d      	ldr	r4, [pc, #372]	; (20151c <main+0x20c>)
  2013a6:	4865      	ldr	r0, [pc, #404]	; (20153c <main+0x22c>)
  tp->prio      = prio;
  2013a8:	f8c4 c034 	str.w	ip, [r4, #52]	; 0x34
  REG_INSERT(tp);
  2013ac:	342c      	adds	r4, #44	; 0x2c
  tp->name      = name;
  2013ae:	61a0      	str	r0, [r4, #24]
  reg_value  =  (reg_value                                   |
  2013b0:	4863      	ldr	r0, [pc, #396]	; (201540 <main+0x230>)
  tp->realprio  = prio;
  2013b2:	f8c4 c03c 	str.w	ip, [r4, #60]	; 0x3c
  2013b6:	ea4e 0000 	orr.w	r0, lr, r0
  REG_INSERT(tp);
  2013ba:	f854 ec18 	ldr.w	lr, [r4, #-24]
  tp->refs      = (trefs_t)1;
  2013be:	f884 2022 	strb.w	r2, [r4, #34]	; 0x22
  REG_INSERT(tp);
  2013c2:	f8c4 e014 	str.w	lr, [r4, #20]
  tlp->next = (thread_t *)tlp;
  2013c6:	f104 0c28 	add.w	ip, r4, #40	; 0x28
  tqp->next = (thread_t *)tqp;
  2013ca:	f8c3 8010 	str.w	r8, [r3, #16]
  tqp->prev = (thread_t *)tqp;
  2013ce:	f8c3 8014 	str.w	r8, [r3, #20]
  2013d2:	f8ce 4010 	str.w	r4, [lr, #16]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  2013d6:	f8df e198 	ldr.w	lr, [pc, #408]	; 201570 <main+0x260>
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
  2013da:	60c8      	str	r0, [r1, #12]
  tlp->next = (thread_t *)tlp;
  2013dc:	f1a4 002c 	sub.w	r0, r4, #44	; 0x2c
  H_NEXT(&default_heap.header) = NULL;
  2013e0:	609d      	str	r5, [r3, #8]
  H_PAGES(&default_heap.header) = 0;
  2013e2:	60dd      	str	r5, [r3, #12]
  tqp->next = (thread_t *)tqp;
  2013e4:	f100 0858 	add.w	r8, r0, #88	; 0x58
  2013e8:	f8de 300c 	ldr.w	r3, [lr, #12]
  2013ec:	6144      	str	r4, [r0, #20]
  2013ee:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
  2013f2:	6184      	str	r4, [r0, #24]
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
  2013f4:	6485      	str	r5, [r0, #72]	; 0x48
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
  2013f6:	f880 204c 	strb.w	r2, [r0, #76]	; 0x4c
  tlp->next = (thread_t *)tlp;
  2013fa:	f8c0 c054 	str.w	ip, [r0, #84]	; 0x54
  2013fe:	f8ce 300c 	str.w	r3, [lr, #12]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  201402:	f04f 0e10 	mov.w	lr, #16
  tqp->next = (thread_t *)tqp;
  201406:	f8c0 8058 	str.w	r8, [r0, #88]	; 0x58
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
  20140a:	4b4e      	ldr	r3, [pc, #312]	; (201544 <main+0x234>)
  tqp->prev = (thread_t *)tqp;
  20140c:	f8c0 805c 	str.w	r8, [r0, #92]	; 0x5c
  201410:	484d      	ldr	r0, [pc, #308]	; (201548 <main+0x238>)
  201412:	f8c3 0fb0 	str.w	r0, [r3, #4016]	; 0xfb0
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
  201416:	6818      	ldr	r0, [r3, #0]
  201418:	4310      	orrs	r0, r2
  20141a:	6018      	str	r0, [r3, #0]
  20141c:	f04f 0320 	mov.w	r3, #32
  201420:	f881 e01f 	strb.w	lr, [r1, #31]
  201424:	f881 3022 	strb.w	r3, [r1, #34]	; 0x22
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
  201428:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
  20142c:	b662      	cpsie	i
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
  20142e:	2320      	movs	r3, #32
  201430:	f383 8811 	msr	BASEPRI, r3
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
  201434:	4b45      	ldr	r3, [pc, #276]	; (20154c <main+0x23c>)
  tp->state     = CH_STATE_WTSTART;
  201436:	f04f 0c02 	mov.w	ip, #2
  REG_INSERT(tp);
  20143a:	f854 1c18 	ldr.w	r1, [r4, #-24]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  20143e:	f103 006c 	add.w	r0, r3, #108	; 0x6c
  tp->prio      = prio;
  201442:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  tp->realprio  = prio;
  201446:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
  tlp->next = (thread_t *)tlp;
  20144a:	f103 0eb8 	add.w	lr, r3, #184	; 0xb8
  tp->refs      = (trefs_t)1;
  20144e:	f883 20b2 	strb.w	r2, [r3, #178]	; 0xb2
  REG_INSERT(tp);
  201452:	f1a4 022c 	sub.w	r2, r4, #44	; 0x2c
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  201456:	4c3e      	ldr	r4, [pc, #248]	; (201550 <main+0x240>)
  REG_INSERT(tp);
  201458:	f8c3 10a4 	str.w	r1, [r3, #164]	; 0xa4
  20145c:	f103 0190 	add.w	r1, r3, #144	; 0x90
  201460:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  tqp->next = (thread_t *)tqp;
  201464:	f103 02bc 	add.w	r2, r3, #188	; 0xbc
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  201468:	f8c3 009c 	str.w	r0, [r3, #156]	; 0x9c
  tp->state     = CH_STATE_WTSTART;
  20146c:	f883 c0b0 	strb.w	ip, [r3, #176]	; 0xb0
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  201470:	f8c3 408c 	str.w	r4, [r3, #140]	; 0x8c
  tp->name      = name;
  201474:	f8df c0fc 	ldr.w	ip, [pc, #252]	; 201574 <main+0x264>
  REG_INSERT(tp);
  201478:	f858 4c44 	ldr.w	r4, [r8, #-68]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  20147c:	4835      	ldr	r0, [pc, #212]	; (201554 <main+0x244>)
  20147e:	671d      	str	r5, [r3, #112]	; 0x70
  201480:	66d8      	str	r0, [r3, #108]	; 0x6c
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
  chSchWakeupS(tp, MSG_OK);
  201482:	4608      	mov	r0, r1
  tp->flags     = CH_FLAG_MODE_STATIC;
  201484:	f883 50b1 	strb.w	r5, [r3, #177]	; 0xb1
  tp->mtxlist   = NULL;
  201488:	f8c3 50c8 	str.w	r5, [r3, #200]	; 0xc8
  tp->epending  = (eventmask_t)0;
  20148c:	f8c3 50c4 	str.w	r5, [r3, #196]	; 0xc4
  tp->wabase = tdp->wbase;
  201490:	f8c3 30ac 	str.w	r3, [r3, #172]	; 0xac
  tp->name      = name;
  201494:	f8c3 c0a8 	str.w	ip, [r3, #168]	; 0xa8
  REG_INSERT(tp);
  201498:	6121      	str	r1, [r4, #16]
  tlp->next = (thread_t *)tlp;
  20149a:	f8c3 e0b8 	str.w	lr, [r3, #184]	; 0xb8
  tqp->next = (thread_t *)tqp;
  20149e:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
  tqp->prev = (thread_t *)tqp;
  2014a2:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
  2014a6:	f848 1c44 	str.w	r1, [r8, #-68]
  chSchWakeupS(tp, MSG_OK);
  2014aa:	f002 fee1 	bl	204270 <chSchWakeupS.constprop.34>
  2014ae:	f385 8811 	msr	BASEPRI, r5
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
  2014b2:	4b29      	ldr	r3, [pc, #164]	; (201558 <main+0x248>)
  PWR->CR1 |= PWR_CR1_DBP;
  2014b4:	4929      	ldr	r1, [pc, #164]	; (20155c <main+0x24c>)
  rccResetAHB1(~0);
  2014b6:	691a      	ldr	r2, [r3, #16]
  2014b8:	611e      	str	r6, [r3, #16]
  2014ba:	611d      	str	r5, [r3, #16]
  rccResetAHB2(~0);
  2014bc:	695a      	ldr	r2, [r3, #20]
  2014be:	615e      	str	r6, [r3, #20]
  2014c0:	615d      	str	r5, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
  2014c2:	6a1a      	ldr	r2, [r3, #32]
  2014c4:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
  2014c8:	621a      	str	r2, [r3, #32]
  2014ca:	621d      	str	r5, [r3, #32]
  rccResetAPB2(~0);
  2014cc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  2014ce:	625e      	str	r6, [r3, #36]	; 0x24
  2014d0:	625d      	str	r5, [r3, #36]	; 0x24
  PWR->CR1 |= PWR_CR1_DBP;
  2014d2:	680a      	ldr	r2, [r1, #0]
  2014d4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
  2014d8:	600a      	str	r2, [r1, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
  2014da:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  2014dc:	f402 7240 	and.w	r2, r2, #768	; 0x300
  2014e0:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
  2014e4:	d003      	beq.n	2014ee <main+0x1de>
    RCC->BDCR = RCC_BDCR_BDRST;
  2014e6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  2014ea:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
  2014ec:	671d      	str	r5, [r3, #112]	; 0x70
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
  2014ee:	4b1a      	ldr	r3, [pc, #104]	; (201558 <main+0x248>)
  2014f0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
  2014f2:	4619      	mov	r1, r3
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
  2014f4:	f042 0219 	orr.w	r2, r2, #25
  2014f8:	671a      	str	r2, [r3, #112]	; 0x70
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
  2014fa:	6f0b      	ldr	r3, [r1, #112]	; 0x70
  2014fc:	0798      	lsls	r0, r3, #30
  2014fe:	d5fc      	bpl.n	2014fa <main+0x1ea>
  PWR->CSR1 &= ~PWR_CSR1_BRE;
  201500:	4d16      	ldr	r5, [pc, #88]	; (20155c <main+0x24c>)
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  201502:	2000      	movs	r0, #0
  201504:	4e16      	ldr	r6, [pc, #88]	; (201560 <main+0x250>)
  201506:	686a      	ldr	r2, [r5, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
  201508:	4686      	mov	lr, r0
    _stm32_dma_streams[i].stream->CR = 0U;
  20150a:	4603      	mov	r3, r0
  20150c:	4915      	ldr	r1, [pc, #84]	; (201564 <main+0x254>)
  20150e:	f422 7200 	bic.w	r2, r2, #512	; 0x200
  201512:	606a      	str	r2, [r5, #4]
  dma_streams_mask = 0U;
  201514:	6030      	str	r0, [r6, #0]
  201516:	4a14      	ldr	r2, [pc, #80]	; (201568 <main+0x258>)
  201518:	4814      	ldr	r0, [pc, #80]	; (20156c <main+0x25c>)
  20151a:	e02f      	b.n	20157c <main+0x26c>
  20151c:	20000d78 	.word	0x20000d78
  201520:	200009b8 	.word	0x200009b8
  201524:	00202521 	.word	0x00202521
  201528:	200009fc 	.word	0x200009fc
  20152c:	20020668 	.word	0x20020668
  201530:	200009d8 	.word	0x200009d8
  201534:	20080000 	.word	0x20080000
  201538:	e000ed00 	.word	0xe000ed00
  20153c:	08005060 	.word	0x08005060
  201540:	05fa0300 	.word	0x05fa0300
  201544:	e0001000 	.word	0xe0001000
  201548:	c5acce55 	.word	0xc5acce55
  20154c:	200008e0 	.word	0x200008e0
  201550:	002002e5 	.word	0x002002e5
  201554:	002025e1 	.word	0x002025e1
  201558:	40023800 	.word	0x40023800
  20155c:	40007000 	.word	0x40007000
  201560:	20000e78 	.word	0x20000e78
  201564:	08004fac 	.word	0x08004fac
  201568:	40026010 	.word	0x40026010
  20156c:	20000df8 	.word	0x20000df8
  201570:	e000edf0 	.word	0xe000edf0
  201574:	08005094 	.word	0x08005094
  201578:	f851 2c0c 	ldr.w	r2, [r1, #-12]
    _stm32_dma_streams[i].stream->CR = 0U;
  20157c:	6013      	str	r3, [r2, #0]
  20157e:	310c      	adds	r1, #12
    dma_isr_redir[i].dma_func = NULL;
  201580:	f840 303e 	str.w	r3, [r0, lr, lsl #3]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
  201584:	f10e 0e01 	add.w	lr, lr, #1
  201588:	f1be 0f10 	cmp.w	lr, #16
  20158c:	d1f4      	bne.n	201578 <main+0x268>
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
  20158e:	f04f 3cff 	mov.w	ip, #4294967295
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
  201592:	4ad6      	ldr	r2, [pc, #856]	; (2018ec <main+0x5dc>)
  201594:	4ed6      	ldr	r6, [pc, #856]	; (2018f0 <main+0x5e0>)
  201596:	f240 75ff 	movw	r5, #2047	; 0x7ff
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
  20159a:	49d6      	ldr	r1, [pc, #856]	; (2018f4 <main+0x5e4>)
  gpiop->ODR     = config->odr;
  20159c:	f64f 70ff 	movw	r0, #65535	; 0xffff
  DMA1->LIFCR = 0xFFFFFFFFU;
  2015a0:	f8c6 c008 	str.w	ip, [r6, #8]
  2015a4:	f64b 747e 	movw	r4, #49022	; 0xbf7e
  DMA1->HIFCR = 0xFFFFFFFFU;
  2015a8:	f8c6 c00c 	str.w	ip, [r6, #12]
  gpiop->PUPDR   = config->pupdr;
  2015ac:	f04f 3a55 	mov.w	sl, #1431655765	; 0x55555555
  DMA2->LIFCR = 0xFFFFFFFFU;
  2015b0:	f8c1 c008 	str.w	ip, [r1, #8]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2015b4:	f04f 0960 	mov.w	r9, #96	; 0x60
  DMA2->HIFCR = 0xFFFFFFFFU;
  2015b8:	f8c1 c00c 	str.w	ip, [r1, #12]
  RCC->AHB1ENR   |= AHB1_EN_MASK;
  2015bc:	6b16      	ldr	r6, [r2, #48]	; 0x30
  gpiop->AFRH    = config->afrh;
  2015be:	f8df 839c 	ldr.w	r8, [pc, #924]	; 20195c <main+0x64c>
  RCC->AHB1ENR   |= AHB1_EN_MASK;
  2015c2:	432e      	orrs	r6, r5
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
  2015c4:	49cc      	ldr	r1, [pc, #816]	; (2018f8 <main+0x5e8>)
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
}
#else
void sdObjectInit(SerialDriver *sdp) {

  sdp->vmt = &vmt;
  2015c6:	f8df b398 	ldr.w	fp, [pc, #920]	; 201960 <main+0x650>
  2015ca:	6316      	str	r6, [r2, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
  2015cc:	6d16      	ldr	r6, [r2, #80]	; 0x50
  2015ce:	432e      	orrs	r6, r5
  2015d0:	4dca      	ldr	r5, [pc, #808]	; (2018fc <main+0x5ec>)
  2015d2:	6516      	str	r6, [r2, #80]	; 0x50
  gpiop->PUPDR   = config->pupdr;
  2015d4:	f5a2 32f1 	sub.w	r2, r2, #123392	; 0x1e200
  gpiop->OTYPER  = config->otyper;
  2015d8:	4ec9      	ldr	r6, [pc, #804]	; (201900 <main+0x5f0>)
  gpiop->PUPDR   = config->pupdr;
  2015da:	3aaf      	subs	r2, #175	; 0xaf
  gpiop->OTYPER  = config->otyper;
  2015dc:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
  2015de:	f8c6 c008 	str.w	ip, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
  2015e2:	60f2      	str	r2, [r6, #12]
  gpiop->AFRL    = config->afrl;
  2015e4:	4ac7      	ldr	r2, [pc, #796]	; (201904 <main+0x5f4>)
  gpiop->ODR     = config->odr;
  2015e6:	6170      	str	r0, [r6, #20]
  gpiop->AFRL    = config->afrl;
  2015e8:	6232      	str	r2, [r6, #32]
  2015ea:	2201      	movs	r2, #1
  gpiop->AFRH    = config->afrh;
  2015ec:	f8c6 8024 	str.w	r8, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
  2015f0:	f8df 8370 	ldr.w	r8, [pc, #880]	; 201964 <main+0x654>
  2015f4:	f8c6 8000 	str.w	r8, [r6]
  gpiop->OTYPER  = config->otyper;
  2015f8:	f8c6 3404 	str.w	r3, [r6, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
  2015fc:	f8c6 c408 	str.w	ip, [r6, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
  201600:	f10c 4c8a 	add.w	ip, ip, #1157627904	; 0x45000000
  201604:	f8df 8360 	ldr.w	r8, [pc, #864]	; 201968 <main+0x658>
  201608:	f10c 1c55 	add.w	ip, ip, #5570645	; 0x550055
  20160c:	f50c 5ca8 	add.w	ip, ip, #5376	; 0x1500
  201610:	f8c6 c40c 	str.w	ip, [r6, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
  201614:	f8c6 4414 	str.w	r4, [r6, #1044]	; 0x414
  gpiop->AFRH    = config->afrh;
  201618:	f44f 0430 	mov.w	r4, #11534336	; 0xb00000
  gpiop->MODER   = config->moder;
  20161c:	f8df c34c 	ldr.w	ip, [pc, #844]	; 20196c <main+0x65c>
  gpiop->AFRL    = config->afrl;
  201620:	f8c6 3420 	str.w	r3, [r6, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
  201624:	f8c6 4424 	str.w	r4, [r6, #1060]	; 0x424
  gpiop->OSPEEDR = config->ospeedr;
  201628:	f06f 4470 	mvn.w	r4, #4026531840	; 0xf0000000
  gpiop->MODER   = config->moder;
  20162c:	f8c6 c400 	str.w	ip, [r6, #1024]	; 0x400
  gpiop->OTYPER  = config->otyper;
  201630:	f8df c33c 	ldr.w	ip, [pc, #828]	; 201970 <main+0x660>
  201634:	4eb4      	ldr	r6, [pc, #720]	; (201908 <main+0x5f8>)
  201636:	f8cc 3004 	str.w	r3, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
  20163a:	f8cc 4008 	str.w	r4, [ip, #8]
  gpiop->MODER   = config->moder;
  20163e:	f640 2408 	movw	r4, #2568	; 0xa08
  gpiop->PUPDR   = config->pupdr;
  201642:	f8cc 800c 	str.w	r8, [ip, #12]
  gpiop->AFRL    = config->afrl;
  201646:	f8df 832c 	ldr.w	r8, [pc, #812]	; 201974 <main+0x664>
  gpiop->ODR     = config->odr;
  20164a:	f8cc 0014 	str.w	r0, [ip, #20]
  gpiop->AFRL    = config->afrl;
  20164e:	f8cc 8020 	str.w	r8, [ip, #32]
  gpiop->AFRH    = config->afrh;
  201652:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
  201656:	f8cc 4000 	str.w	r4, [ip]
  gpiop->OSPEEDR = config->ospeedr;
  20165a:	f46f 1440 	mvn.w	r4, #3145728	; 0x300000
  gpiop->OTYPER  = config->otyper;
  20165e:	f8cc 3404 	str.w	r3, [ip, #1028]	; 0x404
  gpiop->PUPDR   = config->pupdr;
  201662:	f8df 8314 	ldr.w	r8, [pc, #788]	; 201978 <main+0x668>
  gpiop->OSPEEDR = config->ospeedr;
  201666:	f8cc 4408 	str.w	r4, [ip, #1032]	; 0x408
  gpiop->AFRH    = config->afrh;
  20166a:	2477      	movs	r4, #119	; 0x77
  gpiop->PUPDR   = config->pupdr;
  20166c:	f8cc 840c 	str.w	r8, [ip, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
  201670:	f8cc 0414 	str.w	r0, [ip, #1044]	; 0x414
  gpiop->OSPEEDR = config->ospeedr;
  201674:	f8df 8304 	ldr.w	r8, [pc, #772]	; 20197c <main+0x66c>
  gpiop->AFRL    = config->afrl;
  201678:	f8cc 3420 	str.w	r3, [ip, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
  20167c:	f8cc 4424 	str.w	r4, [ip, #1060]	; 0x424
  gpiop->MODER   = config->moder;
  201680:	f44f 2420 	mov.w	r4, #655360	; 0xa0000
  201684:	f8cc 4400 	str.w	r4, [ip, #1024]	; 0x400
  201688:	f04f 6408 	mov.w	r4, #142606336	; 0x8800000
  gpiop->OTYPER  = config->otyper;
  20168c:	f8cc 3804 	str.w	r3, [ip, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
  201690:	f8cc 8808 	str.w	r8, [ip, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
  201694:	f8cc a80c 	str.w	sl, [ip, #2060]	; 0x80c
  gpiop->OTYPER  = config->otyper;
  201698:	f8df 82e4 	ldr.w	r8, [pc, #740]	; 201980 <main+0x670>
  gpiop->ODR     = config->odr;
  20169c:	f8cc 0814 	str.w	r0, [ip, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
  2016a0:	f8cc 3820 	str.w	r3, [ip, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
  2016a4:	f8cc 3824 	str.w	r3, [ip, #2084]	; 0x824
  gpiop->MODER   = config->moder;
  2016a8:	f8cc 3800 	str.w	r3, [ip, #2048]	; 0x800
  gpiop->OSPEEDR = config->ospeedr;
  2016ac:	f8df c2d4 	ldr.w	ip, [pc, #724]	; 201984 <main+0x674>
  gpiop->OTYPER  = config->otyper;
  2016b0:	f8c8 3004 	str.w	r3, [r8, #4]
  gpiop->OSPEEDR = config->ospeedr;
  2016b4:	f8c8 c008 	str.w	ip, [r8, #8]
  gpiop->OTYPER  = config->otyper;
  2016b8:	f8df c2cc 	ldr.w	ip, [pc, #716]	; 201988 <main+0x678>
  gpiop->PUPDR   = config->pupdr;
  2016bc:	f8c8 a00c 	str.w	sl, [r8, #12]
  gpiop->ODR     = config->odr;
  2016c0:	f8c8 0014 	str.w	r0, [r8, #20]
  gpiop->AFRL    = config->afrl;
  2016c4:	f8c8 3020 	str.w	r3, [r8, #32]
  gpiop->AFRH    = config->afrh;
  2016c8:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
  gpiop->MODER   = config->moder;
  2016cc:	f8c8 3000 	str.w	r3, [r8]
  gpiop->OSPEEDR = config->ospeedr;
  2016d0:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 20198c <main+0x67c>
  gpiop->OTYPER  = config->otyper;
  2016d4:	f8cc 3004 	str.w	r3, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
  2016d8:	f8cc 8008 	str.w	r8, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
  2016dc:	f8df 82b0 	ldr.w	r8, [pc, #688]	; 201990 <main+0x680>
  2016e0:	f8cc 800c 	str.w	r8, [ip, #12]
  gpiop->AFRH    = config->afrh;
  2016e4:	f8df 82ac 	ldr.w	r8, [pc, #684]	; 201994 <main+0x684>
  gpiop->ODR     = config->odr;
  2016e8:	f8cc 0014 	str.w	r0, [ip, #20]
  gpiop->AFRL    = config->afrl;
  2016ec:	f8cc 3020 	str.w	r3, [ip, #32]
  gpiop->AFRH    = config->afrh;
  2016f0:	f8cc 8024 	str.w	r8, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
  2016f4:	f8cc 4000 	str.w	r4, [ip]
  gpiop->OSPEEDR = config->ospeedr;
  2016f8:	240f      	movs	r4, #15
  gpiop->PUPDR   = config->pupdr;
  2016fa:	f8df 829c 	ldr.w	r8, [pc, #668]	; 201998 <main+0x688>
  gpiop->OTYPER  = config->otyper;
  2016fe:	f8cc 3404 	str.w	r3, [ip, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
  201702:	f8cc 4408 	str.w	r4, [ip, #1032]	; 0x408
  tqp->next = (thread_t *)tqp;
  201706:	f101 0418 	add.w	r4, r1, #24
  gpiop->PUPDR   = config->pupdr;
  20170a:	f8cc 840c 	str.w	r8, [ip, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
  20170e:	f8cc 0414 	str.w	r0, [ip, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
  201712:	f8cc 3420 	str.w	r3, [ip, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
  201716:	f8cc 3424 	str.w	r3, [ip, #1060]	; 0x424
  gpiop->MODER   = config->moder;
  20171a:	f8cc 3400 	str.w	r3, [ip, #1024]	; 0x400
  gpiop->OTYPER  = config->otyper;
  20171e:	f50c 6c00 	add.w	ip, ip, #2048	; 0x800
  201722:	f8cc 3004 	str.w	r3, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
  201726:	f8cc 3008 	str.w	r3, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
  20172a:	f8cc a00c 	str.w	sl, [ip, #12]
  adcp->config   = NULL;
  20172e:	604b      	str	r3, [r1, #4]
  gpiop->ODR     = config->odr;
  201730:	f8cc 0014 	str.w	r0, [ip, #20]
  adcp->samples  = NULL;
  201734:	608b      	str	r3, [r1, #8]
  gpiop->AFRL    = config->afrl;
  201736:	f8cc 3020 	str.w	r3, [ip, #32]
  adcp->depth    = 0;
  20173a:	60cb      	str	r3, [r1, #12]
  gpiop->AFRH    = config->afrh;
  20173c:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
  adcp->grpp     = NULL;
  201740:	610b      	str	r3, [r1, #16]
  gpiop->MODER   = config->moder;
  201742:	f8cc 3000 	str.w	r3, [ip]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
  201746:	614b      	str	r3, [r1, #20]
  gpiop->OTYPER  = config->otyper;
  201748:	f8cc 3404 	str.w	r3, [ip, #1028]	; 0x404
  20174c:	620b      	str	r3, [r1, #32]
  gpiop->OSPEEDR = config->ospeedr;
  20174e:	f8cc 3408 	str.w	r3, [ip, #1032]	; 0x408
  201752:	618c      	str	r4, [r1, #24]
  gpiop->PUPDR   = config->pupdr;
  201754:	f8cc a40c 	str.w	sl, [ip, #1036]	; 0x40c
  tqp->prev = (thread_t *)tqp;
  201758:	61cc      	str	r4, [r1, #28]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20175a:	f44f 2480 	mov.w	r4, #262144	; 0x40000
  gpiop->ODR     = config->odr;
  20175e:	f8cc 0414 	str.w	r0, [ip, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
  201762:	f8cc 3420 	str.w	r3, [ip, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
  201766:	f8cc 3424 	str.w	r3, [ip, #1060]	; 0x424
  gpiop->MODER   = config->moder;
  20176a:	f8cc 3400 	str.w	r3, [ip, #1024]	; 0x400
  gpiop->OTYPER  = config->otyper;
  20176e:	f8cc 3804 	str.w	r3, [ip, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
  201772:	f8cc 3808 	str.w	r3, [ip, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
  201776:	f8cc a80c 	str.w	sl, [ip, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
  20177a:	f8cc 0814 	str.w	r0, [ip, #2068]	; 0x814
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
  20177e:	4863      	ldr	r0, [pc, #396]	; (20190c <main+0x5fc>)
  gpiop->AFRL    = config->afrl;
  201780:	f8cc 3820 	str.w	r3, [ip, #2080]	; 0x820
  201784:	6288      	str	r0, [r1, #40]	; 0x28
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
  201786:	4862      	ldr	r0, [pc, #392]	; (201910 <main+0x600>)
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  201788:	f8df 8210 	ldr.w	r8, [pc, #528]	; 20199c <main+0x68c>
  gpiop->AFRH    = config->afrh;
  20178c:	f8cc 3824 	str.w	r3, [ip, #2084]	; 0x824
  201790:	62c8      	str	r0, [r1, #44]	; 0x2c
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
  201792:	4860      	ldr	r0, [pc, #384]	; (201914 <main+0x604>)
  gpiop->MODER   = config->moder;
  201794:	f8cc 3800 	str.w	r3, [ip, #2048]	; 0x800
  201798:	6308      	str	r0, [r1, #48]	; 0x30
  20179a:	4658      	mov	r0, fp
  20179c:	f8df c200 	ldr.w	ip, [pc, #512]	; 2019a0 <main+0x690>
  adcp->state    = ADC_STOP;
  2017a0:	700a      	strb	r2, [r1, #0]
 */
void dac_lld_init(void) {

#if STM32_DAC_USE_DAC1_CH1
  dacObjectInit(&DACD1);
  DACD1.params  = &dma1_ch1_params;
  2017a2:	495d      	ldr	r1, [pc, #372]	; (201918 <main+0x608>)
  2017a4:	f888 9312 	strb.w	r9, [r8, #786]	; 0x312
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2017a8:	f8c8 4180 	str.w	r4, [r8, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  2017ac:	f8c8 4000 	str.w	r4, [r8]
 *
 * @init
 */
void dacObjectInit(DACDriver *dacp) {

  dacp->state = DAC_STOP;
  2017b0:	4c5a      	ldr	r4, [pc, #360]	; (20191c <main+0x60c>)
  2017b2:	f840 cb04 	str.w	ip, [r0], #4
  2017b6:	7022      	strb	r2, [r4, #0]
  dacp->config = NULL;
  2017b8:	6123      	str	r3, [r4, #16]
#if DAC_USE_WAIT
  dacp->thread = NULL;
  2017ba:	6163      	str	r3, [r4, #20]
  2017bc:	6223      	str	r3, [r4, #32]
  2017be:	62a1      	str	r1, [r4, #40]	; 0x28
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
  2017c0:	f8cb 0004 	str.w	r0, [fp, #4]
  dacp->config = NULL;
  2017c4:	4620      	mov	r0, r4
  tqp->next = (thread_t *)tqp;
  2017c6:	3418      	adds	r4, #24
  gptObjectInit(&GPTD5);
#endif

#if STM32_GPT_USE_TIM6
  /* Driver initialization.*/
  GPTD6.tim = STM32_TIM6;
  2017c8:	4955      	ldr	r1, [pc, #340]	; (201920 <main+0x610>)
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
  2017ca:	f8df a1d8 	ldr.w	sl, [pc, #472]	; 2019a4 <main+0x694>
  2017ce:	6184      	str	r4, [r0, #24]
  tqp->prev = (thread_t *)tqp;
  2017d0:	61c4      	str	r4, [r0, #28]
  2017d2:	4854      	ldr	r0, [pc, #336]	; (201924 <main+0x614>)
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
  2017d4:	700a      	strb	r2, [r1, #0]
  gptp->config = NULL;
  2017d6:	604b      	str	r3, [r1, #4]
  2017d8:	60c8      	str	r0, [r1, #12]
  gptp->state  = GPT_STOP;
  2017da:	4853      	ldr	r0, [pc, #332]	; (201928 <main+0x618>)
  gptObjectInit(&GPTD8);
#endif

#if STM32_GPT_USE_TIM9
  /* Driver initialization.*/
  GPTD9.tim = STM32_TIM9;
  2017dc:	4953      	ldr	r1, [pc, #332]	; (20192c <main+0x61c>)
 *
 * @init
 */
void extObjectInit(EXTDriver *extp) {

  extp->state  = EXT_STOP;
  2017de:	4c54      	ldr	r4, [pc, #336]	; (201930 <main+0x620>)
  2017e0:	60c1      	str	r1, [r0, #12]
  tqp->next = (thread_t *)tqp;
  2017e2:	f10b 010c 	add.w	r1, fp, #12
  2017e6:	7022      	strb	r2, [r4, #0]
  2017e8:	f8cb 100c 	str.w	r1, [fp, #12]
void pwm_lld_init(void) {

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
  2017ec:	f04f 0106 	mov.w	r1, #6
  extp->config = NULL;
  2017f0:	6063      	str	r3, [r4, #4]
#endif

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
  PWMD2.channels = STM32_TIM2_CHANNELS;
  2017f2:	f04f 0404 	mov.w	r4, #4
  PWMD1.channels = STM32_TIM1_CHANNELS;
  2017f6:	f88a 1010 	strb.w	r1, [sl, #16]
  PWMD1.tim = STM32_TIM1;
  2017fa:	494e      	ldr	r1, [pc, #312]	; (201934 <main+0x624>)
  2017fc:	7002      	strb	r2, [r0, #0]
  gptp->config = NULL;
  2017fe:	6043      	str	r3, [r0, #4]
  tqp->prev = (thread_t *)tqp;
  201800:	f10b 000c 	add.w	r0, fp, #12
  201804:	f8ca 1018 	str.w	r1, [sl, #24]
  201808:	494b      	ldr	r1, [pc, #300]	; (201938 <main+0x628>)
  20180a:	f8cb 0010 	str.w	r0, [fp, #16]
  PWMD2.channels = STM32_TIM2_CHANNELS;
  20180e:	740c      	strb	r4, [r1, #16]
  PWMD2.tim = STM32_TIM2;
  201810:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  201814:	4849      	ldr	r0, [pc, #292]	; (20193c <main+0x62c>)
  201816:	700a      	strb	r2, [r1, #0]
  pwmp->config   = NULL;
  201818:	604b      	str	r3, [r1, #4]
  pwmp->enabled  = 0;
  20181a:	60cb      	str	r3, [r1, #12]
  20181c:	618c      	str	r4, [r1, #24]
  iqp->q_buffer  = bp;
  20181e:	4601      	mov	r1, r0
  iqp->q_top     = bp + size;
  201820:	3010      	adds	r0, #16
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
  201822:	f88b 2008 	strb.w	r2, [fp, #8]
  iqp->q_counter = 0;
  201826:	f8cb 3014 	str.w	r3, [fp, #20]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20182a:	f06f 043f 	mvn.w	r4, #63	; 0x3f
  pwmp->state    = PWM_STOP;
  20182e:	f88a 2000 	strb.w	r2, [sl]
  pwmp->config   = NULL;
  201832:	f8ca 3004 	str.w	r3, [sl, #4]
  pwmp->enabled  = 0;
  201836:	f8ca 300c 	str.w	r3, [sl, #12]
  iqp->q_buffer  = bp;
  20183a:	f8cb 1018 	str.w	r1, [fp, #24]
  iqp->q_top     = bp + size;
  20183e:	f8cb 001c 	str.w	r0, [fp, #28]
  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  201842:	483f      	ldr	r0, [pc, #252]	; (201940 <main+0x630>)
  iqp->q_rdptr   = bp;
  201844:	f8cb 1024 	str.w	r1, [fp, #36]	; 0x24
  iqp->q_wrptr   = bp;
  201848:	f8cb 1020 	str.w	r1, [fp, #32]
  oqp->q_top     = bp + size;
  20184c:	f8cb 0040 	str.w	r0, [fp, #64]	; 0x40
  oqp->q_buffer  = bp;
  201850:	493c      	ldr	r1, [pc, #240]	; (201944 <main+0x634>)
  oqp->q_notify  = onfy;
  201852:	483d      	ldr	r0, [pc, #244]	; (201948 <main+0x638>)
  oqp->q_counter = size;
  201854:	f8cb e038 	str.w	lr, [fp, #56]	; 0x38
  iqp->q_notify  = infy;
  201858:	f8cb 3028 	str.w	r3, [fp, #40]	; 0x28
  oqp->q_buffer  = bp;
  20185c:	f8cb 103c 	str.w	r1, [fp, #60]	; 0x3c
  oqp->q_rdptr   = bp;
  201860:	f8cb 1048 	str.w	r1, [fp, #72]	; 0x48
  oqp->q_wrptr   = bp;
  201864:	f8cb 1044 	str.w	r1, [fp, #68]	; 0x44
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  201868:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  iqp->q_link    = link;
  20186c:	f8cb b02c 	str.w	fp, [fp, #44]	; 0x2c
  oqp->q_link    = link;
  201870:	f8cb b050 	str.w	fp, [fp, #80]	; 0x50
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  201874:	f888 4335 	strb.w	r4, [r8, #821]	; 0x335
  tqp->next = (thread_t *)tqp;
  201878:	f105 0430 	add.w	r4, r5, #48	; 0x30
  oqp->q_notify  = onfy;
  20187c:	f8cb 004c 	str.w	r0, [fp, #76]	; 0x4c

#if STM32_SERIAL_USE_UART5
  sdObjectInit(&SD5);
  iqObjectInit(&SD5.iqueue, sd_in_buf5, sizeof sd_in_buf5, NULL, &SD5);
  oqObjectInit(&SD5.oqueue, sd_out_buf5, sizeof sd_out_buf5, notify5, &SD5);
  SD5.usart = UART5;
  201880:	4832      	ldr	r0, [pc, #200]	; (20194c <main+0x63c>)
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  201882:	f8c8 1184 	str.w	r1, [r8, #388]	; 0x184
  201886:	f8cb 0054 	str.w	r0, [fp, #84]	; 0x54
  iqp->q_top     = bp + size;
  20188a:	4831      	ldr	r0, [pc, #196]	; (201950 <main+0x640>)
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20188c:	f8c8 1004 	str.w	r1, [r8, #4]
  iqp->q_buffer  = bp;
  201890:	4601      	mov	r1, r0
  iqp->q_top     = bp + size;
  201892:	3010      	adds	r0, #16
  201894:	722a      	strb	r2, [r5, #8]
  iqp->q_buffer  = bp;
  201896:	61a9      	str	r1, [r5, #24]
  iqp->q_rdptr   = bp;
  201898:	6269      	str	r1, [r5, #36]	; 0x24
  iqp->q_wrptr   = bp;
  20189a:	6229      	str	r1, [r5, #32]
  sdp->vmt = &vmt;
  20189c:	4629      	mov	r1, r5
  iqp->q_top     = bp + size;
  20189e:	61e8      	str	r0, [r5, #28]
  2018a0:	f10b 0030 	add.w	r0, fp, #48	; 0x30
  2018a4:	f841 cb04 	str.w	ip, [r1], #4
  2018a8:	f8cb 0030 	str.w	r0, [fp, #48]	; 0x30
  2018ac:	6069      	str	r1, [r5, #4]
  2018ae:	f105 010c 	add.w	r1, r5, #12
  tqp->prev = (thread_t *)tqp;
  2018b2:	f8cb 0034 	str.w	r0, [fp, #52]	; 0x34
  SD5.clock = STM32_UART5CLK;
  2018b6:	4827      	ldr	r0, [pc, #156]	; (201954 <main+0x644>)
  tqp->next = (thread_t *)tqp;
  2018b8:	60e9      	str	r1, [r5, #12]
  2018ba:	f8cb 0058 	str.w	r0, [fp, #88]	; 0x58
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2018be:	f06f 003f 	mvn.w	r0, #63	; 0x3f
  tqp->prev = (thread_t *)tqp;
  2018c2:	6129      	str	r1, [r5, #16]
  oqp->q_top     = bp + size;
  2018c4:	4924      	ldr	r1, [pc, #144]	; (201958 <main+0x648>)
  iqp->q_counter = 0;
  2018c6:	616b      	str	r3, [r5, #20]
  iqp->q_notify  = infy;
  2018c8:	62ab      	str	r3, [r5, #40]	; 0x28
  tqp->next = (thread_t *)tqp;
  2018ca:	632c      	str	r4, [r5, #48]	; 0x30
  iqp->q_link    = link;
  2018cc:	62ed      	str	r5, [r5, #44]	; 0x2c
  tqp->prev = (thread_t *)tqp;
  2018ce:	636c      	str	r4, [r5, #52]	; 0x34
  2018d0:	f06f 043f 	mvn.w	r4, #63	; 0x3f
  oqp->q_counter = size;
  2018d4:	f8c5 e038 	str.w	lr, [r5, #56]	; 0x38
  oqp->q_link    = link;
  2018d8:	652d      	str	r5, [r5, #80]	; 0x50
  2018da:	f888 0347 	strb.w	r0, [r8, #839]	; 0x347
  oqp->q_buffer  = bp;
  2018de:	4608      	mov	r0, r1
  oqp->q_top     = bp + size;
  2018e0:	3110      	adds	r1, #16
  oqp->q_buffer  = bp;
  2018e2:	63e8      	str	r0, [r5, #60]	; 0x3c
  oqp->q_rdptr   = bp;
  2018e4:	64a8      	str	r0, [r5, #72]	; 0x48
  oqp->q_wrptr   = bp;
  2018e6:	6468      	str	r0, [r5, #68]	; 0x44
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2018e8:	2080      	movs	r0, #128	; 0x80
  2018ea:	e05d      	b.n	2019a8 <main+0x698>
  2018ec:	40023800 	.word	0x40023800
  2018f0:	40026000 	.word	0x40026000
  2018f4:	40026400 	.word	0x40026400
  2018f8:	20000c28 	.word	0x20000c28
  2018fc:	20000880 	.word	0x20000880
  201900:	40020000 	.word	0x40020000
  201904:	b0000bb0 	.word	0xb0000bb0
  201908:	20000cf0 	.word	0x20000cf0
  20190c:	40012000 	.word	0x40012000
  201910:	08005030 	.word	0x08005030
  201914:	00022c16 	.word	0x00022c16
  201918:	08005078 	.word	0x08005078
  20191c:	20000c64 	.word	0x20000c64
  201920:	20000c90 	.word	0x20000c90
  201924:	40001000 	.word	0x40001000
  201928:	2000080c 	.word	0x2000080c
  20192c:	40014000 	.word	0x40014000
  201930:	20000800 	.word	0x20000800
  201934:	40010000 	.word	0x40010000
  201938:	20000cd0 	.word	0x20000cd0
  20193c:	20000a00 	.word	0x20000a00
  201940:	20000a40 	.word	0x20000a40
  201944:	20000a30 	.word	0x20000a30
  201948:	00203151 	.word	0x00203151
  20194c:	40005000 	.word	0x40005000
  201950:	20000a10 	.word	0x20000a10
  201954:	0337f980 	.word	0x0337f980
  201958:	20000a40 	.word	0x20000a40
  20195c:	000aaa0a 	.word	0x000aaa0a
  201960:	20000820 	.word	0x20000820
  201964:	2aae8028 	.word	0x2aae8028
  201968:	01555051 	.word	0x01555051
  20196c:	18004001 	.word	0x18004001
  201970:	40020800 	.word	0x40020800
  201974:	00bb00b0 	.word	0x00bb00b0
  201978:	55505555 	.word	0x55505555
  20197c:	cffffff3 	.word	0xcffffff3
  201980:	40021400 	.word	0x40021400
  201984:	003fcfff 	.word	0x003fcfff
  201988:	40021800 	.word	0x40021800
  20198c:	3cccf000 	.word	0x3cccf000
  201990:	51155555 	.word	0x51155555
  201994:	00b0b000 	.word	0x00b0b000
  201998:	55555550 	.word	0x55555550
  20199c:	e000e100 	.word	0xe000e100
  2019a0:	080050b4 	.word	0x080050b4
  2019a4:	20000cb4 	.word	0x20000cb4
  oqp->q_top     = bp + size;
  2019a8:	6429      	str	r1, [r5, #64]	; 0x40
  2019aa:	4631      	mov	r1, r6
  2019ac:	f8c8 0188 	str.w	r0, [r8, #392]	; 0x188
  sdp->state = SD_STOP;
  2019b0:	7232      	strb	r2, [r6, #8]
  oqp->q_notify  = onfy;
  2019b2:	4a93      	ldr	r2, [pc, #588]	; (201c00 <main+0x8f0>)
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  2019b4:	f8c8 0008 	str.w	r0, [r8, #8]
  tqp->next = (thread_t *)tqp;
  2019b8:	f106 000c 	add.w	r0, r6, #12
  2019bc:	64ea      	str	r2, [r5, #76]	; 0x4c

#if STM32_SERIAL_USE_USART6
  sdObjectInit(&SD6);
  iqObjectInit(&SD6.iqueue, sd_in_buf6, sizeof sd_in_buf6, NULL, &SD6);
  oqObjectInit(&SD6.oqueue, sd_out_buf6, sizeof sd_out_buf6, notify6, &SD6);
  SD6.usart = USART6;
  2019be:	4a91      	ldr	r2, [pc, #580]	; (201c04 <main+0x8f4>)
  sdp->vmt = &vmt;
  2019c0:	f841 cb04 	str.w	ip, [r1], #4
#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
  SysTick->VAL = 0;
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
  2019c4:	f04f 0c07 	mov.w	ip, #7
  2019c8:	6071      	str	r1, [r6, #4]
  2019ca:	656a      	str	r2, [r5, #84]	; 0x54
  iqp->q_buffer  = bp;
  2019cc:	498e      	ldr	r1, [pc, #568]	; (201c08 <main+0x8f8>)
  SD6.clock = STM32_USART6CLK;
  2019ce:	4a8f      	ldr	r2, [pc, #572]	; (201c0c <main+0x8fc>)
  iqp->q_counter = 0;
  2019d0:	6173      	str	r3, [r6, #20]
  2019d2:	65aa      	str	r2, [r5, #88]	; 0x58
  iqp->q_top     = bp + size;
  2019d4:	f101 0210 	add.w	r2, r1, #16
  oqp->q_counter = size;
  2019d8:	f8c6 e038 	str.w	lr, [r6, #56]	; 0x38
  2019dc:	f106 0e30 	add.w	lr, r6, #48	; 0x30
  iqp->q_top     = bp + size;
  2019e0:	61f2      	str	r2, [r6, #28]
  oqp->q_buffer  = bp;
  2019e2:	4a8b      	ldr	r2, [pc, #556]	; (201c10 <main+0x900>)
  iqp->q_buffer  = bp;
  2019e4:	61b1      	str	r1, [r6, #24]
  iqp->q_rdptr   = bp;
  2019e6:	6271      	str	r1, [r6, #36]	; 0x24
  iqp->q_wrptr   = bp;
  2019e8:	6231      	str	r1, [r6, #32]
  oqp->q_buffer  = bp;
  2019ea:	63f2      	str	r2, [r6, #60]	; 0x3c
  oqp->q_rdptr   = bp;
  2019ec:	64b2      	str	r2, [r6, #72]	; 0x48
  oqp->q_wrptr   = bp;
  2019ee:	6472      	str	r2, [r6, #68]	; 0x44
  oqp->q_top     = bp + size;
  2019f0:	3210      	adds	r2, #16
  oqp->q_notify  = onfy;
  2019f2:	4988      	ldr	r1, [pc, #544]	; (201c14 <main+0x904>)
  iqp->q_notify  = infy;
  2019f4:	62b3      	str	r3, [r6, #40]	; 0x28
  oqp->q_top     = bp + size;
  2019f6:	6432      	str	r2, [r6, #64]	; 0x40
  oqp->q_notify  = onfy;
  2019f8:	64f1      	str	r1, [r6, #76]	; 0x4c
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
  2019fa:	4a87      	ldr	r2, [pc, #540]	; (201c18 <main+0x908>)
  2019fc:	4987      	ldr	r1, [pc, #540]	; (201c1c <main+0x90c>)
  2019fe:	60f0      	str	r0, [r6, #12]
  tqp->prev = (thread_t *)tqp;
  201a00:	6130      	str	r0, [r6, #16]
  iqp->q_link    = link;
  201a02:	62f6      	str	r6, [r6, #44]	; 0x2c
  tqp->next = (thread_t *)tqp;
  201a04:	f8c6 e030 	str.w	lr, [r6, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
  201a08:	f8c6 e034 	str.w	lr, [r6, #52]	; 0x34
  oqp->q_link    = link;
  201a0c:	6536      	str	r6, [r6, #80]	; 0x50
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  201a0e:	f888 4352 	strb.w	r4, [r8, #850]	; 0x352
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  201a12:	f44f 2480 	mov.w	r4, #262144	; 0x40000

#if defined(__CORE_CM0_H_GENERIC)
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
  201a16:	4882      	ldr	r0, [pc, #520]	; (201c20 <main+0x910>)
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  201a18:	f8c8 4188 	str.w	r4, [r8, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  201a1c:	f8c8 4008 	str.w	r4, [r8, #8]
  201a20:	6051      	str	r1, [r2, #4]
  SysTick->VAL = 0;
  201a22:	6093      	str	r3, [r2, #8]
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
  201a24:	f06f 037f 	mvn.w	r3, #127	; 0x7f
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
  201a28:	f8c2 c000 	str.w	ip, [r2]
  201a2c:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
/*
 * @brief       Odometry initialization and start
 */
void lld_Odometry_Init (void)
{
    if( Odometry_is_Initialized ) return;
  201a30:	4b7c      	ldr	r3, [pc, #496]	; (201c24 <main+0x914>)

#if STM32_SERIAL_USE_UART7
  sdObjectInit(&SD7);
  iqObjectInit(&SD7.iqueue, sd_in_buf7, sizeof sd_in_buf7, NULL, &SD7);
  oqObjectInit(&SD7.oqueue, sd_out_buf7, sizeof sd_out_buf7, notify7, &SD7);
  SD7.usart = UART7;
  201a32:	497d      	ldr	r1, [pc, #500]	; (201c28 <main+0x918>)
  SD7.clock = STM32_UART7CLK;
  201a34:	4a7d      	ldr	r2, [pc, #500]	; (201c2c <main+0x91c>)
  201a36:	781b      	ldrb	r3, [r3, #0]
  201a38:	65b2      	str	r2, [r6, #88]	; 0x58
  SD7.usart = UART7;
  201a3a:	6571      	str	r1, [r6, #84]	; 0x54
  201a3c:	2b00      	cmp	r3, #0
  201a3e:	f000 83fb 	beq.w	202238 <main+0xf28>
/*
 * @brief   Initialization of drive
 */
void drive_Speed_Init(void)
{
    if ( isInitialized ) return;
  201a42:	f8df 8234 	ldr.w	r8, [pc, #564]	; 201c78 <main+0x968>
  201a46:	f898 9000 	ldrb.w	r9, [r8]
  201a4a:	f1b9 0f00 	cmp.w	r9, #0
  201a4e:	f000 83b6 	beq.w	2021be <main+0xeae>
};


void lldMotorInit(void)
{
    palSetLineMode( PWM1_P9,  PWM1_MODE_P9  );
  201a52:	2282      	movs	r2, #130	; 0x82
  201a54:	f44f 7100 	mov.w	r1, #512	; 0x200
  201a58:	4875      	ldr	r0, [pc, #468]	; (201c30 <main+0x920>)
  201a5a:	f04f 0920 	mov.w	r9, #32
  201a5e:	f002 f8df 	bl	203c20 <_pal_lld_setgroupmode>
    palSetLineMode( PWM1_P11,  PWM1_MODE_P11 );
  201a62:	2282      	movs	r2, #130	; 0x82
  201a64:	f44f 6100 	mov.w	r1, #2048	; 0x800
  201a68:	4871      	ldr	r0, [pc, #452]	; (201c30 <main+0x920>)
  201a6a:	f002 f8d9 	bl	203c20 <_pal_lld_setgroupmode>
  201a6e:	f389 8811 	msr	BASEPRI, r9
  osalDbgCheck((pwmp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
  201a72:	4b70      	ldr	r3, [pc, #448]	; (201c34 <main+0x924>)
  pwmp->period = config->period;
  pwm_lld_start(pwmp);
  pwmp->enabled = 0;
  pwmp->state = PWM_READY;
  201a74:	f04f 0802 	mov.w	r8, #2
  pwm_lld_start(pwmp);
  201a78:	486f      	ldr	r0, [pc, #444]	; (201c38 <main+0x928>)
  pwmp->period = config->period;
  201a7a:	685a      	ldr	r2, [r3, #4]
  pwmp->config = config;
  201a7c:	f8ca 3004 	str.w	r3, [sl, #4]
  pwmp->period = config->period;
  201a80:	f8ca 2008 	str.w	r2, [sl, #8]
  pwm_lld_start(pwmp);
  201a84:	f001 ffa4 	bl	2039d0 <pwm_lld_start>
  pwmp->enabled = 0;
  201a88:	2300      	movs	r3, #0
  pwmp->state = PWM_READY;
  201a8a:	f88a 8000 	strb.w	r8, [sl]
  pwmp->enabled = 0;
  201a8e:	f8ca 300c 	str.w	r3, [sl, #12]
  201a92:	f383 8811 	msr	BASEPRI, r3
    pwmStart( PWMDriver1, &pwm1conf );
    pwmEnableChannel( PWMDriver1, PWM1_CHANNEL_P9, 5840 );
  201a96:	f241 62d0 	movw	r2, #5840	; 0x16d0
  201a9a:	4619      	mov	r1, r3
  201a9c:	4866      	ldr	r0, [pc, #408]	; (201c38 <main+0x928>)
  201a9e:	f000 fdbf 	bl	202620 <pwmEnableChannel>
    chThdSleepMilliseconds(5000);
  201aa2:	f241 3088 	movw	r0, #5000	; 0x1388
  201aa6:	f001 f9a3 	bl	202df0 <chThdSleep>
  201aaa:	f389 8811 	msr	BASEPRI, r9
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
  201aae:	4b63      	ldr	r3, [pc, #396]	; (201c3c <main+0x92c>)
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  201ab0:	2400      	movs	r4, #0
  201ab2:	4a63      	ldr	r2, [pc, #396]	; (201c40 <main+0x930>)
  tp->prio      = prio;
  201ab4:	f04f 0e80 	mov.w	lr, #128	; 0x80
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  201ab8:	f8c3 4160 	str.w	r4, [r3, #352]	; 0x160
  201abc:	f503 71ae 	add.w	r1, r3, #348	; 0x15c
  tp->flags     = CH_FLAG_MODE_STATIC;
  201ac0:	f883 41a1 	strb.w	r4, [r3, #417]	; 0x1a1
  tp->mtxlist   = NULL;
  201ac4:	2400      	movs	r4, #0
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  201ac6:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
  tlp->next = (thread_t *)tlp;
  201aca:	f503 7cd4 	add.w	ip, r3, #424	; 0x1a8
  tp->mtxlist   = NULL;
  201ace:	f8c3 41b8 	str.w	r4, [r3, #440]	; 0x1b8
  REG_INSERT(tp);
  201ad2:	f503 72c0 	add.w	r2, r3, #384	; 0x180
  tp->epending  = (eventmask_t)0;
  201ad6:	f8c3 41b4 	str.w	r4, [r3, #436]	; 0x1b4
  tp->refs      = (trefs_t)1;
  201ada:	2001      	movs	r0, #1
  REG_INSERT(tp);
  201adc:	4c59      	ldr	r4, [pc, #356]	; (201c44 <main+0x934>)
  tp->state     = CH_STATE_WTSTART;
  201ade:	f883 81a0 	strb.w	r8, [r3, #416]	; 0x1a0
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  201ae2:	f8c3 118c 	str.w	r1, [r3, #396]	; 0x18c
  tqp->next = (thread_t *)tqp;
  201ae6:	f503 71d6 	add.w	r1, r3, #428	; 0x1ac
  REG_INSERT(tp);
  201aea:	f8d4 8014 	ldr.w	r8, [r4, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  201aee:	f8df a18c 	ldr.w	sl, [pc, #396]	; 201c7c <main+0x96c>
  tp->name      = name;
  201af2:	f8df 918c 	ldr.w	r9, [pc, #396]	; 201c80 <main+0x970>
  REG_INSERT(tp);
  201af6:	f8c3 4190 	str.w	r4, [r3, #400]	; 0x190
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  201afa:	f8c3 a15c 	str.w	sl, [r3, #348]	; 0x15c
  tp->refs      = (trefs_t)1;
  201afe:	f883 01a2 	strb.w	r0, [r3, #418]	; 0x1a2

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
  201b02:	4610      	mov	r0, r2
  tp->name      = name;
  201b04:	f8c3 9198 	str.w	r9, [r3, #408]	; 0x198
  tp->prio      = prio;
  201b08:	f8c3 e188 	str.w	lr, [r3, #392]	; 0x188
  REG_INSERT(tp);
  201b0c:	f8c3 8194 	str.w	r8, [r3, #404]	; 0x194
  tp->realprio  = prio;
  201b10:	f8c3 e1bc 	str.w	lr, [r3, #444]	; 0x1bc
  tp->wabase = (stkalign_t *)wsp;
  201b14:	f8c3 319c 	str.w	r3, [r3, #412]	; 0x19c
  REG_INSERT(tp);
  201b18:	f8c8 2010 	str.w	r2, [r8, #16]
  tlp->next = (thread_t *)tlp;
  201b1c:	f8c3 c1a8 	str.w	ip, [r3, #424]	; 0x1a8
  tqp->next = (thread_t *)tqp;
  201b20:	f8c3 11ac 	str.w	r1, [r3, #428]	; 0x1ac
  tqp->prev = (thread_t *)tqp;
  201b24:	f8c3 11b0 	str.w	r1, [r3, #432]	; 0x1b0
  201b28:	6162      	str	r2, [r4, #20]
  chSchWakeupS(tp, MSG_OK);
  201b2a:	f002 fba1 	bl	204270 <chSchWakeupS.constprop.34>
  201b2e:	2300      	movs	r3, #0
  201b30:	f383 8811 	msr	BASEPRI, r3

void commonADC1UnitInit ( void )

{

    if ( adcInitialized )
  201b34:	4b44      	ldr	r3, [pc, #272]	; (201c48 <main+0x938>)
  201b36:	781b      	ldrb	r3, [r3, #0]
  201b38:	b90b      	cbnz	r3, 201b3e <main+0x82e>
  201b3a:	f002 fec9 	bl	2048d0 <commonADC1UnitInit.part.2>
{
    if ( ch >= COMMON_ADC_CHANNELS_NUMBER )
    {
        return 0;
    }
    return filtered_buffer[ch];
  201b3e:	f8df 8144 	ldr.w	r8, [pc, #324]	; 201c84 <main+0x974>
/*
 * Serials UART Initialization for sonar sensors.
 */
void serial_Init(void)
{
    if(isInitialized) return;
  201b42:	4c42      	ldr	r4, [pc, #264]	; (201c4c <main+0x93c>)
    commonADC1UnitInit ();
//    palSetLineMode(LINE_ADC123_IN13,PAL_MODE_INPUT_ANALOG);
//    palSetLineMode(LINE_ADC12_IN9, PAL_MODE_INPUT_ANALOG);
//    adcStartConversion(&ADCD1, &adcgrpcfg1, samples1, ADC1_BUF_DEPTH);
//    gptStartContinuous(&GPTD6,gpt4cfg1.frequency/1000);
    DinADC[0] = (commonADC1UnitGetValue(1)-2000)/5.4;
  201b44:	f8b8 0004 	ldrh.w	r0, [r8, #4]
  201b48:	f5a0 60fa 	sub.w	r0, r0, #2000	; 0x7d0
  201b4c:	f7fe fd28 	bl	2005a0 <__aeabi_i2d>
  201b50:	a329      	add	r3, pc, #164	; (adr r3, 201bf8 <main+0x8e8>)
  201b52:	e9d3 2300 	ldrd	r2, r3, [r3]
  201b56:	f7fe feb3 	bl	2008c0 <__aeabi_ddiv>
  201b5a:	f7ff f821 	bl	200ba0 <__aeabi_d2iz>
    DinCur[0] = (commonADC1UnitGetValue(2) - 1800)/70;
  201b5e:	f8b8 2008 	ldrh.w	r2, [r8, #8]
    DinADC[0] = (commonADC1UnitGetValue(1)-2000)/5.4;
  201b62:	493b      	ldr	r1, [pc, #236]	; (201c50 <main+0x940>)
    DinCur[0] = (commonADC1UnitGetValue(2) - 1800)/70;
  201b64:	f5a2 62e1 	sub.w	r2, r2, #1800	; 0x708
  201b68:	4b3a      	ldr	r3, [pc, #232]	; (201c54 <main+0x944>)
    DinADC[0] = (commonADC1UnitGetValue(1)-2000)/5.4;
  201b6a:	8008      	strh	r0, [r1, #0]
    DinCur[0] = (commonADC1UnitGetValue(2) - 1800)/70;
  201b6c:	fb83 1302 	smull	r1, r3, r3, r2
  201b70:	17d1      	asrs	r1, r2, #31
  201b72:	7820      	ldrb	r0, [r4, #0]
  201b74:	4413      	add	r3, r2
  201b76:	4a38      	ldr	r2, [pc, #224]	; (201c58 <main+0x948>)
  201b78:	ebc1 13a3 	rsb	r3, r1, r3, asr #6
  201b7c:	8013      	strh	r3, [r2, #0]
  201b7e:	2800      	cmp	r0, #0
  201b80:	f000 82ae 	beq.w	2020e0 <main+0xdd0>
};


void initialization(void)
{
      palSetPadMode(GPIOE, 15,PAL_MODE_OUTPUT_PUSHPULL);
  201b84:	2201      	movs	r2, #1
  201b86:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  201b8a:	4829      	ldr	r0, [pc, #164]	; (201c30 <main+0x920>)
  201b8c:	f002 f848 	bl	203c20 <_pal_lld_setgroupmode>
      palSetPadMode(GPIOG, 1,PAL_MODE_OUTPUT_PUSHPULL);
  201b90:	2201      	movs	r2, #1
  201b92:	2102      	movs	r1, #2
  201b94:	4831      	ldr	r0, [pc, #196]	; (201c5c <main+0x94c>)
  201b96:	f002 f843 	bl	203c20 <_pal_lld_setgroupmode>

      palSetLineMode( PAL_LINE( GPIOB, 10 ),  PAL_MODE_ALTERNATE(1) );
  201b9a:	2282      	movs	r2, #130	; 0x82
  201b9c:	f44f 6180 	mov.w	r1, #1024	; 0x400
  201ba0:	482f      	ldr	r0, [pc, #188]	; (201c60 <main+0x950>)
  201ba2:	f002 f83d 	bl	203c20 <_pal_lld_setgroupmode>
  201ba6:	2320      	movs	r3, #32
  201ba8:	f383 8811 	msr	BASEPRI, r3
  pwmp->config = config;
  201bac:	4b2d      	ldr	r3, [pc, #180]	; (201c64 <main+0x954>)
  pwmp->enabled = 0;
  201bae:	2400      	movs	r4, #0
  pwm_lld_start(pwmp);
  201bb0:	482d      	ldr	r0, [pc, #180]	; (201c68 <main+0x958>)
  pwmp->period = config->period;
  201bb2:	685a      	ldr	r2, [r3, #4]
  pwmp->config = config;
  201bb4:	6043      	str	r3, [r0, #4]
  pwmp->period = config->period;
  201bb6:	6082      	str	r2, [r0, #8]
  pwm_lld_start(pwmp);
  201bb8:	f001 ff0a 	bl	2039d0 <pwm_lld_start>
  pwmp->enabled = 0;
  201bbc:	4a2a      	ldr	r2, [pc, #168]	; (201c68 <main+0x958>)
  pwmp->state = PWM_READY;
  201bbe:	2302      	movs	r3, #2
  pwmp->enabled = 0;
  201bc0:	60d4      	str	r4, [r2, #12]
  pwmp->state = PWM_READY;
  201bc2:	7013      	strb	r3, [r2, #0]
  201bc4:	f384 8811 	msr	BASEPRI, r4
  201bc8:	4b28      	ldr	r3, [pc, #160]	; (201c6c <main+0x95c>)
    float robotSpeed = 0;
    bool searchingPlace = true, parking1 = false, parking2 = false;
    int gov = 0;
    int t =0;
    uint16_t firstDistanceLeftSonar = 40;
    int graf = 0;
  201bca:	613c      	str	r4, [r7, #16]
  201bcc:	607b      	str	r3, [r7, #4]
    brakeSensorInit();
  201bce:	f003 f80f 	bl	204bf0 <brakeSensorInit>
    bool searchingPlace = true, parking1 = false, parking2 = false;
  201bd2:	2301      	movs	r3, #1
//    chprintf(((BaseSequentialStream *)&SD7), "%d    ",turn_enable);
//    chprintf(((BaseSequentialStream *)&SD7), "%d    ",drive_enable);
//    chprintf(((BaseSequentialStream *)&SD7), "%d    \r\n",parking_enable);
//

    steerUnitCSSetPosition(0);
  201bd4:	4620      	mov	r0, r4
    int gov = 0;
  201bd6:	60fc      	str	r4, [r7, #12]
    bool searchingPlace = true, parking1 = false, parking2 = false;
  201bd8:	617b      	str	r3, [r7, #20]
  201bda:	623c      	str	r4, [r7, #32]
  201bdc:	61bc      	str	r4, [r7, #24]
    steerUnitCSSetPosition(0);
  201bde:	f002 fd7f 	bl	2046e0 <steerUnitCSSetPosition>
    chThdSleepSeconds(2);
  201be2:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
  201be6:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 201c88 <main+0x978>
  201bea:	f8df b0a0 	ldr.w	fp, [pc, #160]	; 201c8c <main+0x97c>
  201bee:	f001 f8ff 	bl	202df0 <chThdSleep>
//        chprintf(((BaseSequentialStream *)&SD7), "%d    ",turn_enable);
//        chprintf(((BaseSequentialStream *)&SD7), "%d    ",gov);
//        distanceLeftSonar = get_sonar_dist(leftSonar, 4);
        nowDist = get_distance();
        robotSpeed = get_speed();
        nowDist *= 100;
  201bf2:	4d1f      	ldr	r5, [pc, #124]	; (201c70 <main+0x960>)
        robotSpeed *= 100;
//       chprintf(((BaseSequentialStream *)&SD7), "%d  ",distanceLeftSonar);
        chprintf(((BaseSequentialStream *)&SD7), "%d  ",(int)nowDist);
  201bf4:	4e1f      	ldr	r6, [pc, #124]	; (201c74 <main+0x964>)
  201bf6:	e07b      	b.n	201cf0 <main+0x9e0>
  201bf8:	9999999a 	.word	0x9999999a
  201bfc:	40159999 	.word	0x40159999
  201c00:	00203141 	.word	0x00203141
  201c04:	40011400 	.word	0x40011400
  201c08:	20000a20 	.word	0x20000a20
  201c0c:	066ff300 	.word	0x066ff300
  201c10:	20000a50 	.word	0x20000a50
  201c14:	00203131 	.word	0x00203131
  201c18:	e000e010 	.word	0xe000e010
  201c1c:	00034bbf 	.word	0x00034bbf
  201c20:	e000ed00 	.word	0xe000ed00
  201c24:	2000081c 	.word	0x2000081c
  201c28:	40007800 	.word	0x40007800
  201c2c:	0337f980 	.word	0x0337f980
  201c30:	40021000 	.word	0x40021000
  201c34:	20020000 	.word	0x20020000
  201c38:	20000cb4 	.word	0x20000cb4
  201c3c:	20000a60 	.word	0x20000a60
  201c40:	002002e5 	.word	0x002002e5
  201c44:	20000d78 	.word	0x20000d78
  201c48:	20000d52 	.word	0x20000d52
  201c4c:	200009f4 	.word	0x200009f4
  201c50:	20000eb4 	.word	0x20000eb4
  201c54:	ea0ea0eb 	.word	0xea0ea0eb
  201c58:	20000eb8 	.word	0x20000eb8
  201c5c:	40021800 	.word	0x40021800
  201c60:	40020400 	.word	0x40020400
  201c64:	20020044 	.word	0x20020044
  201c68:	20000cd0 	.word	0x20000cd0
  201c6c:	200009dc 	.word	0x200009dc
  201c70:	42c80000 	.word	0x42c80000
  201c74:	20000cf0 	.word	0x20000cf0
  201c78:	200009f5 	.word	0x200009f5
  201c7c:	00204761 	.word	0x00204761
  201c80:	0800509c 	.word	0x0800509c
  201c84:	20000e84 	.word	0x20000e84
  201c88:	20000ebd 	.word	0x20000ebd
  201c8c:	200009f8 	.word	0x200009f8

                            }
                        }
                    }

                    if(parking1)
  201c90:	69bb      	ldr	r3, [r7, #24]
  201c92:	2b00      	cmp	r3, #0
  201c94:	f040 809d 	bne.w	201dd2 <main+0xac2>
                            parking2 = true;
                        }

                    }

                    if(parking2)
  201c98:	6a3b      	ldr	r3, [r7, #32]
  201c9a:	b333      	cbz	r3, 201cea <main+0x9da>
                    {
                        if(graf == 0)
  201c9c:	693b      	ldr	r3, [r7, #16]
  201c9e:	b933      	cbnz	r3, 201cae <main+0x99e>
                        {
                            encoderTicks = 0;
  201ca0:	4ab1      	ldr	r2, [pc, #708]	; (201f68 <main+0xc58>)
  201ca2:	6013      	str	r3, [r2, #0]
                                                        currentDistance = 0;
  201ca4:	2200      	movs	r2, #0
  201ca6:	4bb1      	ldr	r3, [pc, #708]	; (201f6c <main+0xc5c>)
  201ca8:	601a      	str	r2, [r3, #0]
                                                        prevDistance = 0;
  201caa:	4bb1      	ldr	r3, [pc, #708]	; (201f70 <main+0xc60>)
  201cac:	601a      	str	r2, [r3, #0]
                                                        graf = 1;
                        }
                        steerUnitCSSetPosition(100);
  201cae:	2064      	movs	r0, #100	; 0x64
  201cb0:	f002 fd16 	bl	2046e0 <steerUnitCSSetPosition>
                        nowDist = get_distance();
  201cb4:	f002 fdc4 	bl	204840 <get_distance>
void drive_Direction_Control ( bool driveDirection )
{
    if( driveDirection )
        palSetLine( driveDirectionLine );
    else
        palClearLine( driveDirectionLine );
  201cb8:	4bae      	ldr	r3, [pc, #696]	; (201f74 <main+0xc64>)
  201cba:	2208      	movs	r2, #8
  201cbc:	4604      	mov	r4, r0

                        drive_Direction_Control(false);
                        chThdSleepMilliseconds(41);
  201cbe:	2029      	movs	r0, #41	; 0x29
  201cc0:	835a      	strh	r2, [r3, #26]
  201cc2:	f001 f895 	bl	202df0 <chThdSleep>

                        if(nowDist > -ARC_LENGTH)
  201cc6:	4620      	mov	r0, r4
  201cc8:	f7fe fc7c 	bl	2005c4 <__aeabi_f2d>
  201ccc:	a39e      	add	r3, pc, #632	; (adr r3, 201f48 <main+0xc38>)
  201cce:	e9d3 2300 	ldrd	r2, r3, [r3]
  201cd2:	f7fe ff5b 	bl	200b8c <__aeabi_dcmpgt>
  201cd6:	2800      	cmp	r0, #0
  201cd8:	f000 8097 	beq.w	201e0a <main+0xafa>
                        {
                            drive_Speed_Control(1.35);
  201cdc:	48a6      	ldr	r0, [pc, #664]	; (201f78 <main+0xc68>)
  201cde:	f8c7 9020 	str.w	r9, [r7, #32]
  201ce2:	f002 fdcd 	bl	204880 <drive_Speed_Control>
  201ce6:	2301      	movs	r3, #1
  201ce8:	613b      	str	r3, [r7, #16]
                            parking2 = false;

                        }
                    }
        }
        chThdSleepMilliseconds(100);
  201cea:	2064      	movs	r0, #100	; 0x64
  201cec:	f001 f880 	bl	202df0 <chThdSleep>
        nowDist = get_distance();
  201cf0:	f002 fda6 	bl	204840 <get_distance>
  201cf4:	4680      	mov	r8, r0
        robotSpeed = get_speed();
  201cf6:	f002 fd13 	bl	204720 <get_speed>
        nowDist *= 100;
  201cfa:	4629      	mov	r1, r5
        robotSpeed = get_speed();
  201cfc:	4604      	mov	r4, r0
        nowDist *= 100;
  201cfe:	4640      	mov	r0, r8
  201d00:	f7ff f8f4 	bl	200eec <__aeabi_fmul>
        chprintf(((BaseSequentialStream *)&SD7), "%d  ",(int)nowDist);
  201d04:	f7ff fab8 	bl	201278 <__aeabi_f2iz>
  201d08:	499c      	ldr	r1, [pc, #624]	; (201f7c <main+0xc6c>)
  201d0a:	4602      	mov	r2, r0
  201d0c:	4630      	mov	r0, r6
  201d0e:	f002 fb07 	bl	204320 <chprintf.constprop.3>
        robotSpeed *= 100;
  201d12:	4629      	mov	r1, r5
  201d14:	4620      	mov	r0, r4
  201d16:	f7ff f8e9 	bl	200eec <__aeabi_fmul>
        chprintf(((BaseSequentialStream *)&SD7), "%d  \n\r",(int)robotSpeed);
  201d1a:	f7ff faad 	bl	201278 <__aeabi_f2iz>
  201d1e:	4998      	ldr	r1, [pc, #608]	; (201f80 <main+0xc70>)
  201d20:	4602      	mov	r2, r0
  201d22:	4630      	mov	r0, r6
  201d24:	f002 fafc 	bl	204320 <chprintf.constprop.3>
        if(parking_enable)
  201d28:	f89a 9000 	ldrb.w	r9, [sl]
  201d2c:	f1b9 0f00 	cmp.w	r9, #0
  201d30:	d0db      	beq.n	201cea <main+0x9da>
                    if(searchingPlace)
  201d32:	697b      	ldr	r3, [r7, #20]
  201d34:	2b00      	cmp	r3, #0
  201d36:	d0ab      	beq.n	201c90 <main+0x980>
        palSetLine( driveDirectionLine );
  201d38:	4b8e      	ldr	r3, [pc, #568]	; (201f74 <main+0xc64>)
  201d3a:	2208      	movs	r2, #8
                        chThdSleepMilliseconds(41);
  201d3c:	2029      	movs	r0, #41	; 0x29
  201d3e:	831a      	strh	r2, [r3, #24]
  201d40:	f001 f856 	bl	202df0 <chThdSleep>
                        drive_Speed_Control(1.35);
  201d44:	488c      	ldr	r0, [pc, #560]	; (201f78 <main+0xc68>)
  201d46:	f002 fd9b 	bl	204880 <drive_Speed_Control>
 */
uint16_t get_sonar_dist(SerialDriver *type_sonar, uint16_t digits_num )
{


    if(firstValues == false)
  201d4a:	4b8e      	ldr	r3, [pc, #568]	; (201f84 <main+0xc74>)
  201d4c:	781c      	ldrb	r4, [r3, #0]
  201d4e:	bb2c      	cbnz	r4, 201d9c <main+0xa8c>
    {
        for (int i=0; i<WINDOW; i++)
        {
            maxSonarSensorValue = sdGet(type_sonar);
  201d50:	f8df 8238 	ldr.w	r8, [pc, #568]	; 201f8c <main+0xc7c>
  201d54:	e003      	b.n	201d5e <main+0xa4e>
                filterWindow[i] = atoi(&maxSonarSensorValue);
                chThdSleepMilliseconds(30);
            }
            else
            {
                i--;
  201d56:	3c01      	subs	r4, #1
        for (int i=0; i<WINDOW; i++)
  201d58:	3401      	adds	r4, #1
  201d5a:	2c09      	cmp	r4, #9
  201d5c:	dc1b      	bgt.n	201d96 <main+0xa86>
            maxSonarSensorValue = sdGet(type_sonar);
  201d5e:	f64f 71ff 	movw	r1, #65535	; 0xffff
  201d62:	4640      	mov	r0, r8
  201d64:	f001 f80c 	bl	202d80 <iqGetTimeout>
            if (maxSonarSensorValue == 'R')
  201d68:	2852      	cmp	r0, #82	; 0x52
            maxSonarSensorValue = sdGet(type_sonar);
  201d6a:	f8cb 0000 	str.w	r0, [fp]
            if (maxSonarSensorValue == 'R')
  201d6e:	d1f2      	bne.n	201d56 <main+0xa46>
                sdRead(type_sonar, (uint8_t *)&maxSonarSensorValue , digits_num);
  201d70:	f64f 73ff 	movw	r3, #65535	; 0xffff
  201d74:	2204      	movs	r2, #4
  201d76:	4984      	ldr	r1, [pc, #528]	; (201f88 <main+0xc78>)
  201d78:	4640      	mov	r0, r8
  201d7a:	f000 ff91 	bl	202ca0 <iqReadTimeout>
                filterWindow[i] = atoi(&maxSonarSensorValue);
  201d7e:	4882      	ldr	r0, [pc, #520]	; (201f88 <main+0xc78>)
  201d80:	f002 ffbc 	bl	204cfc <atoi>
  201d84:	687b      	ldr	r3, [r7, #4]
  201d86:	f823 0014 	strh.w	r0, [r3, r4, lsl #1]
        for (int i=0; i<WINDOW; i++)
  201d8a:	3401      	adds	r4, #1
                chThdSleepMilliseconds(30);
  201d8c:	201e      	movs	r0, #30
  201d8e:	f001 f82f 	bl	202df0 <chThdSleep>
        for (int i=0; i<WINDOW; i++)
  201d92:	2c09      	cmp	r4, #9
  201d94:	dde3      	ble.n	201d5e <main+0xa4e>
            }
        }
        firstValues = true;
  201d96:	2301      	movs	r3, #1
  201d98:	4a7a      	ldr	r2, [pc, #488]	; (201f84 <main+0xc74>)
  201d9a:	7013      	strb	r3, [r2, #0]
    }

    maxSonarSensorValue = sdGet(type_sonar);
  201d9c:	f64f 71ff 	movw	r1, #65535	; 0xffff
  201da0:	487a      	ldr	r0, [pc, #488]	; (201f8c <main+0xc7c>)
  201da2:	f000 ffed 	bl	202d80 <iqGetTimeout>
        if (maxSonarSensorValue == 'R')
  201da6:	2852      	cmp	r0, #82	; 0x52
    maxSonarSensorValue = sdGet(type_sonar);
  201da8:	f8cb 0000 	str.w	r0, [fp]
        if (maxSonarSensorValue == 'R')
  201dac:	f000 80f8 	beq.w	201fa0 <main+0xc90>
                        placeWidth = distanceLeftSonar - firstDistanceLeftSonar;
  201db0:	68bb      	ldr	r3, [r7, #8]
  201db2:	3b28      	subs	r3, #40	; 0x28
                        if(placeWidth < 150)
  201db4:	b29b      	uxth	r3, r3
  201db6:	2b95      	cmp	r3, #149	; 0x95
  201db8:	d86d      	bhi.n	201e96 <main+0xb86>
                            currentDistance = 0;
  201dba:	4a6c      	ldr	r2, [pc, #432]	; (201f6c <main+0xc5c>)
  201dbc:	2100      	movs	r1, #0
                            encoderTicks = 0;
  201dbe:	2300      	movs	r3, #0
                            currentDistance = 0;
  201dc0:	6011      	str	r1, [r2, #0]
                            prevDistance = 0;
  201dc2:	4a6b      	ldr	r2, [pc, #428]	; (201f70 <main+0xc60>)
  201dc4:	6011      	str	r1, [r2, #0]
                            encoderTicks = 0;
  201dc6:	4a68      	ldr	r2, [pc, #416]	; (201f68 <main+0xc58>)
  201dc8:	6013      	str	r3, [r2, #0]
                    if(parking1)
  201dca:	69bb      	ldr	r3, [r7, #24]
  201dcc:	2b00      	cmp	r3, #0
  201dce:	f43f af63 	beq.w	201c98 <main+0x988>
                        steerUnitCSSetPosition(-100);
  201dd2:	f06f 0063 	mvn.w	r0, #99	; 0x63
  201dd6:	f002 fc83 	bl	2046e0 <steerUnitCSSetPosition>
                        nowDist = get_distance();
  201dda:	f002 fd31 	bl	204840 <get_distance>
        palClearLine( driveDirectionLine );
  201dde:	4b65      	ldr	r3, [pc, #404]	; (201f74 <main+0xc64>)
  201de0:	2208      	movs	r2, #8
  201de2:	4604      	mov	r4, r0
                        chThdSleepMilliseconds(41);
  201de4:	2029      	movs	r0, #41	; 0x29
  201de6:	835a      	strh	r2, [r3, #26]
  201de8:	f001 f802 	bl	202df0 <chThdSleep>
                        if(nowDist > -ARC_LENGTH)
  201dec:	4620      	mov	r0, r4
  201dee:	f7fe fbe9 	bl	2005c4 <__aeabi_f2d>
  201df2:	a355      	add	r3, pc, #340	; (adr r3, 201f48 <main+0xc38>)
  201df4:	e9d3 2300 	ldrd	r2, r3, [r3]
  201df8:	f7fe fec8 	bl	200b8c <__aeabi_dcmpgt>
  201dfc:	b340      	cbz	r0, 201e50 <main+0xb40>
                            drive_Speed_Control(1.35);
  201dfe:	485e      	ldr	r0, [pc, #376]	; (201f78 <main+0xc68>)
  201e00:	f8c7 9018 	str.w	r9, [r7, #24]
  201e04:	f002 fd3c 	bl	204880 <drive_Speed_Control>
  201e08:	e746      	b.n	201c98 <main+0x988>
                            drive_Speed_Control(0);
  201e0a:	2000      	movs	r0, #0
  201e0c:	f002 fd38 	bl	204880 <drive_Speed_Control>
                            if(((get_speed() > 0.3)||(get_speed() < -0.3)) && gov == 0)
  201e10:	f002 fc86 	bl	204720 <get_speed>
  201e14:	f7fe fbd6 	bl	2005c4 <__aeabi_f2d>
  201e18:	4680      	mov	r8, r0
  201e1a:	4689      	mov	r9, r1
  201e1c:	a34c      	add	r3, pc, #304	; (adr r3, 201f50 <main+0xc40>)
  201e1e:	e9d3 2300 	ldrd	r2, r3, [r3]
  201e22:	f7fe feb3 	bl	200b8c <__aeabi_dcmpgt>
  201e26:	2800      	cmp	r0, #0
  201e28:	d064      	beq.n	201ef4 <main+0xbe4>
  201e2a:	68fb      	ldr	r3, [r7, #12]
  201e2c:	2b00      	cmp	r3, #0
  201e2e:	d06d      	beq.n	201f0c <main+0xbfc>
                            chThdSleepSeconds(3);
  201e30:	2201      	movs	r2, #1
                            currentDistance = 0;
  201e32:	2100      	movs	r1, #0
                            encoderTicks = 0;
  201e34:	2300      	movs	r3, #0
                            chThdSleepSeconds(3);
  201e36:	f640 30b8 	movw	r0, #3000	; 0xbb8
  201e3a:	613a      	str	r2, [r7, #16]
                            currentDistance = 0;
  201e3c:	4a4b      	ldr	r2, [pc, #300]	; (201f6c <main+0xc5c>)
                            parking2 = false;
  201e3e:	623b      	str	r3, [r7, #32]
                            currentDistance = 0;
  201e40:	6011      	str	r1, [r2, #0]
                            prevDistance = 0;
  201e42:	4a4b      	ldr	r2, [pc, #300]	; (201f70 <main+0xc60>)
  201e44:	6011      	str	r1, [r2, #0]
                            encoderTicks = 0;
  201e46:	4a48      	ldr	r2, [pc, #288]	; (201f68 <main+0xc58>)
  201e48:	6013      	str	r3, [r2, #0]
                            chThdSleepSeconds(3);
  201e4a:	f000 ffd1 	bl	202df0 <chThdSleep>
  201e4e:	e74c      	b.n	201cea <main+0x9da>
                            drive_Speed_Control(0);
  201e50:	2000      	movs	r0, #0
  201e52:	f002 fd15 	bl	204880 <drive_Speed_Control>
                            if(((get_speed() > 0.3)||(get_speed() < -0.3)) && gov == 0)
  201e56:	f002 fc63 	bl	204720 <get_speed>
  201e5a:	f7fe fbb3 	bl	2005c4 <__aeabi_f2d>
  201e5e:	a33c      	add	r3, pc, #240	; (adr r3, 201f50 <main+0xc40>)
  201e60:	e9d3 2300 	ldrd	r2, r3, [r3]
  201e64:	e9c7 0108 	strd	r0, r1, [r7, #32]
  201e68:	f7fe fe90 	bl	200b8c <__aeabi_dcmpgt>
  201e6c:	2800      	cmp	r0, #0
  201e6e:	f000 80e3 	beq.w	202038 <main+0xd28>
  201e72:	68fb      	ldr	r3, [r7, #12]
  201e74:	2b00      	cmp	r3, #0
  201e76:	f000 80ed 	beq.w	202054 <main+0xd44>
                            currentDistance = 0;
  201e7a:	2100      	movs	r1, #0
  201e7c:	4a3b      	ldr	r2, [pc, #236]	; (201f6c <main+0xc5c>)
                            encoderTicks = 0;
  201e7e:	2300      	movs	r3, #0
                            chThdSleepSeconds(3);
  201e80:	f640 30b8 	movw	r0, #3000	; 0xbb8
                            currentDistance = 0;
  201e84:	6011      	str	r1, [r2, #0]
                            prevDistance = 0;
  201e86:	4a3a      	ldr	r2, [pc, #232]	; (201f70 <main+0xc60>)
                            parking1 = false;
  201e88:	61bb      	str	r3, [r7, #24]
                            prevDistance = 0;
  201e8a:	6011      	str	r1, [r2, #0]
                            encoderTicks = 0;
  201e8c:	4a36      	ldr	r2, [pc, #216]	; (201f68 <main+0xc58>)
  201e8e:	6013      	str	r3, [r2, #0]
                            chThdSleepSeconds(3);
  201e90:	f000 ffae 	bl	202df0 <chThdSleep>
  201e94:	e702      	b.n	201c9c <main+0x98c>
                            placeLength = get_distance();
  201e96:	f002 fcd3 	bl	204840 <get_distance>
                            if(placeLength > MIN_DIST)
  201e9a:	f7fe fb93 	bl	2005c4 <__aeabi_f2d>
  201e9e:	a32e      	add	r3, pc, #184	; (adr r3, 201f58 <main+0xc48>)
  201ea0:	e9d3 2300 	ldrd	r2, r3, [r3]
  201ea4:	f7fe fe72 	bl	200b8c <__aeabi_dcmpgt>
  201ea8:	2800      	cmp	r0, #0
  201eaa:	f43f aef1 	beq.w	201c90 <main+0x980>
                                drive_Speed_Control(0);
  201eae:	2000      	movs	r0, #0
  201eb0:	f002 fce6 	bl	204880 <drive_Speed_Control>
                                if(((get_speed() > 0.3)||(get_speed() < -0.3)) && gov == 0)
  201eb4:	f002 fc34 	bl	204720 <get_speed>
  201eb8:	f7fe fb84 	bl	2005c4 <__aeabi_f2d>
  201ebc:	a324      	add	r3, pc, #144	; (adr r3, 201f50 <main+0xc40>)
  201ebe:	e9d3 2300 	ldrd	r2, r3, [r3]
  201ec2:	e9c7 0106 	strd	r0, r1, [r7, #24]
  201ec6:	f7fe fe61 	bl	200b8c <__aeabi_dcmpgt>
  201eca:	2800      	cmp	r0, #0
  201ecc:	f000 80de 	beq.w	20208c <main+0xd7c>
  201ed0:	68fb      	ldr	r3, [r7, #12]
  201ed2:	2b00      	cmp	r3, #0
  201ed4:	f000 80e8 	beq.w	2020a8 <main+0xd98>
                                currentDistance = 0;
  201ed8:	2100      	movs	r1, #0
  201eda:	4a24      	ldr	r2, [pc, #144]	; (201f6c <main+0xc5c>)
                                encoderTicks = 0;
  201edc:	2300      	movs	r3, #0
                                chThdSleepSeconds(3);
  201ede:	f640 30b8 	movw	r0, #3000	; 0xbb8
                                currentDistance = 0;
  201ee2:	6011      	str	r1, [r2, #0]
                                prevDistance = 0;
  201ee4:	4a22      	ldr	r2, [pc, #136]	; (201f70 <main+0xc60>)
                                searchingPlace = false;
  201ee6:	617b      	str	r3, [r7, #20]
                                prevDistance = 0;
  201ee8:	6011      	str	r1, [r2, #0]
                                encoderTicks = 0;
  201eea:	4a1f      	ldr	r2, [pc, #124]	; (201f68 <main+0xc58>)
  201eec:	6013      	str	r3, [r2, #0]
                                chThdSleepSeconds(3);
  201eee:	f000 ff7f 	bl	202df0 <chThdSleep>
  201ef2:	e76e      	b.n	201dd2 <main+0xac2>
                            if(((get_speed() > 0.3)||(get_speed() < -0.3)) && gov == 0)
  201ef4:	4640      	mov	r0, r8
  201ef6:	4649      	mov	r1, r9
  201ef8:	a319      	add	r3, pc, #100	; (adr r3, 201f60 <main+0xc50>)
  201efa:	e9d3 2300 	ldrd	r2, r3, [r3]
  201efe:	f7fe fe27 	bl	200b50 <__aeabi_dcmplt>
  201f02:	2800      	cmp	r0, #0
  201f04:	d094      	beq.n	201e30 <main+0xb20>
  201f06:	68fb      	ldr	r3, [r7, #12]
  201f08:	2b00      	cmp	r3, #0
  201f0a:	d191      	bne.n	201e30 <main+0xb20>
                                gov = 1;
  201f0c:	2201      	movs	r2, #1
        palSetLine( lineBrakeDirIN1 );
        palClearLine( lineBrakeDirIN2 );
    }
    else
    {
        palClearLine( lineBrakeDirIN1 );
  201f0e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  201f12:	f8df 9088 	ldr.w	r9, [pc, #136]	; 201f9c <main+0xc8c>
        palSetLine( lineBrakeDirIN2 );
  201f16:	f04f 0802 	mov.w	r8, #2
  201f1a:	60fa      	str	r2, [r7, #12]
                                chThdSleepMilliseconds(1000);
  201f1c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    }
}

void brakeUnitCSSetPower( int16_t pressPower )
{
    tfconf.k = pressPower;
  201f20:	4a1b      	ldr	r2, [pc, #108]	; (201f90 <main+0xc80>)
        palSetLine( lineBrakeDirIN2 );
  201f22:	4c1c      	ldr	r4, [pc, #112]	; (201f94 <main+0xc84>)
    tfconf.k = pressPower;
  201f24:	6015      	str	r5, [r2, #0]
        palClearLine( lineBrakeDirIN1 );
  201f26:	f8a9 301a 	strh.w	r3, [r9, #26]
  201f2a:	623b      	str	r3, [r7, #32]
        palSetLine( lineBrakeDirIN2 );
  201f2c:	f8a4 8018 	strh.w	r8, [r4, #24]
  201f30:	f000 ff5e 	bl	202df0 <chThdSleep>
    tfconf.k = pressPower;
  201f34:	4b16      	ldr	r3, [pc, #88]	; (201f90 <main+0xc80>)
  201f36:	4a18      	ldr	r2, [pc, #96]	; (201f98 <main+0xc88>)
  201f38:	601a      	str	r2, [r3, #0]
        palSetLine( lineBrakeDirIN1 );
  201f3a:	6a3b      	ldr	r3, [r7, #32]
  201f3c:	f8a9 3018 	strh.w	r3, [r9, #24]
        palClearLine( lineBrakeDirIN2 );
  201f40:	f8a4 801a 	strh.w	r8, [r4, #26]
  201f44:	e774      	b.n	201e30 <main+0xb20>
  201f46:	bf00      	nop
  201f48:	0a3d70a4 	.word	0x0a3d70a4
  201f4c:	c000a3d7 	.word	0xc000a3d7
  201f50:	33333333 	.word	0x33333333
  201f54:	3fd33333 	.word	0x3fd33333
  201f58:	66666666 	.word	0x66666666
  201f5c:	400e6666 	.word	0x400e6666
  201f60:	33333333 	.word	0x33333333
  201f64:	bfd33333 	.word	0xbfd33333
  201f68:	20000e80 	.word	0x20000e80
  201f6c:	20000dec 	.word	0x20000dec
  201f70:	20000ea4 	.word	0x20000ea4
  201f74:	40020c00 	.word	0x40020c00
  201f78:	3faccccd 	.word	0x3faccccd
  201f7c:	080050a4 	.word	0x080050a4
  201f80:	080050ac 	.word	0x080050ac
  201f84:	200009f0 	.word	0x200009f0
  201f88:	200009f8 	.word	0x200009f8
  201f8c:	2000088c 	.word	0x2000088c
  201f90:	200200bc 	.word	0x200200bc
  201f94:	40021800 	.word	0x40021800
  201f98:	c2480000 	.word	0xc2480000
  201f9c:	40021000 	.word	0x40021000
  201fa0:	f8df c36c 	ldr.w	ip, [pc, #876]	; 202310 <main+0x1000>
{
  201fa4:	46e8      	mov	r8, sp
  201fa6:	f107 0228 	add.w	r2, r7, #40	; 0x28
  201faa:	4663      	mov	r3, ip
  201fac:	f8c7 c004 	str.w	ip, [r7, #4]
        z[k]=x[k];
  201fb0:	f833 1b02 	ldrh.w	r1, [r3], #2
  201fb4:	f822 1b02 	strh.w	r1, [r2], #2
    for (unsigned int k=0; k<w; k++)
  201fb8:	49bb      	ldr	r1, [pc, #748]	; (2022a8 <main+0xf98>)
  201fba:	4299      	cmp	r1, r3
  201fbc:	d1f8      	bne.n	201fb0 <main+0xca0>
  201fbe:	f04f 0e09 	mov.w	lr, #9
        for (uint16_t j=0; j<(w-i-1); j++)
  201fc2:	2200      	movs	r2, #0
  201fc4:	f8c7 c000 	str.w	ip, [r7]
            if (x[j]<x[j+1])
  201fc8:	0053      	lsls	r3, r2, #1
  201fca:	f107 0128 	add.w	r1, r7, #40	; 0x28
  201fce:	f107 0428 	add.w	r4, r7, #40	; 0x28
        for (uint16_t j=0; j<(w-i-1); j++)
  201fd2:	1c50      	adds	r0, r2, #1
            if (x[j]<x[j+1])
  201fd4:	3302      	adds	r3, #2
  201fd6:	f831 1012 	ldrh.w	r1, [r1, r2, lsl #1]
  201fda:	5ae4      	ldrh	r4, [r4, r3]
  201fdc:	42a1      	cmp	r1, r4
  201fde:	d205      	bcs.n	201fec <main+0xcdc>
                x[j] = x[j + 1];
  201fe0:	f107 0c28 	add.w	ip, r7, #40	; 0x28
  201fe4:	f82c 4012 	strh.w	r4, [ip, r2, lsl #1]
                x[j + 1] = buff;
  201fe8:	f82c 1003 	strh.w	r1, [ip, r3]
        for (uint16_t j=0; j<(w-i-1); j++)
  201fec:	b282      	uxth	r2, r0
  201fee:	4596      	cmp	lr, r2
  201ff0:	dcea      	bgt.n	201fc8 <main+0xcb8>
    for (uint16_t i=0; i<(w-1); i++ )
  201ff2:	f1be 0e01 	subs.w	lr, lr, #1
  201ff6:	f8d7 c000 	ldr.w	ip, [r7]
  201ffa:	d1e2      	bne.n	201fc2 <main+0xcb2>
    y = z[w/2];
  201ffc:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
  201ffe:	46c5      	mov	sp, r8
        {
            flt_num = Filter_Mediana(filterWindow, WINDOW);
  202000:	4aaa      	ldr	r2, [pc, #680]	; (2022ac <main+0xf9c>)
  202002:	8013      	strh	r3, [r2, #0]
            for (int i=0; i<WINDOW-1; i++)
            {
                filterWindow[i] = filterWindow[i+1];
  202004:	f8bc 3002 	ldrh.w	r3, [ip, #2]
  202008:	f82c 3b02 	strh.w	r3, [ip], #2
            for (int i=0; i<WINDOW-1; i++)
  20200c:	4ba8      	ldr	r3, [pc, #672]	; (2022b0 <main+0xfa0>)
  20200e:	4563      	cmp	r3, ip
  202010:	d1f8      	bne.n	202004 <main+0xcf4>
            }
            sdRead(type_sonar, (uint8_t *)&maxSonarSensorValue , digits_num);
  202012:	f64f 73ff 	movw	r3, #65535	; 0xffff
  202016:	2204      	movs	r2, #4
  202018:	49a6      	ldr	r1, [pc, #664]	; (2022b4 <main+0xfa4>)
  20201a:	48a7      	ldr	r0, [pc, #668]	; (2022b8 <main+0xfa8>)
  20201c:	f000 fe40 	bl	202ca0 <iqReadTimeout>
            filterWindow[WINDOW-1] = atoi(&maxSonarSensorValue);
  202020:	48a4      	ldr	r0, [pc, #656]	; (2022b4 <main+0xfa4>)
  202022:	f002 fe6b 	bl	204cfc <atoi>
  202026:	687b      	ldr	r3, [r7, #4]
  202028:	8258      	strh	r0, [r3, #18]
            chThdSleepMilliseconds(30);
  20202a:	201e      	movs	r0, #30
  20202c:	f000 fee0 	bl	202df0 <chThdSleep>

            return(flt_num);
  202030:	4b9e      	ldr	r3, [pc, #632]	; (2022ac <main+0xf9c>)
  202032:	881b      	ldrh	r3, [r3, #0]
  202034:	60bb      	str	r3, [r7, #8]
  202036:	e6bb      	b.n	201db0 <main+0xaa0>
                            if(((get_speed() > 0.3)||(get_speed() < -0.3)) && gov == 0)
  202038:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
  20203c:	a398      	add	r3, pc, #608	; (adr r3, 2022a0 <main+0xf90>)
  20203e:	e9d3 2300 	ldrd	r2, r3, [r3]
  202042:	f7fe fd85 	bl	200b50 <__aeabi_dcmplt>
  202046:	2800      	cmp	r0, #0
  202048:	f43f af17 	beq.w	201e7a <main+0xb6a>
  20204c:	68fb      	ldr	r3, [r7, #12]
  20204e:	2b00      	cmp	r3, #0
  202050:	f47f af13 	bne.w	201e7a <main+0xb6a>
                                gov = 1;
  202054:	2101      	movs	r1, #1
        palClearLine( lineBrakeDirIN1 );
  202056:	4a99      	ldr	r2, [pc, #612]	; (2022bc <main+0xfac>)
  202058:	f44f 4300 	mov.w	r3, #32768	; 0x8000
        palSetLine( lineBrakeDirIN2 );
  20205c:	4c98      	ldr	r4, [pc, #608]	; (2022c0 <main+0xfb0>)
  20205e:	60f9      	str	r1, [r7, #12]
  202060:	f04f 0802 	mov.w	r8, #2
    tfconf.k = pressPower;
  202064:	4997      	ldr	r1, [pc, #604]	; (2022c4 <main+0xfb4>)
                                chThdSleepMilliseconds(1000);
  202066:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  20206a:	600d      	str	r5, [r1, #0]
        palClearLine( lineBrakeDirIN1 );
  20206c:	8353      	strh	r3, [r2, #26]
  20206e:	61bb      	str	r3, [r7, #24]
  202070:	623a      	str	r2, [r7, #32]
        palSetLine( lineBrakeDirIN2 );
  202072:	f8a4 8018 	strh.w	r8, [r4, #24]
  202076:	f000 febb 	bl	202df0 <chThdSleep>
    tfconf.k = pressPower;
  20207a:	4b92      	ldr	r3, [pc, #584]	; (2022c4 <main+0xfb4>)
  20207c:	4a92      	ldr	r2, [pc, #584]	; (2022c8 <main+0xfb8>)
  20207e:	601a      	str	r2, [r3, #0]
        palSetLine( lineBrakeDirIN1 );
  202080:	6a3a      	ldr	r2, [r7, #32]
  202082:	69bb      	ldr	r3, [r7, #24]
  202084:	8313      	strh	r3, [r2, #24]
        palClearLine( lineBrakeDirIN2 );
  202086:	f8a4 801a 	strh.w	r8, [r4, #26]
  20208a:	e6f6      	b.n	201e7a <main+0xb6a>
                                if(((get_speed() > 0.3)||(get_speed() < -0.3)) && gov == 0)
  20208c:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
  202090:	a383      	add	r3, pc, #524	; (adr r3, 2022a0 <main+0xf90>)
  202092:	e9d3 2300 	ldrd	r2, r3, [r3]
  202096:	f7fe fd5b 	bl	200b50 <__aeabi_dcmplt>
  20209a:	2800      	cmp	r0, #0
  20209c:	f43f af1c 	beq.w	201ed8 <main+0xbc8>
  2020a0:	68fb      	ldr	r3, [r7, #12]
  2020a2:	2b00      	cmp	r3, #0
  2020a4:	f47f af18 	bne.w	201ed8 <main+0xbc8>
                                    gov = 1;
  2020a8:	2101      	movs	r1, #1
        palClearLine( lineBrakeDirIN1 );
  2020aa:	f44f 4200 	mov.w	r2, #32768	; 0x8000
        palSetLine( lineBrakeDirIN2 );
  2020ae:	2302      	movs	r3, #2
        palClearLine( lineBrakeDirIN1 );
  2020b0:	f8df 8208 	ldr.w	r8, [pc, #520]	; 2022bc <main+0xfac>
  2020b4:	60f9      	str	r1, [r7, #12]
                                    chThdSleepMilliseconds(2000);
  2020b6:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
        palSetLine( lineBrakeDirIN2 );
  2020ba:	4c81      	ldr	r4, [pc, #516]	; (2022c0 <main+0xfb0>)
    tfconf.k = pressPower;
  2020bc:	4981      	ldr	r1, [pc, #516]	; (2022c4 <main+0xfb4>)
  2020be:	600d      	str	r5, [r1, #0]
        palClearLine( lineBrakeDirIN1 );
  2020c0:	f8a8 201a 	strh.w	r2, [r8, #26]
  2020c4:	617a      	str	r2, [r7, #20]
        palSetLine( lineBrakeDirIN2 );
  2020c6:	8323      	strh	r3, [r4, #24]
  2020c8:	61bb      	str	r3, [r7, #24]
  2020ca:	f000 fe91 	bl	202df0 <chThdSleep>
    tfconf.k = pressPower;
  2020ce:	4b7d      	ldr	r3, [pc, #500]	; (2022c4 <main+0xfb4>)
  2020d0:	4a7d      	ldr	r2, [pc, #500]	; (2022c8 <main+0xfb8>)
  2020d2:	601a      	str	r2, [r3, #0]
        palSetLine( lineBrakeDirIN1 );
  2020d4:	697a      	ldr	r2, [r7, #20]
  2020d6:	f8a8 2018 	strh.w	r2, [r8, #24]
        palClearLine( lineBrakeDirIN2 );
  2020da:	69bb      	ldr	r3, [r7, #24]
  2020dc:	8363      	strh	r3, [r4, #26]
  2020de:	e6fb      	b.n	201ed8 <main+0xbc8>
  2020e0:	2320      	movs	r3, #32
  2020e2:	f383 8811 	msr	BASEPRI, r3
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
  2020e6:	7a33      	ldrb	r3, [r6, #8]
  2020e8:	2b01      	cmp	r3, #1
  2020ea:	d104      	bne.n	2020f6 <main+0xde6>
      rccEnableUSART6(FALSE);
    }
#endif
#if STM32_SERIAL_USE_UART7
    if (&SD7 == sdp) {
      rccEnableUART7(FALSE);
  2020ec:	4a77      	ldr	r2, [pc, #476]	; (2022cc <main+0xfbc>)
  2020ee:	6c13      	ldr	r3, [r2, #64]	; 0x40
  2020f0:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  2020f4:	6413      	str	r3, [r2, #64]	; 0x40
    if (&LPSD1 == sdp) {
      rccEnableLPUART1(FALSE);
    }
#endif
  }
  usart_init(sdp, config);
  2020f6:	4976      	ldr	r1, [pc, #472]	; (2022d0 <main+0xfc0>)
  2020f8:	4876      	ldr	r0, [pc, #472]	; (2022d4 <main+0xfc4>)
  2020fa:	f001 fc39 	bl	203970 <usart_init.lto_priv.59>

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
  2020fe:	2202      	movs	r2, #2
  202100:	2300      	movs	r3, #0
  202102:	7232      	strb	r2, [r6, #8]
  202104:	f383 8811 	msr	BASEPRI, r3
  202108:	2320      	movs	r3, #32
  20210a:	f383 8811 	msr	BASEPRI, r3
  if (sdp->state == SD_STOP) {
  20210e:	7a2b      	ldrb	r3, [r5, #8]
  202110:	2b01      	cmp	r3, #1
  202112:	d104      	bne.n	20211e <main+0xe0e>
      rccEnableUSART6(FALSE);
  202114:	4a6d      	ldr	r2, [pc, #436]	; (2022cc <main+0xfbc>)
  202116:	6c53      	ldr	r3, [r2, #68]	; 0x44
  202118:	f043 0320 	orr.w	r3, r3, #32
  20211c:	6453      	str	r3, [r2, #68]	; 0x44
  usart_init(sdp, config);
  20211e:	496c      	ldr	r1, [pc, #432]	; (2022d0 <main+0xfc0>)
  202120:	486d      	ldr	r0, [pc, #436]	; (2022d8 <main+0xfc8>)
  202122:	f001 fc25 	bl	203970 <usart_init.lto_priv.59>
  202126:	2202      	movs	r2, #2
  202128:	2300      	movs	r3, #0
  20212a:	722a      	strb	r2, [r5, #8]
  20212c:	f383 8811 	msr	BASEPRI, r3
  202130:	2320      	movs	r3, #32
  202132:	f383 8811 	msr	BASEPRI, r3
  if (sdp->state == SD_STOP) {
  202136:	f89b 3008 	ldrb.w	r3, [fp, #8]
  20213a:	2b01      	cmp	r3, #1
  20213c:	d104      	bne.n	202148 <main+0xe38>
      rccEnableUART5(FALSE);
  20213e:	4a63      	ldr	r2, [pc, #396]	; (2022cc <main+0xfbc>)
  202140:	6c13      	ldr	r3, [r2, #64]	; 0x40
  202142:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  202146:	6413      	str	r3, [r2, #64]	; 0x40
  usart_init(sdp, config);
  202148:	4961      	ldr	r1, [pc, #388]	; (2022d0 <main+0xfc0>)
  20214a:	4864      	ldr	r0, [pc, #400]	; (2022dc <main+0xfcc>)
  20214c:	f001 fc10 	bl	203970 <usart_init.lto_priv.59>
  202150:	2202      	movs	r2, #2
  202152:	2300      	movs	r3, #0
  202154:	f88b 2008 	strb.w	r2, [fp, #8]
  202158:	f383 8811 	msr	BASEPRI, r3
    palSetLineMode( leftSonarTX, PAL_MODE_ALTERNATE(8) );           // TX for left sensor
  20215c:	4d60      	ldr	r5, [pc, #384]	; (2022e0 <main+0xfd0>)
    palSetLineMode( frontLeftSonarTX, PAL_MODE_ALTERNATE(8) );      // TX for front left sensor
  20215e:	f240 4202 	movw	r2, #1026	; 0x402
  202162:	f44f 7180 	mov.w	r1, #256	; 0x100
  202166:	4855      	ldr	r0, [pc, #340]	; (2022bc <main+0xfac>)
  202168:	f001 fd5a 	bl	203c20 <_pal_lld_setgroupmode>
    palSetLineMode( frontLeftSonarRX, PAL_MODE_ALTERNATE(8) );      // RX for front left sensor
  20216c:	f240 4202 	movw	r2, #1026	; 0x402
  202170:	2180      	movs	r1, #128	; 0x80
  202172:	4852      	ldr	r0, [pc, #328]	; (2022bc <main+0xfac>)
  202174:	f001 fd54 	bl	203c20 <_pal_lld_setgroupmode>
    palSetLineMode( leftSonarTX, PAL_MODE_ALTERNATE(8) );           // TX for left sensor
  202178:	4628      	mov	r0, r5
  20217a:	f240 4202 	movw	r2, #1026	; 0x402
  20217e:	2140      	movs	r1, #64	; 0x40
  202180:	f001 fd4e 	bl	203c20 <_pal_lld_setgroupmode>
    palSetLineMode( leftSonarRX, PAL_MODE_ALTERNATE(8) );           // RX for left sensor
  202184:	4628      	mov	r0, r5
  202186:	f240 4202 	movw	r2, #1026	; 0x402
  20218a:	2180      	movs	r1, #128	; 0x80
  20218c:	f001 fd48 	bl	203c20 <_pal_lld_setgroupmode>
    palSetLineMode( backLeftSonarTX, PAL_MODE_ALTERNATE(8) );       // TX for back left sensor
  202190:	f240 4202 	movw	r2, #1026	; 0x402
  202194:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  202198:	4852      	ldr	r0, [pc, #328]	; (2022e4 <main+0xfd4>)
  20219a:	f001 fd41 	bl	203c20 <_pal_lld_setgroupmode>
    palSetLineMode( backLeftSonarRX, PAL_MODE_ALTERNATE(8) );       // RX for back left sensor
  20219e:	f240 4202 	movw	r2, #1026	; 0x402
  2021a2:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  2021a6:	484f      	ldr	r0, [pc, #316]	; (2022e4 <main+0xfd4>)
  2021a8:	f001 fd3a 	bl	203c20 <_pal_lld_setgroupmode>
    palSetPad(GPIOF, 4); //High level pin 4 for Sonar front left
  2021ac:	4a4e      	ldr	r2, [pc, #312]	; (2022e8 <main+0xfd8>)
  2021ae:	2310      	movs	r3, #16
    palSetPad(GPIOF, 5); //High level pin 4 for Sonar left
  2021b0:	2020      	movs	r0, #32
    isInitialized = true;
  2021b2:	2101      	movs	r1, #1
    palSetPad(GPIOF, 4); //High level pin 4 for Sonar front left
  2021b4:	8313      	strh	r3, [r2, #24]
    palSetPad(GPIOF, 5); //High level pin 4 for Sonar left
  2021b6:	8310      	strh	r0, [r2, #24]
    palSetPad(GPIOC, 4); //High level pin 4 for Sonar back left
  2021b8:	832b      	strh	r3, [r5, #24]
    isInitialized = true;
  2021ba:	7021      	strb	r1, [r4, #0]
  2021bc:	e4e2      	b.n	201b84 <main+0x874>
    palSetLineMode(driveSpeedLine, PAL_MODE_INPUT_ANALOG);          // GPIOA 4 for DAC
  2021be:	2203      	movs	r2, #3
  2021c0:	2110      	movs	r1, #16
  2021c2:	484a      	ldr	r0, [pc, #296]	; (2022ec <main+0xfdc>)
  2021c4:	f001 fd2c 	bl	203c20 <_pal_lld_setgroupmode>
    palSetLineMode(driveDirectionLine, PAL_MODE_OUTPUT_OPENDRAIN ); // GPIOD 3 for direction
  2021c8:	2205      	movs	r2, #5
  2021ca:	2108      	movs	r1, #8
  2021cc:	4848      	ldr	r0, [pc, #288]	; (2022f0 <main+0xfe0>)
  2021ce:	f001 fd27 	bl	203c20 <_pal_lld_setgroupmode>
  2021d2:	2320      	movs	r3, #32
  2021d4:	f383 8811 	msr	BASEPRI, r3
 */
void dac_lld_start(DACDriver *dacp) {

  /* If the driver is in DAC_STOP state then a full initialization is
     required.*/
  if (dacp->state == DAC_STOP) {
  2021d8:	4a46      	ldr	r2, [pc, #280]	; (2022f4 <main+0xfe4>)
  osalSysLock();

  osalDbgAssert((dacp->state == DAC_STOP) || (dacp->state == DAC_READY),
                "invalid state");

  dacp->config = config;
  2021da:	4b47      	ldr	r3, [pc, #284]	; (2022f8 <main+0xfe8>)
  2021dc:	f892 c000 	ldrb.w	ip, [r2]
  2021e0:	6113      	str	r3, [r2, #16]
  2021e2:	f1bc 0f01 	cmp.w	ip, #1
  2021e6:	d11d      	bne.n	202224 <main+0xf14>
    dacchannel_t channel = 0;

    /* Enabling the clock source.*/
#if STM32_DAC_USE_DAC1_CH1
    if (&DACD1 == dacp) {
      rccEnableDAC1(false);
  2021e8:	f8df e0e0 	ldr.w	lr, [pc, #224]	; 2022cc <main+0xfbc>
    /* Enabling DAC in SW triggering mode initially, initializing data to
       zero.*/
#if STM32_DAC_DUAL_MODE == FALSE
    dacp->params->dac->CR &= dacp->params->regmask;
    dacp->params->dac->CR |= (DAC_CR_EN1 | dacp->config->cr) << dacp->params->regshift;
    dac_lld_put_channel(dacp, channel, dacp->config->init);
  2021ec:	4649      	mov	r1, r9
    dacp->params->dac->CR &= dacp->params->regmask;
  2021ee:	6a93      	ldr	r3, [r2, #40]	; 0x28
      rccEnableDAC1(false);
  2021f0:	f8de 0040 	ldr.w	r0, [lr, #64]	; 0x40
    dacp->params->dac->CR &= dacp->params->regmask;
  2021f4:	681a      	ldr	r2, [r3, #0]
      rccEnableDAC1(false);
  2021f6:	f040 5900 	orr.w	r9, r0, #536870912	; 0x20000000
    dac_lld_put_channel(dacp, channel, dacp->config->init);
  2021fa:	483e      	ldr	r0, [pc, #248]	; (2022f4 <main+0xfe4>)
      rccEnableDAC1(false);
  2021fc:	f8ce 9040 	str.w	r9, [lr, #64]	; 0x40
    dacp->params->dac->CR &= dacp->params->regmask;
  202200:	f8d2 e000 	ldr.w	lr, [r2]
  202204:	f8d3 900c 	ldr.w	r9, [r3, #12]
    dacp->params->dac->CR |= (DAC_CR_EN1 | dacp->config->cr) << dacp->params->regshift;
  202208:	689b      	ldr	r3, [r3, #8]
    dacp->params->dac->CR &= dacp->params->regmask;
  20220a:	ea0e 0e09 	and.w	lr, lr, r9
    dacp->params->dac->CR |= (DAC_CR_EN1 | dacp->config->cr) << dacp->params->regshift;
  20220e:	fa0c f303 	lsl.w	r3, ip, r3
    dacp->params->dac->CR &= dacp->params->regmask;
  202212:	f8c2 e000 	str.w	lr, [r2]
    dacp->params->dac->CR |= (DAC_CR_EN1 | dacp->config->cr) << dacp->params->regshift;
  202216:	f8d2 e000 	ldr.w	lr, [r2]
  20221a:	ea43 030e 	orr.w	r3, r3, lr
  20221e:	6013      	str	r3, [r2, #0]
    dac_lld_put_channel(dacp, channel, dacp->config->init);
  202220:	f002 f85e 	bl	2042e0 <dac_lld_put_channel.constprop.14>
  dac_lld_start(dacp);
  dacp->state = DAC_READY;
  202224:	2202      	movs	r2, #2
  202226:	4933      	ldr	r1, [pc, #204]	; (2022f4 <main+0xfe4>)
  202228:	2300      	movs	r3, #0
  20222a:	700a      	strb	r2, [r1, #0]
  20222c:	f383 8811 	msr	BASEPRI, r3
    isInitialized = true;
  202230:	2301      	movs	r3, #1
  202232:	f888 3000 	strb.w	r3, [r8]
  202236:	e40c      	b.n	201a52 <main+0x742>
  202238:	61bb      	str	r3, [r7, #24]
  20223a:	2220      	movs	r2, #32
  20223c:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheck((gptp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
              "invalid state");
  gptp->config = config;
  202240:	492e      	ldr	r1, [pc, #184]	; (2022fc <main+0xfec>)
  gpt_lld_start(gptp);
  202242:	482f      	ldr	r0, [pc, #188]	; (202300 <main+0xff0>)
  202244:	617a      	str	r2, [r7, #20]
  gptp->config = config;
  202246:	6041      	str	r1, [r0, #4]
  202248:	6239      	str	r1, [r7, #32]
  gpt_lld_start(gptp);
  20224a:	f001 fc91 	bl	203b70 <gpt_lld_start>
  gptp->state = GPT_READY;
  20224e:	4b2c      	ldr	r3, [pc, #176]	; (202300 <main+0xff0>)
  202250:	f04f 0202 	mov.w	r2, #2
  202254:	701a      	strb	r2, [r3, #0]
  202256:	69bb      	ldr	r3, [r7, #24]
  202258:	f383 8811 	msr	BASEPRI, r3
    gptStart( GPT_Driver, &GPT9cfg );
    gptStartContinuous( GPT_Driver, TMR_TICKS_2_OVRFLOW );
  20225c:	6a39      	ldr	r1, [r7, #32]
  20225e:	4829      	ldr	r0, [pc, #164]	; (202304 <main+0xff4>)
  202260:	6809      	ldr	r1, [r1, #0]
  202262:	61bb      	str	r3, [r7, #24]
  202264:	fba0 3101 	umull	r3, r1, r0, r1
  202268:	697a      	ldr	r2, [r7, #20]
  20226a:	0949      	lsrs	r1, r1, #5
  20226c:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheckClassI();
  osalDbgCheck(gptp != NULL);
  osalDbgAssert(gptp->state == GPT_READY,
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
  202270:	f04f 0e03 	mov.w	lr, #3
  gpt_lld_start_timer(gptp, interval);
  202274:	4822      	ldr	r0, [pc, #136]	; (202300 <main+0xff0>)
  202276:	623a      	str	r2, [r7, #32]
  gptp->state = GPT_CONTINUOUS;
  202278:	f880 e000 	strb.w	lr, [r0]
  gpt_lld_start_timer(gptp, interval);
  20227c:	f001 fc60 	bl	203b40 <gpt_lld_start_timer>
  202280:	69bb      	ldr	r3, [r7, #24]
  202282:	f383 8811 	msr	BASEPRI, r3
/*
 * @brief       Starts EXT module
 */
void lld_Encoder_Init(void)
{
    if ( Enc_is_Initialized ) return;
  202286:	4b20      	ldr	r3, [pc, #128]	; (202308 <main+0xff8>)
  202288:	6a3a      	ldr	r2, [r7, #32]
  20228a:	781b      	ldrb	r3, [r3, #0]
  20228c:	2b00      	cmp	r3, #0
  20228e:	d041      	beq.n	202314 <main+0x1004>
    lld_Encoder_Init();
    Odometry_is_Initialized = true;
  202290:	2301      	movs	r3, #1
  202292:	4a1e      	ldr	r2, [pc, #120]	; (20230c <main+0xffc>)
  202294:	7013      	strb	r3, [r2, #0]
  202296:	f7ff bbd4 	b.w	201a42 <main+0x732>
  20229a:	bf00      	nop
  20229c:	f3af 8000 	nop.w
  2022a0:	33333333 	.word	0x33333333
  2022a4:	bfd33333 	.word	0xbfd33333
  2022a8:	200009f0 	.word	0x200009f0
  2022ac:	200009f2 	.word	0x200009f2
  2022b0:	200009ee 	.word	0x200009ee
  2022b4:	200009f8 	.word	0x200009f8
  2022b8:	2000088c 	.word	0x2000088c
  2022bc:	40021000 	.word	0x40021000
  2022c0:	40021800 	.word	0x40021800
  2022c4:	200200bc 	.word	0x200200bc
  2022c8:	c2480000 	.word	0xc2480000
  2022cc:	40023800 	.word	0x40023800
  2022d0:	08004f90 	.word	0x08004f90
  2022d4:	20000cf0 	.word	0x20000cf0
  2022d8:	20000880 	.word	0x20000880
  2022dc:	20000820 	.word	0x20000820
  2022e0:	40020800 	.word	0x40020800
  2022e4:	40020400 	.word	0x40020400
  2022e8:	40021400 	.word	0x40021400
  2022ec:	40020000 	.word	0x40020000
  2022f0:	40020c00 	.word	0x40020c00
  2022f4:	20000c64 	.word	0x20000c64
  2022f8:	08004ec8 	.word	0x08004ec8
  2022fc:	20020088 	.word	0x20020088
  202300:	2000080c 	.word	0x2000080c
  202304:	51eb851f 	.word	0x51eb851f
  202308:	20000808 	.word	0x20000808
  20230c:	2000081c 	.word	0x2000081c
  202310:	200009dc 	.word	0x200009dc
  202314:	f382 8811 	msr	BASEPRI, r2
 * @notapi
 */
void ext_lld_start(EXTDriver *extp) {
  expchannel_t line;

  if (extp->state == EXT_STOP)
  202318:	4b72      	ldr	r3, [pc, #456]	; (2024e4 <main+0x11d4>)
  osalDbgCheck((extp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((extp->state == EXT_STOP) || (extp->state == EXT_ACTIVE),
                "invalid state");
  extp->config = config;
  20231a:	4a72      	ldr	r2, [pc, #456]	; (2024e4 <main+0x11d4>)
  20231c:	781b      	ldrb	r3, [r3, #0]
  20231e:	4972      	ldr	r1, [pc, #456]	; (2024e8 <main+0x11d8>)
  202320:	2b01      	cmp	r3, #1
  202322:	6051      	str	r1, [r2, #4]
  202324:	d16e      	bne.n	202404 <main+0x10f4>
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202326:	f44f 7180 	mov.w	r1, #256	; 0x100
  20232a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  20232e:	f44f 7200 	mov.w	r2, #512	; 0x200
  202332:	2040      	movs	r0, #64	; 0x40
  202334:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
  202338:	2480      	movs	r4, #128	; 0x80
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20233a:	f888 9306 	strb.w	r9, [r8, #774]	; 0x306
  20233e:	f04f 0ef0 	mov.w	lr, #240	; 0xf0
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202342:	f8c8 0180 	str.w	r0, [r8, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  202346:	f8c8 0000 	str.w	r0, [r8]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20234a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20234e:	f888 9307 	strb.w	r9, [r8, #775]	; 0x307
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202352:	f8c8 4180 	str.w	r4, [r8, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  202356:	f8c8 4000 	str.w	r4, [r8]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20235a:	f888 9308 	strb.w	r9, [r8, #776]	; 0x308
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20235e:	f8c8 1180 	str.w	r1, [r8, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  202362:	f8c8 1000 	str.w	r1, [r8]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  202366:	f888 9309 	strb.w	r9, [r8, #777]	; 0x309
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20236a:	f8c8 2180 	str.w	r2, [r8, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20236e:	f8c8 2000 	str.w	r2, [r8]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  202372:	f888 930a 	strb.w	r9, [r8, #778]	; 0x30a
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202376:	f8c8 3180 	str.w	r3, [r8, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20237a:	f8c8 3000 	str.w	r3, [r8]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20237e:	f888 9317 	strb.w	r9, [r8, #791]	; 0x317
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202382:	f8c8 c180 	str.w	ip, [r8, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  202386:	f8c8 c000 	str.w	ip, [r8]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20238a:	f04f 5c00 	mov.w	ip, #536870912	; 0x20000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20238e:	f888 9328 	strb.w	r9, [r8, #808]	; 0x328
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  202392:	f8c8 1184 	str.w	r1, [r8, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  202396:	f8c8 1004 	str.w	r1, [r8, #4]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20239a:	2102      	movs	r1, #2
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20239c:	f888 9301 	strb.w	r9, [r8, #769]	; 0x301
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2023a0:	f8c8 1180 	str.w	r1, [r8, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  2023a4:	f8c8 1000 	str.w	r1, [r8]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2023a8:	f888 e329 	strb.w	lr, [r8, #809]	; 0x329
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2023ac:	f8c8 2184 	str.w	r2, [r8, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  2023b0:	f8c8 2004 	str.w	r2, [r8, #4]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2023b4:	f888 932a 	strb.w	r9, [r8, #810]	; 0x32a
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2023b8:	f8c8 3184 	str.w	r3, [r8, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  2023bc:	f8c8 3004 	str.w	r3, [r8, #4]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2023c0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2023c4:	f888 933e 	strb.w	r9, [r8, #830]	; 0x33e
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2023c8:	f8c8 3184 	str.w	r3, [r8, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  2023cc:	f8c8 3004 	str.w	r3, [r8, #4]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2023d0:	2304      	movs	r3, #4
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2023d2:	f888 934c 	strb.w	r9, [r8, #844]	; 0x34c
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2023d6:	f8c8 0188 	str.w	r0, [r8, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  2023da:	f8c8 0008 	str.w	r0, [r8, #8]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2023de:	f888 e302 	strb.w	lr, [r8, #770]	; 0x302
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2023e2:	f8c8 3180 	str.w	r3, [r8, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  2023e6:	f8c8 3000 	str.w	r3, [r8]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2023ea:	2308      	movs	r3, #8
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2023ec:	f888 e303 	strb.w	lr, [r8, #771]	; 0x303
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2023f0:	f8c8 3180 	str.w	r3, [r8, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  2023f4:	f8c8 3000 	str.w	r3, [r8]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2023f8:	f888 935d 	strb.w	r9, [r8, #861]	; 0x35d
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2023fc:	f8c8 c188 	str.w	ip, [r8, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  202400:	f8c8 c008 	str.w	ip, [r8, #8]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
  202404:	2000      	movs	r0, #0
  (void)extp;

#if STM32_EXTI_NUM_LINES > 32
  if (channel < 32) {
#endif
    EXTI->IMR  &= ~cmask;
  202406:	4b39      	ldr	r3, [pc, #228]	; (2024ec <main+0x11dc>)
  202408:	4680      	mov	r8, r0
  20240a:	e017      	b.n	20243c <main+0x112c>
  uint32_t cmask = (1 << (channel & 0x1F));
  20240c:	fa02 f108 	lsl.w	r1, r2, r8
    EXTI->IMR  &= ~cmask;
  202410:	6818      	ldr	r0, [r3, #0]
  202412:	43ca      	mvns	r2, r1
  202414:	4010      	ands	r0, r2
  202416:	6018      	str	r0, [r3, #0]
    EXTI->EMR  &= ~cmask;
  202418:	6858      	ldr	r0, [r3, #4]
  20241a:	4010      	ands	r0, r2
  20241c:	6058      	str	r0, [r3, #4]
    EXTI->RTSR &= ~cmask;
  20241e:	6898      	ldr	r0, [r3, #8]
  202420:	4010      	ands	r0, r2
  202422:	6098      	str	r0, [r3, #8]
    EXTI->FTSR &= ~cmask;
  202424:	68d8      	ldr	r0, [r3, #12]
  202426:	4002      	ands	r2, r0
  202428:	60da      	str	r2, [r3, #12]
    EXTI->PR    =  cmask;
  20242a:	6159      	str	r1, [r3, #20]
  for (line = 0; line < EXT_MAX_CHANNELS; line++)
  20242c:	f108 0801 	add.w	r8, r8, #1
  202430:	f1b8 0f18 	cmp.w	r8, #24
  202434:	d044      	beq.n	2024c0 <main+0x11b0>
  202436:	4a2c      	ldr	r2, [pc, #176]	; (2024e8 <main+0x11d8>)
  202438:	f852 0038 	ldr.w	r0, [r2, r8, lsl #3]
    if (extp->config->channels[line].mode & EXT_CH_MODE_AUTOSTART)
  20243c:	0741      	lsls	r1, r0, #29
  uint32_t cmask = (1 << (channel & 0x1F));
  20243e:	f04f 0201 	mov.w	r2, #1
    if (extp->config->channels[line].mode & EXT_CH_MODE_AUTOSTART)
  202442:	d5e3      	bpl.n	20240c <main+0x10fc>
  if (channel < 16) {
  202444:	f1b8 0f0f 	cmp.w	r8, #15
  uint32_t cmask = (1 << (channel & 0x1F));
  202448:	fa02 f908 	lsl.w	r9, r2, r8
  if (channel < 16) {
  20244c:	d816      	bhi.n	20247c <main+0x116c>
  20244e:	f028 0e03 	bic.w	lr, r8, #3
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
  202452:	f008 0103 	and.w	r1, r8, #3
  202456:	240f      	movs	r4, #15
                      EXT_MODE_GPIO_MASK) >>
  202458:	f3c0 1203 	ubfx	r2, r0, #4, #4
  20245c:	f10e 4e80 	add.w	lr, lr, #1073741824	; 0x40000000
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
  202460:	0089      	lsls	r1, r1, #2
  202462:	f50e 3e9c 	add.w	lr, lr, #79872	; 0x13800
  202466:	fa04 fc01 	lsl.w	ip, r4, r1
    uint32_t port = ((extp->config->channels[channel].mode &
  20246a:	408a      	lsls	r2, r1
    SYSCFG->EXTICR[n] = (SYSCFG->EXTICR[n] & mask) | port;
  20246c:	f8de 4008 	ldr.w	r4, [lr, #8]
  202470:	ea24 0c0c 	bic.w	ip, r4, ip
  202474:	ea42 020c 	orr.w	r2, r2, ip
  202478:	f8ce 2008 	str.w	r2, [lr, #8]
      EXTI->RTSR |= cmask;
  20247c:	689a      	ldr	r2, [r3, #8]
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
  20247e:	07c4      	lsls	r4, r0, #31
  202480:	ea6f 0109 	mvn.w	r1, r9
      EXTI->RTSR |= cmask;
  202484:	bf4c      	ite	mi
  202486:	ea49 0202 	orrmi.w	r2, r9, r2
      EXTI->RTSR &= ~cmask;
  20248a:	400a      	andpl	r2, r1
    if (extp->config->channels[channel].mode & EXT_CH_MODE_FALLING_EDGE)
  20248c:	0780      	lsls	r0, r0, #30
      EXTI->RTSR &= ~cmask;
  20248e:	609a      	str	r2, [r3, #8]
      EXTI->FTSR |= cmask;
  202490:	68da      	ldr	r2, [r3, #12]
  202492:	bf4c      	ite	mi
  202494:	ea49 0202 	orrmi.w	r2, r9, r2
      EXTI->FTSR &= ~cmask;
  202498:	400a      	andpl	r2, r1
  20249a:	60da      	str	r2, [r3, #12]
    if (extp->config->channels[channel].cb != NULL) {
  20249c:	4a12      	ldr	r2, [pc, #72]	; (2024e8 <main+0x11d8>)
  20249e:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
  2024a2:	6852      	ldr	r2, [r2, #4]
  2024a4:	b1b2      	cbz	r2, 2024d4 <main+0x11c4>
      EXTI->IMR |= cmask;
  2024a6:	681a      	ldr	r2, [r3, #0]
  for (line = 0; line < EXT_MAX_CHANNELS; line++)
  2024a8:	f108 0801 	add.w	r8, r8, #1
      EXTI->IMR |= cmask;
  2024ac:	ea49 0202 	orr.w	r2, r9, r2
  for (line = 0; line < EXT_MAX_CHANNELS; line++)
  2024b0:	f1b8 0f18 	cmp.w	r8, #24
      EXTI->IMR |= cmask;
  2024b4:	601a      	str	r2, [r3, #0]
      EXTI->EMR &= ~cmask;
  2024b6:	685a      	ldr	r2, [r3, #4]
  2024b8:	ea01 0102 	and.w	r1, r1, r2
  2024bc:	6059      	str	r1, [r3, #4]
  for (line = 0; line < EXT_MAX_CHANNELS; line++)
  2024be:	d1ba      	bne.n	202436 <main+0x1126>
  ext_lld_start(extp);
  extp->state = EXT_ACTIVE;
  2024c0:	2202      	movs	r2, #2
  2024c2:	4908      	ldr	r1, [pc, #32]	; (2024e4 <main+0x11d4>)
  2024c4:	2300      	movs	r3, #0
  2024c6:	700a      	strb	r2, [r1, #0]
  2024c8:	f383 8811 	msr	BASEPRI, r3
    extStart( &EXTD1, &EXTcfg );
    Enc_is_Initialized = true;
  2024cc:	2301      	movs	r3, #1
  2024ce:	4a08      	ldr	r2, [pc, #32]	; (2024f0 <main+0x11e0>)
  2024d0:	7013      	strb	r3, [r2, #0]
  2024d2:	e6dd      	b.n	202290 <main+0xf80>
      EXTI->EMR |= cmask;
  2024d4:	685a      	ldr	r2, [r3, #4]
  2024d6:	ea49 0202 	orr.w	r2, r9, r2
  2024da:	605a      	str	r2, [r3, #4]
      EXTI->IMR &= ~cmask;
  2024dc:	681a      	ldr	r2, [r3, #0]
  2024de:	4011      	ands	r1, r2
  2024e0:	6019      	str	r1, [r3, #0]
  2024e2:	e7a3      	b.n	20242c <main+0x111c>
  2024e4:	20000800 	.word	0x20000800
  2024e8:	08004ed0 	.word	0x08004ed0
  2024ec:	40013c00 	.word	0x40013c00
  2024f0:	20000808 	.word	0x20000808
	...

00202500 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
  202500:	b480      	push	{r7}
  202502:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
  202504:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
  202508:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
  20250a:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
  20250e:	2300      	movs	r3, #0
  202510:	f383 8811 	msr	BASEPRI, r3
  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
  202514:	46bd      	mov	sp, r7
  202516:	bc80      	pop	{r7}
  202518:	4770      	bx	lr
  20251a:	bf00      	nop
  20251c:	0000      	movs	r0, r0
	...

00202520 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
  202520:	b470      	push	{r4, r5, r6}
  202522:	2320      	movs	r3, #32
  202524:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
  202528:	4e0d      	ldr	r6, [pc, #52]	; (202560 <chCoreAllocAligned+0x40>)
  size = MEM_ALIGN_NEXT(size, align);
  20252a:	1e4a      	subs	r2, r1, #1
  20252c:	424d      	negs	r5, r1
  if (((size_t)endmem - (size_t)p) < size) {
  20252e:	4c0d      	ldr	r4, [pc, #52]	; (202564 <chCoreAllocAligned+0x44>)
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
  202530:	6833      	ldr	r3, [r6, #0]
  size = MEM_ALIGN_NEXT(size, align);
  202532:	4402      	add	r2, r0
  if (((size_t)endmem - (size_t)p) < size) {
  202534:	6824      	ldr	r4, [r4, #0]
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
  202536:	3b01      	subs	r3, #1
  size = MEM_ALIGN_NEXT(size, align);
  202538:	402a      	ands	r2, r5
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
  20253a:	1858      	adds	r0, r3, r1
  20253c:	4028      	ands	r0, r5
  if (((size_t)endmem - (size_t)p) < size) {
  20253e:	1a23      	subs	r3, r4, r0
  202540:	429a      	cmp	r2, r3
  202542:	d806      	bhi.n	202552 <chCoreAllocAligned+0x32>
  nextmem = p + size;
  202544:	4402      	add	r2, r0
  202546:	2300      	movs	r3, #0
  202548:	6032      	str	r2, [r6, #0]
  20254a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedI(size, align);
  chSysUnlock();

  return p;
}
  20254e:	bc70      	pop	{r4, r5, r6}
  202550:	4770      	bx	lr
    return NULL;
  202552:	2000      	movs	r0, #0
  202554:	2300      	movs	r3, #0
  202556:	f383 8811 	msr	BASEPRI, r3
}
  20255a:	bc70      	pop	{r4, r5, r6}
  20255c:	4770      	bx	lr
  20255e:	bf00      	nop
  202560:	200009fc 	.word	0x200009fc
  202564:	200009d8 	.word	0x200009d8
	...

00202570 <wakeup>:
  202570:	2320      	movs	r3, #32
  202572:	f383 8811 	msr	BASEPRI, r3
 */
static void wakeup(void *p) {
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
  202576:	f890 3020 	ldrb.w	r3, [r0, #32]
  20257a:	2b07      	cmp	r3, #7
  20257c:	d80e      	bhi.n	20259c <wakeup+0x2c>
  20257e:	e8df f003 	tbb	[pc, r3]
  202582:	0d28      	.short	0x0d28
  202584:	0408240d 	.word	0x0408240d
  202588:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
  20258a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
  20258c:	6893      	ldr	r3, [r2, #8]
  20258e:	3301      	adds	r3, #1
  202590:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
  202592:	e890 000c 	ldmia.w	r0, {r2, r3}
  202596:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
  202598:	6802      	ldr	r2, [r0, #0]
  20259a:	6053      	str	r3, [r2, #4]
  tp->state = CH_STATE_READY;
  20259c:	2200      	movs	r2, #0
  20259e:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
  2025a0:	4b0e      	ldr	r3, [pc, #56]	; (2025dc <wakeup+0x6c>)
  tp->state = CH_STATE_READY;
  2025a2:	f880 2020 	strb.w	r2, [r0, #32]
static void wakeup(void *p) {
  2025a6:	b410      	push	{r4}
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  2025a8:	f04f 34ff 	mov.w	r4, #4294967295
  2025ac:	6244      	str	r4, [r0, #36]	; 0x24
    cp = cp->queue.next;
  2025ae:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
  2025b0:	689a      	ldr	r2, [r3, #8]
  2025b2:	428a      	cmp	r2, r1
  2025b4:	d2fb      	bcs.n	2025ae <wakeup+0x3e>
  tp->queue.prev             = cp->queue.prev;
  2025b6:	685a      	ldr	r2, [r3, #4]
  2025b8:	2100      	movs	r1, #0
  tp->queue.next             = cp;
  2025ba:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
  2025bc:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
  2025be:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
  2025c0:	6058      	str	r0, [r3, #4]
  2025c2:	f381 8811 	msr	BASEPRI, r1
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
  2025c6:	bc10      	pop	{r4}
  2025c8:	4770      	bx	lr
    *tp->u.wttrp = NULL;
  2025ca:	6a43      	ldr	r3, [r0, #36]	; 0x24
  2025cc:	2200      	movs	r2, #0
  2025ce:	601a      	str	r2, [r3, #0]
  2025d0:	e7e4      	b.n	20259c <wakeup+0x2c>
  2025d2:	2300      	movs	r3, #0
  2025d4:	f383 8811 	msr	BASEPRI, r3
  2025d8:	4770      	bx	lr
  2025da:	bf00      	nop
  2025dc:	20000d78 	.word	0x20000d78

002025e0 <_idle_thread.lto_priv.58>:
static void _idle_thread(void *p) {
  2025e0:	e7fe      	b.n	2025e0 <_idle_thread.lto_priv.58>
  2025e2:	bf00      	nop
	...

002025f0 <chSchGoSleepS>:
  thread_t *otp = currp;
  2025f0:	4b08      	ldr	r3, [pc, #32]	; (202614 <chSchGoSleepS+0x24>)
  thread_t *tp = tqp->next;
  2025f2:	681a      	ldr	r2, [r3, #0]
  2025f4:	6999      	ldr	r1, [r3, #24]
void chSchGoSleepS(tstate_t newstate) {
  2025f6:	b430      	push	{r4, r5}
  otp->state = newstate;
  2025f8:	f881 0020 	strb.w	r0, [r1, #32]
  currp->state = CH_STATE_CURRENT;
  2025fc:	2501      	movs	r5, #1
  tqp->next             = tp->queue.next;
  2025fe:	6814      	ldr	r4, [r2, #0]
  chSysSwitch(currp, otp);
  202600:	4610      	mov	r0, r2
  tqp->next->queue.prev = (thread_t *)tqp;
  202602:	6063      	str	r3, [r4, #4]
  tqp->next             = tp->queue.next;
  202604:	601c      	str	r4, [r3, #0]
  currp->state = CH_STATE_CURRENT;
  202606:	f882 5020 	strb.w	r5, [r2, #32]
  currp = queue_fifo_remove(&ch.rlist.queue);
  20260a:	619a      	str	r2, [r3, #24]
}
  20260c:	bc30      	pop	{r4, r5}
  chSysSwitch(currp, otp);
  20260e:	f7fd be61 	b.w	2002d4 <_port_switch>
  202612:	bf00      	nop
  202614:	20000d78 	.word	0x20000d78
	...

00202620 <pwmEnableChannel>:
 *
 * @api
 */
void pwmEnableChannel(PWMDriver *pwmp,
                      pwmchannel_t channel,
                      pwmcnt_t width) {
  202620:	b410      	push	{r4}
  202622:	2320      	movs	r3, #32
  202624:	f383 8811 	msr	BASEPRI, r3

  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");

  pwmEnableChannelI(pwmp, channel, width);
  202628:	2401      	movs	r4, #1
  20262a:	68c3      	ldr	r3, [r0, #12]

  /* Changing channel duty cycle on the fly.*/
#if STM32_TIM_MAX_CHANNELS <= 4
  pwmp->tim->CCR[channel] = width;
#else
  if (channel < 4)
  20262c:	2903      	cmp	r1, #3
  20262e:	fa04 f401 	lsl.w	r4, r4, r1
  202632:	ea43 0304 	orr.w	r3, r3, r4
  202636:	60c3      	str	r3, [r0, #12]
    pwmp->tim->CCR[channel] = width;
  202638:	6983      	ldr	r3, [r0, #24]
  if (channel < 4)
  20263a:	d907      	bls.n	20264c <pwmEnableChannel+0x2c>
  else
    pwmp->tim->CCXR[channel - 4] = width;
  20263c:	3112      	adds	r1, #18
  20263e:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
  202642:	2300      	movs	r3, #0
  202644:	f383 8811 	msr	BASEPRI, r3

  osalSysUnlock();
}
  202648:	bc10      	pop	{r4}
  20264a:	4770      	bx	lr
    pwmp->tim->CCR[channel] = width;
  20264c:	310c      	adds	r1, #12
  20264e:	eb03 0181 	add.w	r1, r3, r1, lsl #2
  202652:	2300      	movs	r3, #0
  202654:	604a      	str	r2, [r1, #4]
  202656:	f383 8811 	msr	BASEPRI, r3
  20265a:	bc10      	pop	{r4}
  20265c:	4770      	bx	lr
  20265e:	bf00      	nop

00202660 <_port_irq_epilogue>:
  202660:	2320      	movs	r3, #32
  202662:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202666:	4b11      	ldr	r3, [pc, #68]	; (2026ac <_port_irq_epilogue+0x4c>)
  202668:	685b      	ldr	r3, [r3, #4]
  20266a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  20266e:	d102      	bne.n	202676 <_port_irq_epilogue+0x16>
  202670:	f383 8811 	msr	BASEPRI, r3
  202674:	4770      	bx	lr
void _port_irq_epilogue(void) {
  202676:	b480      	push	{r7}
  202678:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
  20267a:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
  20267e:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp--;
  202682:	f1a3 0220 	sub.w	r2, r3, #32
    ctxp->xpsr = (regarm_t)0x01000000;
  202686:	f843 1c04 	str.w	r1, [r3, #-4]
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
  20268a:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
  20268e:	4a08      	ldr	r2, [pc, #32]	; (2026b0 <_port_irq_epilogue+0x50>)
  202690:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
  202692:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
  202694:	6889      	ldr	r1, [r1, #8]
  202696:	6892      	ldr	r2, [r2, #8]
  202698:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
  20269a:	bf8c      	ite	hi
  20269c:	4a05      	ldrhi	r2, [pc, #20]	; (2026b4 <_port_irq_epilogue+0x54>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
  20269e:	4a06      	ldrls	r2, [pc, #24]	; (2026b8 <_port_irq_epilogue+0x58>)
  2026a0:	f843 2c08 	str.w	r2, [r3, #-8]
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
  2026a4:	46bd      	mov	sp, r7
  2026a6:	bc80      	pop	{r7}
  2026a8:	4770      	bx	lr
  2026aa:	bf00      	nop
  2026ac:	e000ed00 	.word	0xe000ed00
  2026b0:	20000d78 	.word	0x20000d78
  2026b4:	002002f5 	.word	0x002002f5
  2026b8:	002002f8 	.word	0x002002f8
  2026bc:	00000000 	.word	0x00000000

002026c0 <Vector4C>:
OSAL_IRQ_HANDLER(Vector4C) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
  2026c0:	4a09      	ldr	r2, [pc, #36]	; (2026e8 <Vector4C+0x28>)
OSAL_IRQ_HANDLER(Vector4C) {
  2026c2:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  2026c4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 22);
  2026c6:	6811      	ldr	r1, [r2, #0]
  2026c8:	400b      	ands	r3, r1
  2026ca:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  EXTI->PR = pr;
  2026ce:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 22))
  2026d0:	b12b      	cbz	r3, 2026de <Vector4C+0x1e>
    EXTD1.config->channels[22].cb(&EXTD1, 22);
  2026d2:	4806      	ldr	r0, [pc, #24]	; (2026ec <Vector4C+0x2c>)
  2026d4:	2116      	movs	r1, #22
  2026d6:	6843      	ldr	r3, [r0, #4]
  2026d8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
  2026dc:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
  2026de:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  2026e2:	f7ff bfbd 	b.w	202660 <_port_irq_epilogue>
  2026e6:	bf00      	nop
  2026e8:	40013c00 	.word	0x40013c00
  2026ec:	20000800 	.word	0x20000800

002026f0 <Vector48>:
  pr = EXTI->PR;
  2026f0:	4a09      	ldr	r2, [pc, #36]	; (202718 <Vector48+0x28>)
OSAL_IRQ_HANDLER(Vector48) {
  2026f2:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  2026f4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 21);
  2026f6:	6811      	ldr	r1, [r2, #0]
  2026f8:	400b      	ands	r3, r1
  2026fa:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  EXTI->PR = pr;
  2026fe:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 21))
  202700:	b12b      	cbz	r3, 20270e <Vector48+0x1e>
    EXTD1.config->channels[21].cb(&EXTD1, 21);
  202702:	4806      	ldr	r0, [pc, #24]	; (20271c <Vector48+0x2c>)
  202704:	2115      	movs	r1, #21
  202706:	6843      	ldr	r3, [r0, #4]
  202708:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
  20270c:	4798      	blx	r3
}
  20270e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  202712:	f7ff bfa5 	b.w	202660 <_port_irq_epilogue>
  202716:	bf00      	nop
  202718:	40013c00 	.word	0x40013c00
  20271c:	20000800 	.word	0x20000800

00202720 <Vector170>:
  pr = EXTI->PR;
  202720:	4a09      	ldr	r2, [pc, #36]	; (202748 <Vector170+0x28>)
OSAL_IRQ_HANDLER(Vector170) {
  202722:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  202724:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 20);
  202726:	6811      	ldr	r1, [r2, #0]
  202728:	400b      	ands	r3, r1
  20272a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
  EXTI->PR = pr;
  20272e:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 20))
  202730:	b12b      	cbz	r3, 20273e <Vector170+0x1e>
    EXTD1.config->channels[20].cb(&EXTD1, 20);
  202732:	4806      	ldr	r0, [pc, #24]	; (20274c <Vector170+0x2c>)
  202734:	2114      	movs	r1, #20
  202736:	6843      	ldr	r3, [r0, #4]
  202738:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
  20273c:	4798      	blx	r3
}
  20273e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  202742:	f7ff bf8d 	b.w	202660 <_port_irq_epilogue>
  202746:	bf00      	nop
  202748:	40013c00 	.word	0x40013c00
  20274c:	20000800 	.word	0x20000800

00202750 <Vector138>:
  pr = EXTI->PR;
  202750:	4a09      	ldr	r2, [pc, #36]	; (202778 <Vector138+0x28>)
OSAL_IRQ_HANDLER(Vector138) {
  202752:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  202754:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 19);
  202756:	6811      	ldr	r1, [r2, #0]
  202758:	400b      	ands	r3, r1
  20275a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
  EXTI->PR = pr;
  20275e:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 19))
  202760:	b12b      	cbz	r3, 20276e <Vector138+0x1e>
    EXTD1.config->channels[19].cb(&EXTD1, 19);
  202762:	4806      	ldr	r0, [pc, #24]	; (20277c <Vector138+0x2c>)
  202764:	2113      	movs	r1, #19
  202766:	6843      	ldr	r3, [r0, #4]
  202768:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
  20276c:	4798      	blx	r3
}
  20276e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  202772:	f7ff bf75 	b.w	202660 <_port_irq_epilogue>
  202776:	bf00      	nop
  202778:	40013c00 	.word	0x40013c00
  20277c:	20000800 	.word	0x20000800

00202780 <VectorE8>:
  pr = EXTI->PR;
  202780:	4a09      	ldr	r2, [pc, #36]	; (2027a8 <VectorE8+0x28>)
OSAL_IRQ_HANDLER(VectorE8) {
  202782:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  202784:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 18);
  202786:	6811      	ldr	r1, [r2, #0]
  202788:	400b      	ands	r3, r1
  20278a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
  EXTI->PR = pr;
  20278e:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 18))
  202790:	b12b      	cbz	r3, 20279e <VectorE8+0x1e>
    EXTD1.config->channels[18].cb(&EXTD1, 18);
  202792:	4806      	ldr	r0, [pc, #24]	; (2027ac <VectorE8+0x2c>)
  202794:	2112      	movs	r1, #18
  202796:	6843      	ldr	r3, [r0, #4]
  202798:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
  20279c:	4798      	blx	r3
}
  20279e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  2027a2:	f7ff bf5d 	b.w	202660 <_port_irq_epilogue>
  2027a6:	bf00      	nop
  2027a8:	40013c00 	.word	0x40013c00
  2027ac:	20000800 	.word	0x20000800

002027b0 <VectorE4>:
  pr = EXTI->PR;
  2027b0:	4a09      	ldr	r2, [pc, #36]	; (2027d8 <VectorE4+0x28>)
OSAL_IRQ_HANDLER(VectorE4) {
  2027b2:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  2027b4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 17);
  2027b6:	6811      	ldr	r1, [r2, #0]
  2027b8:	400b      	ands	r3, r1
  2027ba:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  EXTI->PR = pr;
  2027be:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 17))
  2027c0:	b12b      	cbz	r3, 2027ce <VectorE4+0x1e>
    EXTD1.config->channels[17].cb(&EXTD1, 17);
  2027c2:	4806      	ldr	r0, [pc, #24]	; (2027dc <VectorE4+0x2c>)
  2027c4:	2111      	movs	r1, #17
  2027c6:	6843      	ldr	r3, [r0, #4]
  2027c8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  2027cc:	4798      	blx	r3
}
  2027ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  2027d2:	f7ff bf45 	b.w	202660 <_port_irq_epilogue>
  2027d6:	bf00      	nop
  2027d8:	40013c00 	.word	0x40013c00
  2027dc:	20000800 	.word	0x20000800

002027e0 <Vector44>:
  pr = EXTI->PR;
  2027e0:	4a09      	ldr	r2, [pc, #36]	; (202808 <Vector44+0x28>)
OSAL_IRQ_HANDLER(Vector44) {
  2027e2:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  2027e4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 16);
  2027e6:	6811      	ldr	r1, [r2, #0]
  2027e8:	400b      	ands	r3, r1
  2027ea:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  EXTI->PR = pr;
  2027ee:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 16))
  2027f0:	b12b      	cbz	r3, 2027fe <Vector44+0x1e>
    EXTD1.config->channels[16].cb(&EXTD1, 16);
  2027f2:	4806      	ldr	r0, [pc, #24]	; (20280c <Vector44+0x2c>)
  2027f4:	2110      	movs	r1, #16
  2027f6:	6843      	ldr	r3, [r0, #4]
  2027f8:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  2027fc:	4798      	blx	r3
}
  2027fe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  202802:	f7ff bf2d 	b.w	202660 <_port_irq_epilogue>
  202806:	bf00      	nop
  202808:	40013c00 	.word	0x40013c00
  20280c:	20000800 	.word	0x20000800

00202810 <VectorE0>:
  pr = EXTI->PR;
  202810:	4b1d      	ldr	r3, [pc, #116]	; (202888 <VectorE0+0x78>)
OSAL_IRQ_HANDLER(VectorE0) {
  202812:	b510      	push	{r4, lr}
  pr = EXTI->PR;
  202814:	695c      	ldr	r4, [r3, #20]
  pr &= EXTI->IMR & ((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
  202816:	681a      	ldr	r2, [r3, #0]
  202818:	4014      	ands	r4, r2
  20281a:	f404 427c 	and.w	r2, r4, #64512	; 0xfc00
  EXTI->PR = pr;
  20281e:	615a      	str	r2, [r3, #20]
  if (pr & (1U << 10))
  202820:	0562      	lsls	r2, r4, #21
  202822:	d42a      	bmi.n	20287a <VectorE0+0x6a>
  if (pr & (1U << 11))
  202824:	0523      	lsls	r3, r4, #20
  202826:	d422      	bmi.n	20286e <VectorE0+0x5e>
  if (pr & (1U << 12))
  202828:	04e0      	lsls	r0, r4, #19
  20282a:	d41a      	bmi.n	202862 <VectorE0+0x52>
  if (pr & (1U << 13))
  20282c:	04a1      	lsls	r1, r4, #18
  20282e:	d412      	bmi.n	202856 <VectorE0+0x46>
  if (pr & (1U << 14))
  202830:	0462      	lsls	r2, r4, #17
  202832:	d40a      	bmi.n	20284a <VectorE0+0x3a>
  if (pr & (1U << 15))
  202834:	0423      	lsls	r3, r4, #16
  202836:	d504      	bpl.n	202842 <VectorE0+0x32>
    EXTD1.config->channels[15].cb(&EXTD1, 15);
  202838:	4814      	ldr	r0, [pc, #80]	; (20288c <VectorE0+0x7c>)
  20283a:	210f      	movs	r1, #15
  20283c:	6843      	ldr	r3, [r0, #4]
  20283e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  202840:	4798      	blx	r3
}
  202842:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  202846:	f7ff bf0b 	b.w	202660 <_port_irq_epilogue>
    EXTD1.config->channels[14].cb(&EXTD1, 14);
  20284a:	4810      	ldr	r0, [pc, #64]	; (20288c <VectorE0+0x7c>)
  20284c:	210e      	movs	r1, #14
  20284e:	6843      	ldr	r3, [r0, #4]
  202850:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  202852:	4798      	blx	r3
  202854:	e7ee      	b.n	202834 <VectorE0+0x24>
    EXTD1.config->channels[13].cb(&EXTD1, 13);
  202856:	480d      	ldr	r0, [pc, #52]	; (20288c <VectorE0+0x7c>)
  202858:	210d      	movs	r1, #13
  20285a:	6843      	ldr	r3, [r0, #4]
  20285c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  20285e:	4798      	blx	r3
  202860:	e7e6      	b.n	202830 <VectorE0+0x20>
    EXTD1.config->channels[12].cb(&EXTD1, 12);
  202862:	480a      	ldr	r0, [pc, #40]	; (20288c <VectorE0+0x7c>)
  202864:	210c      	movs	r1, #12
  202866:	6843      	ldr	r3, [r0, #4]
  202868:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  20286a:	4798      	blx	r3
  20286c:	e7de      	b.n	20282c <VectorE0+0x1c>
    EXTD1.config->channels[11].cb(&EXTD1, 11);
  20286e:	4807      	ldr	r0, [pc, #28]	; (20288c <VectorE0+0x7c>)
  202870:	210b      	movs	r1, #11
  202872:	6843      	ldr	r3, [r0, #4]
  202874:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  202876:	4798      	blx	r3
  202878:	e7d6      	b.n	202828 <VectorE0+0x18>
    EXTD1.config->channels[10].cb(&EXTD1, 10);
  20287a:	4804      	ldr	r0, [pc, #16]	; (20288c <VectorE0+0x7c>)
  20287c:	210a      	movs	r1, #10
  20287e:	6843      	ldr	r3, [r0, #4]
  202880:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  202882:	4798      	blx	r3
  202884:	e7ce      	b.n	202824 <VectorE0+0x14>
  202886:	bf00      	nop
  202888:	40013c00 	.word	0x40013c00
  20288c:	20000800 	.word	0x20000800

00202890 <Vector9C>:
  pr = EXTI->PR;
  202890:	4b19      	ldr	r3, [pc, #100]	; (2028f8 <Vector9C+0x68>)
OSAL_IRQ_HANDLER(Vector9C) {
  202892:	b510      	push	{r4, lr}
  pr = EXTI->PR;
  202894:	695c      	ldr	r4, [r3, #20]
  pr &= EXTI->IMR & ((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
  202896:	681a      	ldr	r2, [r3, #0]
  202898:	4014      	ands	r4, r2
  20289a:	f404 7278 	and.w	r2, r4, #992	; 0x3e0
  EXTI->PR = pr;
  20289e:	615a      	str	r2, [r3, #20]
  if (pr & (1U << 5))
  2028a0:	06a3      	lsls	r3, r4, #26
  2028a2:	d422      	bmi.n	2028ea <Vector9C+0x5a>
  if (pr & (1U << 6))
  2028a4:	0660      	lsls	r0, r4, #25
  2028a6:	d41a      	bmi.n	2028de <Vector9C+0x4e>
  if (pr & (1U << 7))
  2028a8:	0621      	lsls	r1, r4, #24
  2028aa:	d412      	bmi.n	2028d2 <Vector9C+0x42>
  if (pr & (1U << 8))
  2028ac:	05e2      	lsls	r2, r4, #23
  2028ae:	d40a      	bmi.n	2028c6 <Vector9C+0x36>
  if (pr & (1U << 9))
  2028b0:	05a3      	lsls	r3, r4, #22
  2028b2:	d504      	bpl.n	2028be <Vector9C+0x2e>
    EXTD1.config->channels[9].cb(&EXTD1, 9);
  2028b4:	4811      	ldr	r0, [pc, #68]	; (2028fc <Vector9C+0x6c>)
  2028b6:	2109      	movs	r1, #9
  2028b8:	6843      	ldr	r3, [r0, #4]
  2028ba:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  2028bc:	4798      	blx	r3
}
  2028be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  2028c2:	f7ff becd 	b.w	202660 <_port_irq_epilogue>
    EXTD1.config->channels[8].cb(&EXTD1, 8);
  2028c6:	480d      	ldr	r0, [pc, #52]	; (2028fc <Vector9C+0x6c>)
  2028c8:	2108      	movs	r1, #8
  2028ca:	6843      	ldr	r3, [r0, #4]
  2028cc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  2028ce:	4798      	blx	r3
  2028d0:	e7ee      	b.n	2028b0 <Vector9C+0x20>
    EXTD1.config->channels[7].cb(&EXTD1, 7);
  2028d2:	480a      	ldr	r0, [pc, #40]	; (2028fc <Vector9C+0x6c>)
  2028d4:	2107      	movs	r1, #7
  2028d6:	6843      	ldr	r3, [r0, #4]
  2028d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  2028da:	4798      	blx	r3
  2028dc:	e7e6      	b.n	2028ac <Vector9C+0x1c>
    EXTD1.config->channels[6].cb(&EXTD1, 6);
  2028de:	4807      	ldr	r0, [pc, #28]	; (2028fc <Vector9C+0x6c>)
  2028e0:	2106      	movs	r1, #6
  2028e2:	6843      	ldr	r3, [r0, #4]
  2028e4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  2028e6:	4798      	blx	r3
  2028e8:	e7de      	b.n	2028a8 <Vector9C+0x18>
    EXTD1.config->channels[5].cb(&EXTD1, 5);
  2028ea:	4804      	ldr	r0, [pc, #16]	; (2028fc <Vector9C+0x6c>)
  2028ec:	2105      	movs	r1, #5
  2028ee:	6843      	ldr	r3, [r0, #4]
  2028f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  2028f2:	4798      	blx	r3
  2028f4:	e7d6      	b.n	2028a4 <Vector9C+0x14>
  2028f6:	bf00      	nop
  2028f8:	40013c00 	.word	0x40013c00
  2028fc:	20000800 	.word	0x20000800

00202900 <Vector68>:
  pr = EXTI->PR;
  202900:	4a08      	ldr	r2, [pc, #32]	; (202924 <Vector68+0x24>)
OSAL_IRQ_HANDLER(Vector68) {
  202902:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  202904:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 4);
  202906:	6811      	ldr	r1, [r2, #0]
  202908:	400b      	ands	r3, r1
  20290a:	f003 0310 	and.w	r3, r3, #16
  EXTI->PR = pr;
  20290e:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 4))
  202910:	b123      	cbz	r3, 20291c <Vector68+0x1c>
    EXTD1.config->channels[4].cb(&EXTD1, 4);
  202912:	4805      	ldr	r0, [pc, #20]	; (202928 <Vector68+0x28>)
  202914:	2104      	movs	r1, #4
  202916:	6843      	ldr	r3, [r0, #4]
  202918:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  20291a:	4798      	blx	r3
}
  20291c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  202920:	f7ff be9e 	b.w	202660 <_port_irq_epilogue>
  202924:	40013c00 	.word	0x40013c00
  202928:	20000800 	.word	0x20000800
  20292c:	00000000 	.word	0x00000000

00202930 <Vector64>:
  pr = EXTI->PR;
  202930:	4a08      	ldr	r2, [pc, #32]	; (202954 <Vector64+0x24>)
OSAL_IRQ_HANDLER(Vector64) {
  202932:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  202934:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 3);
  202936:	6811      	ldr	r1, [r2, #0]
  202938:	400b      	ands	r3, r1
  20293a:	f003 0308 	and.w	r3, r3, #8
  EXTI->PR = pr;
  20293e:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 3))
  202940:	b123      	cbz	r3, 20294c <Vector64+0x1c>
    EXTD1.config->channels[3].cb(&EXTD1, 3);
  202942:	4805      	ldr	r0, [pc, #20]	; (202958 <Vector64+0x28>)
  202944:	2103      	movs	r1, #3
  202946:	6843      	ldr	r3, [r0, #4]
  202948:	69db      	ldr	r3, [r3, #28]
  20294a:	4798      	blx	r3
}
  20294c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  202950:	f7ff be86 	b.w	202660 <_port_irq_epilogue>
  202954:	40013c00 	.word	0x40013c00
  202958:	20000800 	.word	0x20000800
  20295c:	00000000 	.word	0x00000000

00202960 <Vector60>:
  pr = EXTI->PR;
  202960:	4a08      	ldr	r2, [pc, #32]	; (202984 <Vector60+0x24>)
OSAL_IRQ_HANDLER(Vector60) {
  202962:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  202964:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 2);
  202966:	6811      	ldr	r1, [r2, #0]
  202968:	400b      	ands	r3, r1
  20296a:	f003 0304 	and.w	r3, r3, #4
  EXTI->PR = pr;
  20296e:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 2))
  202970:	b123      	cbz	r3, 20297c <Vector60+0x1c>
    EXTD1.config->channels[2].cb(&EXTD1, 2);
  202972:	4805      	ldr	r0, [pc, #20]	; (202988 <Vector60+0x28>)
  202974:	2102      	movs	r1, #2
  202976:	6843      	ldr	r3, [r0, #4]
  202978:	695b      	ldr	r3, [r3, #20]
  20297a:	4798      	blx	r3
}
  20297c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  202980:	f7ff be6e 	b.w	202660 <_port_irq_epilogue>
  202984:	40013c00 	.word	0x40013c00
  202988:	20000800 	.word	0x20000800
  20298c:	00000000 	.word	0x00000000

00202990 <Vector5C>:
  pr = EXTI->PR;
  202990:	4a08      	ldr	r2, [pc, #32]	; (2029b4 <Vector5C+0x24>)
OSAL_IRQ_HANDLER(Vector5C) {
  202992:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  202994:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 1);
  202996:	6811      	ldr	r1, [r2, #0]
  202998:	400b      	ands	r3, r1
  20299a:	f003 0302 	and.w	r3, r3, #2
  EXTI->PR = pr;
  20299e:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 1))
  2029a0:	b123      	cbz	r3, 2029ac <Vector5C+0x1c>
    EXTD1.config->channels[1].cb(&EXTD1, 1);
  2029a2:	4805      	ldr	r0, [pc, #20]	; (2029b8 <Vector5C+0x28>)
  2029a4:	2101      	movs	r1, #1
  2029a6:	6843      	ldr	r3, [r0, #4]
  2029a8:	68db      	ldr	r3, [r3, #12]
  2029aa:	4798      	blx	r3
}
  2029ac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  2029b0:	f7ff be56 	b.w	202660 <_port_irq_epilogue>
  2029b4:	40013c00 	.word	0x40013c00
  2029b8:	20000800 	.word	0x20000800
  2029bc:	00000000 	.word	0x00000000

002029c0 <Vector58>:
  pr = EXTI->PR;
  2029c0:	4a08      	ldr	r2, [pc, #32]	; (2029e4 <Vector58+0x24>)
OSAL_IRQ_HANDLER(Vector58) {
  2029c2:	b508      	push	{r3, lr}
  pr = EXTI->PR;
  2029c4:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 0);
  2029c6:	6811      	ldr	r1, [r2, #0]
  2029c8:	400b      	ands	r3, r1
  2029ca:	f003 0301 	and.w	r3, r3, #1
  EXTI->PR = pr;
  2029ce:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 0))
  2029d0:	b123      	cbz	r3, 2029dc <Vector58+0x1c>
    EXTD1.config->channels[0].cb(&EXTD1, 0);
  2029d2:	4805      	ldr	r0, [pc, #20]	; (2029e8 <Vector58+0x28>)
  2029d4:	2100      	movs	r1, #0
  2029d6:	6843      	ldr	r3, [r0, #4]
  2029d8:	685b      	ldr	r3, [r3, #4]
  2029da:	4798      	blx	r3
}
  2029dc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  2029e0:	f7ff be3e 	b.w	202660 <_port_irq_epilogue>
  2029e4:	40013c00 	.word	0x40013c00
  2029e8:	20000800 	.word	0x20000800
  2029ec:	00000000 	.word	0x00000000

002029f0 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
  2029f0:	4b0e      	ldr	r3, [pc, #56]	; (202a2c <chTMStopMeasurementX+0x3c>)
  tmp->last = (now - tmp->last) - offset;
  2029f2:	6882      	ldr	r2, [r0, #8]
  2029f4:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
  2029f6:	490e      	ldr	r1, [pc, #56]	; (202a30 <chTMStopMeasurementX+0x40>)
  tmp->last = (now - tmp->last) - offset;
  2029f8:	1a9b      	subs	r3, r3, r2
  if (tmp->last > tmp->worst) {
  2029fa:	6842      	ldr	r2, [r0, #4]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
  2029fc:	b430      	push	{r4, r5}
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
  2029fe:	6f0c      	ldr	r4, [r1, #112]	; 0x70
  tmp->n++;
  202a00:	68c1      	ldr	r1, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  202a02:	1b1b      	subs	r3, r3, r4
  tmp->n++;
  202a04:	3101      	adds	r1, #1
  tmp->last = (now - tmp->last) - offset;
  202a06:	6083      	str	r3, [r0, #8]
  tmp->n++;
  202a08:	60c1      	str	r1, [r0, #12]
  tmp->cumulative += (rttime_t)tmp->last;
  202a0a:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  202a0e:	18e4      	adds	r4, r4, r3
  202a10:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
  202a14:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
  202a16:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
  202a18:	bf88      	it	hi
  202a1a:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
  202a1c:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
  202a1e:	e9c0 4504 	strd	r4, r5, [r0, #16]
    tmp->best = tmp->last;
  202a22:	bf38      	it	cc
  202a24:	6003      	strcc	r3, [r0, #0]
}
  202a26:	bc30      	pop	{r4, r5}
  202a28:	4770      	bx	lr
  202a2a:	bf00      	nop
  202a2c:	e0001000 	.word	0xe0001000
  202a30:	20000d78 	.word	0x20000d78
	...

00202a40 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
  202a40:	4a0e      	ldr	r2, [pc, #56]	; (202a7c <chSchDoReschedule+0x3c>)

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
  202a42:	2101      	movs	r1, #1
  thread_t *tp = tqp->next;
  202a44:	6810      	ldr	r0, [r2, #0]
void chSchDoReschedule(void) {
  202a46:	b430      	push	{r4, r5}
  tqp->next             = tp->queue.next;
  202a48:	6803      	ldr	r3, [r0, #0]
  tp->state = CH_STATE_READY;
  202a4a:	2500      	movs	r5, #0
  thread_t *otp = currp;
  202a4c:	6994      	ldr	r4, [r2, #24]
  202a4e:	6013      	str	r3, [r2, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  202a50:	605a      	str	r2, [r3, #4]
  currp->state = CH_STATE_CURRENT;
  202a52:	f880 1020 	strb.w	r1, [r0, #32]
  tp->state = CH_STATE_READY;
  202a56:	f884 5020 	strb.w	r5, [r4, #32]

  /* Handling idle-leave hook.*/
  if (otp->prio == IDLEPRIO) {
  202a5a:	68a1      	ldr	r1, [r4, #8]
  currp = queue_fifo_remove(&ch.rlist.queue);
  202a5c:	6190      	str	r0, [r2, #24]
  202a5e:	e000      	b.n	202a62 <chSchDoReschedule+0x22>
  202a60:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
  202a62:	689a      	ldr	r2, [r3, #8]
  202a64:	4291      	cmp	r1, r2
  202a66:	d3fb      	bcc.n	202a60 <chSchDoReschedule+0x20>
  tp->queue.prev             = cp->queue.prev;
  202a68:	685a      	ldr	r2, [r3, #4]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
  202a6a:	4621      	mov	r1, r4
  tp->queue.next             = cp;
  202a6c:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  202a6e:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  202a70:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
  202a72:	605c      	str	r4, [r3, #4]
}
  202a74:	bc30      	pop	{r4, r5}
  chSysSwitch(currp, otp);
  202a76:	f7fd bc2d 	b.w	2002d4 <_port_switch>
  202a7a:	bf00      	nop
  202a7c:	20000d78 	.word	0x20000d78

00202a80 <chSchGoSleepTimeoutS>:
  if (TIME_INFINITE != time) {
  202a80:	f64f 73ff 	movw	r3, #65535	; 0xffff
  202a84:	4299      	cmp	r1, r3
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
  202a86:	b5f0      	push	{r4, r5, r6, r7, lr}
  202a88:	b087      	sub	sp, #28
  if (TIME_INFINITE != time) {
  202a8a:	d031      	beq.n	202af0 <chSchGoSleepTimeoutS+0x70>
    chVTDoSetI(&vt, time, wakeup, currp);
  202a8c:	4c1c      	ldr	r4, [pc, #112]	; (202b00 <chSchGoSleepTimeoutS+0x80>)
  202a8e:	4607      	mov	r7, r0

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
  202a90:	481c      	ldr	r0, [pc, #112]	; (202b04 <chSchGoSleepTimeoutS+0x84>)
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;

  /* Pointer to the first element in the delta list.*/
  p = ch.vtlist.next;
  202a92:	69e3      	ldr	r3, [r4, #28]
  vtp->par = par;
  202a94:	69a5      	ldr	r5, [r4, #24]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
  202a96:	891a      	ldrh	r2, [r3, #8]
  vtp->par = par;
  202a98:	9505      	str	r5, [sp, #20]
  while (p->delta < delta) {
  202a9a:	4291      	cmp	r1, r2
  vtp->func = vtfunc;
  202a9c:	9004      	str	r0, [sp, #16]
  while (p->delta < delta) {
  202a9e:	d905      	bls.n	202aac <chSchGoSleepTimeoutS+0x2c>
    delta -= p->delta;
  202aa0:	1a89      	subs	r1, r1, r2
    p = p->next;
  202aa2:	681b      	ldr	r3, [r3, #0]
    delta -= p->delta;
  202aa4:	b289      	uxth	r1, r1
  while (p->delta < delta) {
  202aa6:	891a      	ldrh	r2, [r3, #8]
  202aa8:	428a      	cmp	r2, r1
  202aaa:	d3f9      	bcc.n	202aa0 <chSchGoSleepTimeoutS+0x20>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
  202aac:	685d      	ldr	r5, [r3, #4]
  vtp->prev->next = vtp;
  202aae:	aa01      	add	r2, sp, #4
  vtp->next = p;
  202ab0:	9301      	str	r3, [sp, #4]
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
  ch.vtlist.delta = (systime_t)-1;
  202ab2:	f64f 76ff 	movw	r6, #65535	; 0xffff
  vtp->prev = vtp->next->prev;
  202ab6:	9502      	str	r5, [sp, #8]
    chSchGoSleepS(newstate);
  202ab8:	4638      	mov	r0, r7
  vtp->prev->next = vtp;
  202aba:	602a      	str	r2, [r5, #0]
  p->prev = vtp;
  202abc:	605a      	str	r2, [r3, #4]
  vtp->delta = delta
  202abe:	f8ad 100c 	strh.w	r1, [sp, #12]
  p->delta -= delta;
  202ac2:	891a      	ldrh	r2, [r3, #8]
  202ac4:	1a51      	subs	r1, r2, r1
  202ac6:	8119      	strh	r1, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
  202ac8:	84a6      	strh	r6, [r4, #36]	; 0x24
  202aca:	f7ff fd91 	bl	2025f0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
  202ace:	9b04      	ldr	r3, [sp, #16]
  202ad0:	b153      	cbz	r3, 202ae8 <chSchGoSleepTimeoutS+0x68>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->next->delta += vtp->delta;
  202ad2:	9b01      	ldr	r3, [sp, #4]
  202ad4:	f8bd 000c 	ldrh.w	r0, [sp, #12]
  202ad8:	891a      	ldrh	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->prev->next = vtp->next;
  202ada:	9902      	ldr	r1, [sp, #8]
  vtp->next->delta += vtp->delta;
  202adc:	4402      	add	r2, r0
  202ade:	811a      	strh	r2, [r3, #8]
  vtp->prev->next = vtp->next;
  202ae0:	600b      	str	r3, [r1, #0]
  vtp->next->prev = vtp->prev;
  202ae2:	9b01      	ldr	r3, [sp, #4]
  202ae4:	6059      	str	r1, [r3, #4]
  vtp->func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.delta = (systime_t)-1;
  202ae6:	84a6      	strh	r6, [r4, #36]	; 0x24
  return currp->u.rdymsg;
  202ae8:	69a3      	ldr	r3, [r4, #24]
}
  202aea:	6a58      	ldr	r0, [r3, #36]	; 0x24
  202aec:	b007      	add	sp, #28
  202aee:	bdf0      	pop	{r4, r5, r6, r7, pc}
  202af0:	4c03      	ldr	r4, [pc, #12]	; (202b00 <chSchGoSleepTimeoutS+0x80>)
    chSchGoSleepS(newstate);
  202af2:	f7ff fd7d 	bl	2025f0 <chSchGoSleepS>
  return currp->u.rdymsg;
  202af6:	69a3      	ldr	r3, [r4, #24]
}
  202af8:	6a58      	ldr	r0, [r3, #36]	; 0x24
  202afa:	b007      	add	sp, #28
  202afc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  202afe:	bf00      	nop
  202b00:	20000d78 	.word	0x20000d78
  202b04:	00202571 	.word	0x00202571
	...

00202b10 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
  202b10:	b161      	cbz	r1, 202b2c <chThdEnqueueTimeoutS+0x1c>
  202b12:	4602      	mov	r2, r0
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
  202b14:	4b07      	ldr	r3, [pc, #28]	; (202b34 <chThdEnqueueTimeoutS+0x24>)

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  202b16:	2004      	movs	r0, #4
  queue_insert(currp, tqp);
  202b18:	699b      	ldr	r3, [r3, #24]
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
  202b1a:	b410      	push	{r4}
  tp->queue.prev             = tqp->prev;
  202b1c:	6854      	ldr	r4, [r2, #4]
  202b1e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->queue.prev->queue.next = tp;
  202b22:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
  202b24:	6053      	str	r3, [r2, #4]
}
  202b26:	bc10      	pop	{r4}
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  202b28:	f7ff bfaa 	b.w	202a80 <chSchGoSleepTimeoutS>
}
  202b2c:	f04f 30ff 	mov.w	r0, #4294967295
  202b30:	4770      	bx	lr
  202b32:	bf00      	nop
  202b34:	20000d78 	.word	0x20000d78
	...

00202b40 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
  202b40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  202b44:	4699      	mov	r9, r3
  202b46:	b083      	sub	sp, #12
  202b48:	4604      	mov	r4, r0
  202b4a:	460e      	mov	r6, r1
  202b4c:	4615      	mov	r5, r2
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  202b4e:	f8d0 801c 	ldr.w	r8, [r0, #28]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
  202b52:	2320      	movs	r3, #32
  202b54:	f383 8811 	msr	BASEPRI, r3
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.systime;
  202b58:	4b26      	ldr	r3, [pc, #152]	; (202bf4 <oqWriteTimeout+0xb4>)
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  202b5a:	f109 3aff 	add.w	sl, r9, #4294967295
  size_t w = 0;
  202b5e:	2700      	movs	r7, #0
  202b60:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  202b62:	fa1f fa8a 	uxth.w	sl, sl
  deadline = osalOsGetSystemTimeX() + timeout;
  202b66:	fa19 f383 	uxtah	r3, r9, r3
  202b6a:	b29b      	uxth	r3, r3
  202b6c:	9301      	str	r3, [sp, #4]
    while (oqIsFullI(oqp)) {
  202b6e:	68a3      	ldr	r3, [r4, #8]
  202b70:	b313      	cbz	r3, 202bb8 <oqWriteTimeout+0x78>
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
  202b72:	6961      	ldr	r1, [r4, #20]
  202b74:	f106 0b01 	add.w	fp, r6, #1
    oqp->q_counter--;
  202b78:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
  202b7a:	1c48      	adds	r0, r1, #1
    oqp->q_counter--;
  202b7c:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
  202b7e:	6160      	str	r0, [r4, #20]
    oqp->q_counter--;
  202b80:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
  202b82:	7833      	ldrb	r3, [r6, #0]
  202b84:	700b      	strb	r3, [r1, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
  202b86:	6961      	ldr	r1, [r4, #20]
  202b88:	6923      	ldr	r3, [r4, #16]
  202b8a:	4299      	cmp	r1, r3
  202b8c:	d301      	bcc.n	202b92 <oqWriteTimeout+0x52>
      oqp->q_wrptr = oqp->q_buffer;
  202b8e:	68e3      	ldr	r3, [r4, #12]
  202b90:	6163      	str	r3, [r4, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
  202b92:	f1b8 0f00 	cmp.w	r8, #0
  202b96:	d001      	beq.n	202b9c <oqWriteTimeout+0x5c>
      nfy(oqp);
  202b98:	4620      	mov	r0, r4
  202b9a:	47c0      	blx	r8
  202b9c:	2300      	movs	r3, #0
  202b9e:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    if (--n == 0U) {
  202ba2:	3d01      	subs	r5, #1
    w++;
  202ba4:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
  202ba8:	d019      	beq.n	202bde <oqWriteTimeout+0x9e>
  202baa:	2320      	movs	r3, #32
  202bac:	f383 8811 	msr	BASEPRI, r3
    while (oqIsFullI(oqp)) {
  202bb0:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
  202bb2:	465e      	mov	r6, fp
    while (oqIsFullI(oqp)) {
  202bb4:	2b00      	cmp	r3, #0
  202bb6:	d1dc      	bne.n	202b72 <oqWriteTimeout+0x32>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  202bb8:	f64f 72fd 	movw	r2, #65533	; 0xfffd
  202bbc:	4592      	cmp	sl, r2
  202bbe:	d812      	bhi.n	202be6 <oqWriteTimeout+0xa6>
  202bc0:	4a0c      	ldr	r2, [pc, #48]	; (202bf4 <oqWriteTimeout+0xb4>)
  202bc2:	8cd1      	ldrh	r1, [r2, #38]	; 0x26
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
  202bc4:	9a01      	ldr	r2, [sp, #4]
  202bc6:	1a51      	subs	r1, r2, r1
  202bc8:	b289      	uxth	r1, r1
        if (next_timeout > timeout) {
  202bca:	4589      	cmp	r9, r1
  202bcc:	d305      	bcc.n	202bda <oqWriteTimeout+0x9a>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
  202bce:	4620      	mov	r0, r4
  202bd0:	f7ff ff9e 	bl	202b10 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
  202bd4:	2800      	cmp	r0, #0
  202bd6:	d0ca      	beq.n	202b6e <oqWriteTimeout+0x2e>
  202bd8:	2300      	movs	r3, #0
  202bda:	f383 8811 	msr	BASEPRI, r3
      return w;
    }

    osalSysLock();
  }
}
  202bde:	4638      	mov	r0, r7
  202be0:	b003      	add	sp, #12
  202be2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  202be6:	4649      	mov	r1, r9
  202be8:	4620      	mov	r0, r4
  202bea:	f7ff ff91 	bl	202b10 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
  202bee:	2800      	cmp	r0, #0
  202bf0:	d0bd      	beq.n	202b6e <oqWriteTimeout+0x2e>
  202bf2:	e7f1      	b.n	202bd8 <oqWriteTimeout+0x98>
  202bf4:	20000d78 	.word	0x20000d78
	...

00202c00 <_writet.lto_priv.56>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
  202c00:	3030      	adds	r0, #48	; 0x30
  202c02:	f7ff bf9d 	b.w	202b40 <oqWriteTimeout>
  202c06:	bf00      	nop
	...

00202c10 <_write.lto_priv.50>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
  202c10:	3030      	adds	r0, #48	; 0x30
  202c12:	f64f 73ff 	movw	r3, #65535	; 0xffff
  202c16:	f7ff bf93 	b.w	202b40 <oqWriteTimeout>
  202c1a:	bf00      	nop
  202c1c:	0000      	movs	r0, r0
	...

00202c20 <oqPutTimeout>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
  202c20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  202c22:	4604      	mov	r4, r0
  202c24:	460f      	mov	r7, r1
  202c26:	4616      	mov	r6, r2
  202c28:	2320      	movs	r3, #32
  202c2a:	f383 8811 	msr	BASEPRI, r3
  202c2e:	e003      	b.n	202c38 <oqPutTimeout+0x18>
  202c30:	f7ff ff6e 	bl	202b10 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
  202c34:	2800      	cmp	r0, #0
  202c36:	db19      	blt.n	202c6c <oqPutTimeout+0x4c>
  while (oqIsFullI(oqp)) {
  202c38:	68a5      	ldr	r5, [r4, #8]
  202c3a:	4631      	mov	r1, r6
  202c3c:	4620      	mov	r0, r4
  202c3e:	2d00      	cmp	r5, #0
  202c40:	d0f6      	beq.n	202c30 <oqPutTimeout+0x10>
  *oqp->q_wrptr++ = b;
  202c42:	6962      	ldr	r2, [r4, #20]
  oqp->q_counter--;
  202c44:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
  202c46:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
  202c48:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
  202c4a:	6161      	str	r1, [r4, #20]
  oqp->q_counter--;
  202c4c:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
  202c4e:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
  202c50:	6962      	ldr	r2, [r4, #20]
  202c52:	6923      	ldr	r3, [r4, #16]
  202c54:	429a      	cmp	r2, r3
  202c56:	d301      	bcc.n	202c5c <oqPutTimeout+0x3c>
    oqp->q_wrptr = oqp->q_buffer;
  202c58:	68e3      	ldr	r3, [r4, #12]
  202c5a:	6163      	str	r3, [r4, #20]
  if (oqp->q_notify != NULL) {
  202c5c:	69e3      	ldr	r3, [r4, #28]
  202c5e:	b10b      	cbz	r3, 202c64 <oqPutTimeout+0x44>
    oqp->q_notify(oqp);
  202c60:	4620      	mov	r0, r4
  202c62:	4798      	blx	r3
  202c64:	2000      	movs	r0, #0
  202c66:	f380 8811 	msr	BASEPRI, r0
}
  202c6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  202c6c:	f385 8811 	msr	BASEPRI, r5
  202c70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  202c72:	bf00      	nop
	...

00202c80 <_putt.lto_priv.54>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
  202c80:	3030      	adds	r0, #48	; 0x30
  202c82:	f7ff bfcd 	b.w	202c20 <oqPutTimeout>
  202c86:	bf00      	nop
	...

00202c90 <_put.lto_priv.52>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
  202c90:	3030      	adds	r0, #48	; 0x30
  202c92:	f64f 72ff 	movw	r2, #65535	; 0xffff
  202c96:	f7ff bfc3 	b.w	202c20 <oqPutTimeout>
  202c9a:	bf00      	nop
  202c9c:	0000      	movs	r0, r0
	...

00202ca0 <iqReadTimeout>:
                     size_t n, systime_t timeout) {
  202ca0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  202ca4:	4699      	mov	r9, r3
  202ca6:	b083      	sub	sp, #12
  202ca8:	4604      	mov	r4, r0
  202caa:	460e      	mov	r6, r1
  202cac:	4615      	mov	r5, r2
  qnotify_t nfy = iqp->q_notify;
  202cae:	f8d0 801c 	ldr.w	r8, [r0, #28]
  202cb2:	2320      	movs	r3, #32
  202cb4:	f383 8811 	msr	BASEPRI, r3
  202cb8:	4b26      	ldr	r3, [pc, #152]	; (202d54 <iqReadTimeout+0xb4>)
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  202cba:	f109 3aff 	add.w	sl, r9, #4294967295
  size_t r = 0;
  202cbe:	2700      	movs	r7, #0
  202cc0:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  202cc2:	fa1f fa8a 	uxth.w	sl, sl
  deadline = osalOsGetSystemTimeX() + timeout;
  202cc6:	fa19 f383 	uxtah	r3, r9, r3
  202cca:	b29b      	uxth	r3, r3
  202ccc:	9301      	str	r3, [sp, #4]
    while (iqIsEmptyI(iqp)) {
  202cce:	68a3      	ldr	r3, [r4, #8]
  202cd0:	b313      	cbz	r3, 202d18 <iqReadTimeout+0x78>
    *bp++ = *iqp->q_rdptr++;
  202cd2:	69a1      	ldr	r1, [r4, #24]
  202cd4:	f106 0b01 	add.w	fp, r6, #1
    iqp->q_counter--;
  202cd8:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
  202cda:	1c48      	adds	r0, r1, #1
    iqp->q_counter--;
  202cdc:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
  202cde:	61a0      	str	r0, [r4, #24]
    iqp->q_counter--;
  202ce0:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
  202ce2:	780b      	ldrb	r3, [r1, #0]
  202ce4:	7033      	strb	r3, [r6, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
  202ce6:	69a1      	ldr	r1, [r4, #24]
  202ce8:	6923      	ldr	r3, [r4, #16]
  202cea:	4299      	cmp	r1, r3
  202cec:	d301      	bcc.n	202cf2 <iqReadTimeout+0x52>
      iqp->q_rdptr = iqp->q_buffer;
  202cee:	68e3      	ldr	r3, [r4, #12]
  202cf0:	61a3      	str	r3, [r4, #24]
    if (nfy != NULL) {
  202cf2:	f1b8 0f00 	cmp.w	r8, #0
  202cf6:	d001      	beq.n	202cfc <iqReadTimeout+0x5c>
      nfy(iqp);
  202cf8:	4620      	mov	r0, r4
  202cfa:	47c0      	blx	r8
  202cfc:	2300      	movs	r3, #0
  202cfe:	f383 8811 	msr	BASEPRI, r3
    if (--n == 0U) {
  202d02:	3d01      	subs	r5, #1
    r++;
  202d04:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
  202d08:	d019      	beq.n	202d3e <iqReadTimeout+0x9e>
  202d0a:	2320      	movs	r3, #32
  202d0c:	f383 8811 	msr	BASEPRI, r3
    while (iqIsEmptyI(iqp)) {
  202d10:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
  202d12:	465e      	mov	r6, fp
    while (iqIsEmptyI(iqp)) {
  202d14:	2b00      	cmp	r3, #0
  202d16:	d1dc      	bne.n	202cd2 <iqReadTimeout+0x32>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
  202d18:	f64f 72fd 	movw	r2, #65533	; 0xfffd
  202d1c:	4592      	cmp	sl, r2
  202d1e:	d812      	bhi.n	202d46 <iqReadTimeout+0xa6>
  202d20:	4a0c      	ldr	r2, [pc, #48]	; (202d54 <iqReadTimeout+0xb4>)
  202d22:	8cd1      	ldrh	r1, [r2, #38]	; 0x26
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
  202d24:	9a01      	ldr	r2, [sp, #4]
  202d26:	1a51      	subs	r1, r2, r1
  202d28:	b289      	uxth	r1, r1
        if (next_timeout > timeout) {
  202d2a:	4589      	cmp	r9, r1
  202d2c:	d305      	bcc.n	202d3a <iqReadTimeout+0x9a>
  202d2e:	4620      	mov	r0, r4
  202d30:	f7ff feee 	bl	202b10 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
  202d34:	2800      	cmp	r0, #0
  202d36:	d0ca      	beq.n	202cce <iqReadTimeout+0x2e>
  202d38:	2300      	movs	r3, #0
  202d3a:	f383 8811 	msr	BASEPRI, r3
}
  202d3e:	4638      	mov	r0, r7
  202d40:	b003      	add	sp, #12
  202d42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  202d46:	4649      	mov	r1, r9
  202d48:	4620      	mov	r0, r4
  202d4a:	f7ff fee1 	bl	202b10 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
  202d4e:	2800      	cmp	r0, #0
  202d50:	d0bd      	beq.n	202cce <iqReadTimeout+0x2e>
  202d52:	e7f1      	b.n	202d38 <iqReadTimeout+0x98>
  202d54:	20000d78 	.word	0x20000d78
	...

00202d60 <_readt.lto_priv.57>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
  202d60:	300c      	adds	r0, #12
  202d62:	f7ff bf9d 	b.w	202ca0 <iqReadTimeout>
  202d66:	bf00      	nop
	...

00202d70 <_read.lto_priv.51>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
  202d70:	300c      	adds	r0, #12
  202d72:	f64f 73ff 	movw	r3, #65535	; 0xffff
  202d76:	f7ff bf93 	b.w	202ca0 <iqReadTimeout>
  202d7a:	bf00      	nop
  202d7c:	0000      	movs	r0, r0
	...

00202d80 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
  202d80:	b570      	push	{r4, r5, r6, lr}
  202d82:	2320      	movs	r3, #32
  202d84:	4604      	mov	r4, r0
  202d86:	460e      	mov	r6, r1
  202d88:	f383 8811 	msr	BASEPRI, r3
  202d8c:	e003      	b.n	202d96 <iqGetTimeout+0x16>
  202d8e:	f7ff febf 	bl	202b10 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
  202d92:	2800      	cmp	r0, #0
  202d94:	db19      	blt.n	202dca <iqGetTimeout+0x4a>
  while (iqIsEmptyI(iqp)) {
  202d96:	68a5      	ldr	r5, [r4, #8]
  202d98:	4631      	mov	r1, r6
  202d9a:	4620      	mov	r0, r4
  202d9c:	2d00      	cmp	r5, #0
  202d9e:	d0f6      	beq.n	202d8e <iqGetTimeout+0xe>
  b = *iqp->q_rdptr++;
  202da0:	69a1      	ldr	r1, [r4, #24]
  iqp->q_counter--;
  202da2:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  202da4:	1c4a      	adds	r2, r1, #1
  if (iqp->q_rdptr >= iqp->q_top) {
  202da6:	6920      	ldr	r0, [r4, #16]
  iqp->q_counter--;
  202da8:	3b01      	subs	r3, #1
  if (iqp->q_rdptr >= iqp->q_top) {
  202daa:	4282      	cmp	r2, r0
  b = *iqp->q_rdptr++;
  202dac:	61a2      	str	r2, [r4, #24]
  iqp->q_counter--;
  202dae:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  202db0:	780d      	ldrb	r5, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
  202db2:	d301      	bcc.n	202db8 <iqGetTimeout+0x38>
    iqp->q_rdptr = iqp->q_buffer;
  202db4:	68e3      	ldr	r3, [r4, #12]
  202db6:	61a3      	str	r3, [r4, #24]
  if (iqp->q_notify != NULL) {
  202db8:	69e3      	ldr	r3, [r4, #28]
  202dba:	b10b      	cbz	r3, 202dc0 <iqGetTimeout+0x40>
    iqp->q_notify(iqp);
  202dbc:	4620      	mov	r0, r4
  202dbe:	4798      	blx	r3
  202dc0:	2300      	movs	r3, #0
  202dc2:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
  202dc6:	4628      	mov	r0, r5
}
  202dc8:	bd70      	pop	{r4, r5, r6, pc}
  202dca:	f385 8811 	msr	BASEPRI, r5
  202dce:	bd70      	pop	{r4, r5, r6, pc}

00202dd0 <_gett.lto_priv.55>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
  202dd0:	300c      	adds	r0, #12
  202dd2:	f7ff bfd5 	b.w	202d80 <iqGetTimeout>
  202dd6:	bf00      	nop
	...

00202de0 <_get.lto_priv.53>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
  202de0:	300c      	adds	r0, #12
  202de2:	f64f 71ff 	movw	r1, #65535	; 0xffff
  202de6:	f7ff bfcb 	b.w	202d80 <iqGetTimeout>
  202dea:	bf00      	nop
  202dec:	0000      	movs	r0, r0
	...

00202df0 <chThdSleep>:
void chThdSleep(systime_t time) {
  202df0:	b508      	push	{r3, lr}
  202df2:	4601      	mov	r1, r0
  202df4:	2320      	movs	r3, #32
  202df6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
  202dfa:	2008      	movs	r0, #8
  202dfc:	f7ff fe40 	bl	202a80 <chSchGoSleepTimeoutS>
  202e00:	2300      	movs	r3, #0
  202e02:	f383 8811 	msr	BASEPRI, r3
  202e06:	bd08      	pop	{r3, pc}
	...

00202e10 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
  202e10:	b410      	push	{r4}
  tp->state = CH_STATE_READY;
  202e12:	2200      	movs	r2, #0
thread_t *chSchReadyI(thread_t *tp) {
  202e14:	4604      	mov	r4, r0
  cp = (thread_t *)&ch.rlist.queue;
  202e16:	4b08      	ldr	r3, [pc, #32]	; (202e38 <chSchReadyI+0x28>)
  202e18:	6881      	ldr	r1, [r0, #8]
  tp->state = CH_STATE_READY;
  202e1a:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
  202e1e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
  202e20:	689a      	ldr	r2, [r3, #8]
  202e22:	428a      	cmp	r2, r1
  202e24:	d2fb      	bcs.n	202e1e <chSchReadyI+0xe>
  tp->queue.prev             = cp->queue.prev;
  202e26:	685a      	ldr	r2, [r3, #4]
}
  202e28:	4620      	mov	r0, r4
  tp->queue.next             = cp;
  202e2a:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  202e2c:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  202e2e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
  202e30:	605c      	str	r4, [r3, #4]
}
  202e32:	bc10      	pop	{r4}
  202e34:	4770      	bx	lr
  202e36:	bf00      	nop
  202e38:	20000d78 	.word	0x20000d78
  202e3c:	00000000 	.word	0x00000000

00202e40 <adc_lld_serve_rx_interrupt.lto_priv.37>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
  202e40:	f011 0f0c 	tst.w	r1, #12
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
  202e44:	b570      	push	{r4, r5, r6, lr}
  202e46:	4604      	mov	r4, r0
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
  202e48:	d031      	beq.n	202eae <adc_lld_serve_rx_interrupt.lto_priv.37+0x6e>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
  202e4a:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
  202e4c:	6803      	ldr	r3, [r0, #0]
  202e4e:	681a      	ldr	r2, [r3, #0]
  202e50:	f022 021f 	bic.w	r2, r2, #31
  202e54:	601a      	str	r2, [r3, #0]
  202e56:	6819      	ldr	r1, [r3, #0]
  202e58:	f011 0101 	ands.w	r1, r1, #1
  202e5c:	d1fb      	bne.n	202e56 <adc_lld_serve_rx_interrupt.lto_priv.37+0x16>
  202e5e:	7a03      	ldrb	r3, [r0, #8]
  202e60:	223d      	movs	r2, #61	; 0x3d
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
  202e62:	6925      	ldr	r5, [r4, #16]
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
  202e64:	2601      	movs	r6, #1
  dmaStreamDisable(adcp->dmastp);
  202e66:	6840      	ldr	r0, [r0, #4]
  202e68:	409a      	lsls	r2, r3
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
  202e6a:	68ad      	ldr	r5, [r5, #8]
  adcp->adc->CR1 = 0;
  202e6c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  dmaStreamDisable(adcp->dmastp);
  202e6e:	6002      	str	r2, [r0, #0]
  adcp->adc->CR1 = 0;
  202e70:	6059      	str	r1, [r3, #4]
  adcp->adc->CR2 = 0;
  202e72:	6099      	str	r1, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
  202e74:	609e      	str	r6, [r3, #8]
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
  202e76:	2d00      	cmp	r5, #0
  202e78:	d030      	beq.n	202edc <adc_lld_serve_rx_interrupt.lto_priv.37+0x9c>
  202e7a:	2305      	movs	r3, #5
  202e7c:	4620      	mov	r0, r4
  202e7e:	7023      	strb	r3, [r4, #0]
  202e80:	47a8      	blx	r5
  202e82:	7823      	ldrb	r3, [r4, #0]
  202e84:	2b05      	cmp	r3, #5
  202e86:	d067      	beq.n	202f58 <adc_lld_serve_rx_interrupt.lto_priv.37+0x118>
  202e88:	2300      	movs	r3, #0
  202e8a:	6123      	str	r3, [r4, #16]
  202e8c:	2320      	movs	r3, #32
  202e8e:	f383 8811 	msr	BASEPRI, r3
  if (*trp != NULL) {
  202e92:	6963      	ldr	r3, [r4, #20]
  202e94:	b13b      	cbz	r3, 202ea6 <adc_lld_serve_rx_interrupt.lto_priv.37+0x66>
    *trp = NULL;
  202e96:	2100      	movs	r1, #0
    tp->u.rdymsg = msg;
  202e98:	f04f 32ff 	mov.w	r2, #4294967295
    (void) chSchReadyI(tp);
  202e9c:	4618      	mov	r0, r3
    *trp = NULL;
  202e9e:	6161      	str	r1, [r4, #20]
    tp->u.rdymsg = msg;
  202ea0:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
  202ea2:	f7ff ffb5 	bl	202e10 <chSchReadyI>
  202ea6:	2300      	movs	r3, #0
  202ea8:	f383 8811 	msr	BASEPRI, r3
  202eac:	bd70      	pop	{r4, r5, r6, pc}
    if (adcp->grpp != NULL) {
  202eae:	6905      	ldr	r5, [r0, #16]
  202eb0:	b19d      	cbz	r5, 202eda <adc_lld_serve_rx_interrupt.lto_priv.37+0x9a>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
  202eb2:	068a      	lsls	r2, r1, #26
  202eb4:	d50f      	bpl.n	202ed6 <adc_lld_serve_rx_interrupt.lto_priv.37+0x96>
        _adc_isr_full_code(adcp);
  202eb6:	782b      	ldrb	r3, [r5, #0]
  202eb8:	b1eb      	cbz	r3, 202ef6 <adc_lld_serve_rx_interrupt.lto_priv.37+0xb6>
  202eba:	686b      	ldr	r3, [r5, #4]
  202ebc:	b16b      	cbz	r3, 202eda <adc_lld_serve_rx_interrupt.lto_priv.37+0x9a>
  202ebe:	68c2      	ldr	r2, [r0, #12]
  202ec0:	2a01      	cmp	r2, #1
  202ec2:	d94c      	bls.n	202f5e <adc_lld_serve_rx_interrupt.lto_priv.37+0x11e>
  202ec4:	0852      	lsrs	r2, r2, #1
  202ec6:	886d      	ldrh	r5, [r5, #2]
  202ec8:	6884      	ldr	r4, [r0, #8]
  202eca:	0051      	lsls	r1, r2, #1
  202ecc:	fb05 4101 	mla	r1, r5, r1, r4
}
  202ed0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _adc_isr_full_code(adcp);
  202ed4:	4718      	bx	r3
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
  202ed6:	06cb      	lsls	r3, r1, #27
  202ed8:	d404      	bmi.n	202ee4 <adc_lld_serve_rx_interrupt.lto_priv.37+0xa4>
  202eda:	bd70      	pop	{r4, r5, r6, pc}
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
  202edc:	2302      	movs	r3, #2
  202ede:	6125      	str	r5, [r4, #16]
  202ee0:	7023      	strb	r3, [r4, #0]
  202ee2:	e7d3      	b.n	202e8c <adc_lld_serve_rx_interrupt.lto_priv.37+0x4c>
        _adc_isr_half_code(adcp);
  202ee4:	686b      	ldr	r3, [r5, #4]
  202ee6:	2b00      	cmp	r3, #0
  202ee8:	d0f7      	beq.n	202eda <adc_lld_serve_rx_interrupt.lto_priv.37+0x9a>
  202eea:	68c2      	ldr	r2, [r0, #12]
  202eec:	6881      	ldr	r1, [r0, #8]
  202eee:	0852      	lsrs	r2, r2, #1
}
  202ef0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _adc_isr_half_code(adcp);
  202ef4:	4718      	bx	r3
  dmaStreamDisable(adcp->dmastp);
  202ef6:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
  202ef8:	6802      	ldr	r2, [r0, #0]
  202efa:	6813      	ldr	r3, [r2, #0]
  202efc:	f023 031f 	bic.w	r3, r3, #31
  202f00:	6013      	str	r3, [r2, #0]
  202f02:	6813      	ldr	r3, [r2, #0]
  202f04:	f013 0301 	ands.w	r3, r3, #1
  202f08:	d1fb      	bne.n	202f02 <adc_lld_serve_rx_interrupt.lto_priv.37+0xc2>
  202f0a:	7a02      	ldrb	r2, [r0, #8]
  202f0c:	213d      	movs	r1, #61	; 0x3d
        _adc_isr_full_code(adcp);
  202f0e:	686d      	ldr	r5, [r5, #4]
  adcp->adc->CR2 = ADC_CR2_ADON;
  202f10:	2601      	movs	r6, #1
  dmaStreamDisable(adcp->dmastp);
  202f12:	6840      	ldr	r0, [r0, #4]
  202f14:	4091      	lsls	r1, r2
  adcp->adc->CR1 = 0;
  202f16:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  dmaStreamDisable(adcp->dmastp);
  202f18:	6001      	str	r1, [r0, #0]
  adcp->adc->CR1 = 0;
  202f1a:	6053      	str	r3, [r2, #4]
  adcp->adc->CR2 = 0;
  202f1c:	6093      	str	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
  202f1e:	6096      	str	r6, [r2, #8]
        _adc_isr_full_code(adcp);
  202f20:	b1ad      	cbz	r5, 202f4e <adc_lld_serve_rx_interrupt.lto_priv.37+0x10e>
  202f22:	2304      	movs	r3, #4
  202f24:	68e2      	ldr	r2, [r4, #12]
  202f26:	68a1      	ldr	r1, [r4, #8]
  202f28:	4620      	mov	r0, r4
  202f2a:	7023      	strb	r3, [r4, #0]
  202f2c:	47a8      	blx	r5
  202f2e:	7823      	ldrb	r3, [r4, #0]
  202f30:	2b04      	cmp	r3, #4
  202f32:	d00c      	beq.n	202f4e <adc_lld_serve_rx_interrupt.lto_priv.37+0x10e>
  202f34:	2320      	movs	r3, #32
  202f36:	f383 8811 	msr	BASEPRI, r3
  if (*trp != NULL) {
  202f3a:	6963      	ldr	r3, [r4, #20]
  202f3c:	2b00      	cmp	r3, #0
  202f3e:	d0b2      	beq.n	202ea6 <adc_lld_serve_rx_interrupt.lto_priv.37+0x66>
    *trp = NULL;
  202f40:	2200      	movs	r2, #0
    (void) chSchReadyI(tp);
  202f42:	4618      	mov	r0, r3
    *trp = NULL;
  202f44:	6162      	str	r2, [r4, #20]
    tp->u.rdymsg = msg;
  202f46:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
  202f48:	f7ff ff62 	bl	202e10 <chSchReadyI>
  202f4c:	e7ab      	b.n	202ea6 <adc_lld_serve_rx_interrupt.lto_priv.37+0x66>
  202f4e:	2202      	movs	r2, #2
  202f50:	2300      	movs	r3, #0
  202f52:	7022      	strb	r2, [r4, #0]
  202f54:	6123      	str	r3, [r4, #16]
  202f56:	e7ed      	b.n	202f34 <adc_lld_serve_rx_interrupt.lto_priv.37+0xf4>
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
  202f58:	2302      	movs	r3, #2
  202f5a:	7023      	strb	r3, [r4, #0]
  202f5c:	e794      	b.n	202e88 <adc_lld_serve_rx_interrupt.lto_priv.37+0x48>
        _adc_isr_full_code(adcp);
  202f5e:	6881      	ldr	r1, [r0, #8]
}
  202f60:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        _adc_isr_full_code(adcp);
  202f64:	4718      	bx	r3
  202f66:	bf00      	nop
	...

00202f70 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
  202f70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  202f72:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  202f74:	42a0      	cmp	r0, r4
  202f76:	d022      	beq.n	202fbe <chEvtBroadcastFlagsI+0x4e>
  202f78:	460d      	mov	r5, r1
  202f7a:	4607      	mov	r7, r0
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
  202f7c:	2600      	movs	r6, #0
  202f7e:	e002      	b.n	202f86 <chEvtBroadcastFlagsI+0x16>
    elp = elp->next;
  202f80:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
  202f82:	42a7      	cmp	r7, r4
  202f84:	d01b      	beq.n	202fbe <chEvtBroadcastFlagsI+0x4e>
    elp->flags |= flags;
  202f86:	68e3      	ldr	r3, [r4, #12]
  202f88:	432b      	orrs	r3, r5
  202f8a:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
  202f8c:	b115      	cbz	r5, 202f94 <chEvtBroadcastFlagsI+0x24>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
  202f8e:	6922      	ldr	r2, [r4, #16]
    if ((flags == (eventflags_t)0) ||
  202f90:	4213      	tst	r3, r2
  202f92:	d0f5      	beq.n	202f80 <chEvtBroadcastFlagsI+0x10>
      chEvtSignalI(elp->listener, elp->events);
  202f94:	6860      	ldr	r0, [r4, #4]
  tp->epending |= events;
  202f96:	68a3      	ldr	r3, [r4, #8]
  202f98:	6b41      	ldr	r1, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
  202f9a:	f890 2020 	ldrb.w	r2, [r0, #32]
  tp->epending |= events;
  202f9e:	430b      	orrs	r3, r1
  if (((tp->state == CH_STATE_WTOREVT) &&
  202fa0:	2a0a      	cmp	r2, #10
  tp->epending |= events;
  202fa2:	6343      	str	r3, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
  202fa4:	d00c      	beq.n	202fc0 <chEvtBroadcastFlagsI+0x50>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  202fa6:	2a0b      	cmp	r2, #11
  202fa8:	d1ea      	bne.n	202f80 <chEvtBroadcastFlagsI+0x10>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
  202faa:	6a42      	ldr	r2, [r0, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
  202fac:	ea32 0303 	bics.w	r3, r2, r3
  202fb0:	d1e6      	bne.n	202f80 <chEvtBroadcastFlagsI+0x10>
    tp->u.rdymsg = MSG_OK;
  202fb2:	6246      	str	r6, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
  202fb4:	f7ff ff2c 	bl	202e10 <chSchReadyI>
    elp = elp->next;
  202fb8:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
  202fba:	42a7      	cmp	r7, r4
  202fbc:	d1e3      	bne.n	202f86 <chEvtBroadcastFlagsI+0x16>
  202fbe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  202fc0:	6a42      	ldr	r2, [r0, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
  202fc2:	4213      	tst	r3, r2
  202fc4:	d0dc      	beq.n	202f80 <chEvtBroadcastFlagsI+0x10>
    tp->u.rdymsg = MSG_OK;
  202fc6:	6246      	str	r6, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
  202fc8:	f7ff ff22 	bl	202e10 <chSchReadyI>
  202fcc:	e7f4      	b.n	202fb8 <chEvtBroadcastFlagsI+0x48>
  202fce:	bf00      	nop

00202fd0 <chThdExit>:
void chThdExit(msg_t msg) {
  202fd0:	b538      	push	{r3, r4, r5, lr}
  202fd2:	2220      	movs	r2, #32
  202fd4:	4603      	mov	r3, r0
  202fd6:	f382 8811 	msr	BASEPRI, r2
  thread_t *tp = currp;
  202fda:	4a10      	ldr	r2, [pc, #64]	; (20301c <chThdExit+0x4c>)
  202fdc:	6994      	ldr	r4, [r2, #24]
  while (list_notempty(&tp->waiting)) {
  202fde:	f104 0528 	add.w	r5, r4, #40	; 0x28
  return (bool)(tlp->next != (thread_t *)tlp);
  202fe2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  tp->u.exitcode = msg;
  202fe4:	6263      	str	r3, [r4, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
  202fe6:	4285      	cmp	r5, r0
  202fe8:	d006      	beq.n	202ff8 <chThdExit+0x28>
  tlp->next = tp->queue.next;
  202fea:	6803      	ldr	r3, [r0, #0]
  202fec:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
  202fee:	f7ff ff0f 	bl	202e10 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
  202ff2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
  202ff4:	42a8      	cmp	r0, r5
  202ff6:	d1f8      	bne.n	202fea <chThdExit+0x1a>
  if ((tp->refs == (trefs_t)0) &&
  202ff8:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
  202ffc:	b943      	cbnz	r3, 203010 <chThdExit+0x40>
  202ffe:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
  203002:	079b      	lsls	r3, r3, #30
  203004:	d104      	bne.n	203010 <chThdExit+0x40>
    REG_REMOVE(tp);
  203006:	6922      	ldr	r2, [r4, #16]
  203008:	6963      	ldr	r3, [r4, #20]
  20300a:	611a      	str	r2, [r3, #16]
  20300c:	6922      	ldr	r2, [r4, #16]
  20300e:	6153      	str	r3, [r2, #20]
  chSchGoSleepS(CH_STATE_FINAL);
  203010:	200f      	movs	r0, #15
}
  203012:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
  203016:	f7ff baeb 	b.w	2025f0 <chSchGoSleepS>
  20301a:	bf00      	nop
  20301c:	20000d78 	.word	0x20000d78

00203020 <BusFault_Handler>:
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
__attribute__((weak))
void _unhandled_exception(void) {
  203020:	e7fe      	b.n	203020 <BusFault_Handler>
  203022:	bf00      	nop
	...

00203030 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
  203030:	b5f0      	push	{r4, r5, r6, r7, lr}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
  203032:	4f12      	ldr	r7, [pc, #72]	; (20307c <__init_ram_areas+0x4c>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
  203034:	2600      	movs	r6, #0
void __init_ram_areas(void) {
  203036:	4d12      	ldr	r5, [pc, #72]	; (203080 <__init_ram_areas+0x50>)
  203038:	f107 0e80 	add.w	lr, r7, #128	; 0x80
  20303c:	4c11      	ldr	r4, [pc, #68]	; (203084 <__init_ram_areas+0x54>)
  20303e:	4b12      	ldr	r3, [pc, #72]	; (203088 <__init_ram_areas+0x58>)
  203040:	4912      	ldr	r1, [pc, #72]	; (20308c <__init_ram_areas+0x5c>)
    while (p < rap->clear_area) {
  203042:	429c      	cmp	r4, r3
  203044:	d911      	bls.n	20306a <__init_ram_areas+0x3a>
  203046:	3904      	subs	r1, #4
  203048:	461a      	mov	r2, r3
      *p = *tp;
  20304a:	f851 0f04 	ldr.w	r0, [r1, #4]!
  20304e:	f842 0b04 	str.w	r0, [r2], #4
    while (p < rap->clear_area) {
  203052:	4294      	cmp	r4, r2
  203054:	d8f9      	bhi.n	20304a <__init_ram_areas+0x1a>
  203056:	43da      	mvns	r2, r3
  203058:	4414      	add	r4, r2
  20305a:	f024 0403 	bic.w	r4, r4, #3
  20305e:	3404      	adds	r4, #4
  203060:	4423      	add	r3, r4
    while (p < rap->no_init_area) {
  203062:	429d      	cmp	r5, r3
  203064:	d903      	bls.n	20306e <__init_ram_areas+0x3e>
      *p = 0;
  203066:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->no_init_area) {
  20306a:	429d      	cmp	r5, r3
  20306c:	d8fb      	bhi.n	203066 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  20306e:	3710      	adds	r7, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
  203070:	4577      	cmp	r7, lr
  203072:	d202      	bcs.n	20307a <__init_ram_areas+0x4a>
  203074:	e897 003a 	ldmia.w	r7, {r1, r3, r4, r5}
  203078:	e7e3      	b.n	203042 <__init_ram_areas+0x12>
  20307a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  20307c:	080050d4 	.word	0x080050d4
  203080:	20020664 	.word	0x20020664
  203084:	20020664 	.word	0x20020664
  203088:	20020664 	.word	0x20020664
  20308c:	0800590c 	.word	0x0800590c

00203090 <__default_exit>:
void __default_exit(void) {
  203090:	e7fe      	b.n	203090 <__default_exit>
  203092:	bf00      	nop
	...

002030a0 <__late_init>:
void __late_init(void) {}
  2030a0:	4770      	bx	lr
  2030a2:	bf00      	nop
	...

002030b0 <__core_init>:
void __core_init(void) {
  2030b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
  2030b2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  2030b6:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
  2030ba:	4c1b      	ldr	r4, [pc, #108]	; (203128 <__core_init+0x78>)
  2030bc:	2200      	movs	r2, #0
  2030be:	f8c4 2250 	str.w	r2, [r4, #592]	; 0x250
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
  2030c2:	6963      	ldr	r3, [r4, #20]
  2030c4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  2030c8:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
  2030ca:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  2030ce:	f3bf 8f6f 	isb	sy
  #if (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
  2030d2:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
  2030d6:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
  2030da:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
  2030de:	f643 7ee0 	movw	lr, #16352	; 0x3fe0
  2030e2:	f3c3 06c9 	ubfx	r6, r3, #3, #10

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
  2030e6:	f3c3 334e 	ubfx	r3, r3, #13, #15
  2030ea:	07b7      	lsls	r7, r6, #30
  2030ec:	015d      	lsls	r5, r3, #5
  2030ee:	ea05 000e 	and.w	r0, r5, lr
  2030f2:	4639      	mov	r1, r7
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  2030f4:	4632      	mov	r2, r6
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  2030f6:	ea41 0300 	orr.w	r3, r1, r0
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways--);
  2030fa:	3a01      	subs	r2, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  2030fc:	f101 4140 	add.w	r1, r1, #3221225472	; 0xc0000000
  203100:	f8c4 3260 	str.w	r3, [r4, #608]	; 0x260
      } while (ways--);
  203104:	1c53      	adds	r3, r2, #1
  203106:	d1f6      	bne.n	2030f6 <__core_init+0x46>
  203108:	3d20      	subs	r5, #32
    } while(sets--);
  20310a:	f115 0f20 	cmn.w	r5, #32
  20310e:	d1ee      	bne.n	2030ee <__core_init+0x3e>
  203110:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
  203114:	6963      	ldr	r3, [r4, #20]
  203116:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  20311a:	6163      	str	r3, [r4, #20]
  20311c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  203120:	f3bf 8f6f 	isb	sy
  203124:	bdf0      	pop	{r4, r5, r6, r7, pc}
  203126:	bf00      	nop
  203128:	e000ed00 	.word	0xe000ed00
  20312c:	00000000 	.word	0x00000000

00203130 <notify7.lto_priv.47>:
  UART7->CR1 |= USART_CR1_TXEIE;
  203130:	4a02      	ldr	r2, [pc, #8]	; (20313c <notify7.lto_priv.47+0xc>)
  203132:	6813      	ldr	r3, [r2, #0]
  203134:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  203138:	6013      	str	r3, [r2, #0]
  20313a:	4770      	bx	lr
  20313c:	40007800 	.word	0x40007800

00203140 <notify6.lto_priv.46>:
  USART6->CR1 |= USART_CR1_TXEIE;
  203140:	4a02      	ldr	r2, [pc, #8]	; (20314c <notify6.lto_priv.46+0xc>)
  203142:	6813      	ldr	r3, [r2, #0]
  203144:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  203148:	6013      	str	r3, [r2, #0]
  20314a:	4770      	bx	lr
  20314c:	40011400 	.word	0x40011400

00203150 <notify5.lto_priv.45>:
  UART5->CR1 |= USART_CR1_TXEIE;
  203150:	4a02      	ldr	r2, [pc, #8]	; (20315c <notify5.lto_priv.45+0xc>)
  203152:	6813      	ldr	r3, [r2, #0]
  203154:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  203158:	6013      	str	r3, [r2, #0]
  20315a:	4770      	bx	lr
  20315c:	40005000 	.word	0x40005000

00203160 <pwm_lld_serve_interrupt>:
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
  203160:	6983      	ldr	r3, [r0, #24]
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  203162:	b570      	push	{r4, r5, r6, lr}
  sr  = pwmp->tim->SR;
  203164:	691c      	ldr	r4, [r3, #16]
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  203166:	4605      	mov	r5, r0
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  203168:	68da      	ldr	r2, [r3, #12]
  20316a:	4014      	ands	r4, r2
  20316c:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
  20316e:	07a6      	lsls	r6, r4, #30
  pwmp->tim->SR = ~sr;
  203170:	ea6f 0202 	mvn.w	r2, r2
  203174:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
  203176:	d503      	bpl.n	203180 <pwm_lld_serve_interrupt+0x20>
      (pwmp->config->channels[0].callback != NULL))
  203178:	6843      	ldr	r3, [r0, #4]
  20317a:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
  20317c:	b103      	cbz	r3, 203180 <pwm_lld_serve_interrupt+0x20>
    pwmp->config->channels[0].callback(pwmp);
  20317e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
  203180:	0760      	lsls	r0, r4, #29
  203182:	d504      	bpl.n	20318e <pwm_lld_serve_interrupt+0x2e>
      (pwmp->config->channels[1].callback != NULL))
  203184:	686b      	ldr	r3, [r5, #4]
  203186:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
  203188:	b10b      	cbz	r3, 20318e <pwm_lld_serve_interrupt+0x2e>
    pwmp->config->channels[1].callback(pwmp);
  20318a:	4628      	mov	r0, r5
  20318c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
  20318e:	0721      	lsls	r1, r4, #28
  203190:	d504      	bpl.n	20319c <pwm_lld_serve_interrupt+0x3c>
      (pwmp->config->channels[2].callback != NULL))
  203192:	686b      	ldr	r3, [r5, #4]
  203194:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
  203196:	b10b      	cbz	r3, 20319c <pwm_lld_serve_interrupt+0x3c>
    pwmp->config->channels[2].callback(pwmp);
  203198:	4628      	mov	r0, r5
  20319a:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
  20319c:	06e2      	lsls	r2, r4, #27
  20319e:	d504      	bpl.n	2031aa <pwm_lld_serve_interrupt+0x4a>
      (pwmp->config->channels[3].callback != NULL))
  2031a0:	686b      	ldr	r3, [r5, #4]
  2031a2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
  2031a4:	b10b      	cbz	r3, 2031aa <pwm_lld_serve_interrupt+0x4a>
    pwmp->config->channels[3].callback(pwmp);
  2031a6:	4628      	mov	r0, r5
  2031a8:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
  2031aa:	07e3      	lsls	r3, r4, #31
  2031ac:	d506      	bpl.n	2031bc <pwm_lld_serve_interrupt+0x5c>
  2031ae:	686b      	ldr	r3, [r5, #4]
  2031b0:	689b      	ldr	r3, [r3, #8]
  2031b2:	b11b      	cbz	r3, 2031bc <pwm_lld_serve_interrupt+0x5c>
    pwmp->config->callback(pwmp);
  2031b4:	4628      	mov	r0, r5
}
  2031b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pwmp->config->callback(pwmp);
  2031ba:	4718      	bx	r3
  2031bc:	bd70      	pop	{r4, r5, r6, pc}
  2031be:	bf00      	nop

002031c0 <VectorB0>:
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
  2031c0:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD2);
  2031c2:	4803      	ldr	r0, [pc, #12]	; (2031d0 <VectorB0+0x10>)
  2031c4:	f7ff ffcc 	bl	203160 <pwm_lld_serve_interrupt>
}
  2031c8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  2031cc:	f7ff ba48 	b.w	202660 <_port_irq_epilogue>
  2031d0:	20000cd0 	.word	0x20000cd0
	...

002031e0 <VectorA4>:
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
  2031e0:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD1);
  2031e2:	4803      	ldr	r0, [pc, #12]	; (2031f0 <VectorA4+0x10>)
  2031e4:	f7ff ffbc 	bl	203160 <pwm_lld_serve_interrupt>
}
  2031e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  2031ec:	f7ff ba38 	b.w	202660 <_port_irq_epilogue>
  2031f0:	20000cb4 	.word	0x20000cb4
	...

00203200 <VectorAC>:
  203200:	f7ff bfee 	b.w	2031e0 <VectorA4>
	...

00203210 <VectorA0>:
OSAL_IRQ_HANDLER(STM32_TIM9_HANDLER) {
  203210:	b508      	push	{r3, lr}
 *
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {

  gptp->tim->SR = 0;
  203212:	4b0b      	ldr	r3, [pc, #44]	; (203240 <VectorA0+0x30>)
  203214:	2100      	movs	r1, #0
  if (gptp->state == GPT_ONESHOT) {
  203216:	7818      	ldrb	r0, [r3, #0]
  gptp->tim->SR = 0;
  203218:	68da      	ldr	r2, [r3, #12]
  if (gptp->state == GPT_ONESHOT) {
  20321a:	2804      	cmp	r0, #4
  gptp->tim->SR = 0;
  20321c:	6111      	str	r1, [r2, #16]
  if (gptp->state == GPT_ONESHOT) {
  20321e:	d107      	bne.n	203230 <VectorA0+0x20>
    gptp->state = GPT_READY;                /* Back in GPT_READY state.     */
  203220:	2002      	movs	r0, #2
  203222:	7018      	strb	r0, [r3, #0]
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  203224:	6011      	str	r1, [r2, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  203226:	6111      	str	r1, [r2, #16]
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
  203228:	68d1      	ldr	r1, [r2, #12]
  20322a:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  20322e:	60d1      	str	r1, [r2, #12]
    gpt_lld_stop_timer(gptp);               /* Timer automatically stopped. */
  }
  gptp->config->callback(gptp);
  203230:	685b      	ldr	r3, [r3, #4]
  203232:	4803      	ldr	r0, [pc, #12]	; (203240 <VectorA0+0x30>)
  203234:	685b      	ldr	r3, [r3, #4]
  203236:	4798      	blx	r3
}
  203238:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  20323c:	f7ff ba10 	b.w	202660 <_port_irq_epilogue>
  203240:	2000080c 	.word	0x2000080c
	...

00203250 <Vector118>:
OSAL_IRQ_HANDLER(STM32_TIM6_HANDLER) {
  203250:	b508      	push	{r3, lr}
  gptp->tim->SR = 0;
  203252:	4b0b      	ldr	r3, [pc, #44]	; (203280 <Vector118+0x30>)
  203254:	2100      	movs	r1, #0
  if (gptp->state == GPT_ONESHOT) {
  203256:	7818      	ldrb	r0, [r3, #0]
  gptp->tim->SR = 0;
  203258:	68da      	ldr	r2, [r3, #12]
  if (gptp->state == GPT_ONESHOT) {
  20325a:	2804      	cmp	r0, #4
  gptp->tim->SR = 0;
  20325c:	6111      	str	r1, [r2, #16]
  if (gptp->state == GPT_ONESHOT) {
  20325e:	d107      	bne.n	203270 <Vector118+0x20>
    gptp->state = GPT_READY;                /* Back in GPT_READY state.     */
  203260:	2002      	movs	r0, #2
  203262:	7018      	strb	r0, [r3, #0]
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  203264:	6011      	str	r1, [r2, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  203266:	6111      	str	r1, [r2, #16]
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
  203268:	68d1      	ldr	r1, [r2, #12]
  20326a:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  20326e:	60d1      	str	r1, [r2, #12]
  gptp->config->callback(gptp);
  203270:	685b      	ldr	r3, [r3, #4]
  203272:	4803      	ldr	r0, [pc, #12]	; (203280 <Vector118+0x30>)
  203274:	685b      	ldr	r3, [r3, #4]
  203276:	4798      	blx	r3
}
  203278:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  20327c:	f7ff b9f0 	b.w	202660 <_port_irq_epilogue>
  203280:	20000c90 	.word	0x20000c90
	...

00203290 <SysTick_Handler>:
OSAL_IRQ_HANDLER(SysTick_Handler) {
  203290:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
  203292:	2720      	movs	r7, #32
  203294:	f387 8811 	msr	BASEPRI, r7
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
  203298:	4d12      	ldr	r5, [pc, #72]	; (2032e4 <SysTick_Handler+0x54>)
  20329a:	8cea      	ldrh	r2, [r5, #38]	; 0x26
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
  20329c:	462e      	mov	r6, r5
  ch.vtlist.systime++;
  20329e:	3201      	adds	r2, #1
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
  2032a0:	f856 3f1c 	ldr.w	r3, [r6, #28]!
  ch.vtlist.systime++;
  2032a4:	b292      	uxth	r2, r2
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
  2032a6:	42b3      	cmp	r3, r6
  ch.vtlist.systime++;
  2032a8:	84ea      	strh	r2, [r5, #38]	; 0x26
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
  2032aa:	d013      	beq.n	2032d4 <SysTick_Handler+0x44>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.next->delta;
  2032ac:	891c      	ldrh	r4, [r3, #8]
  2032ae:	3c01      	subs	r4, #1
  2032b0:	b2a4      	uxth	r4, r4
  2032b2:	811c      	strh	r4, [r3, #8]
    while (ch.vtlist.next->delta == (systime_t)0) {
  2032b4:	b974      	cbnz	r4, 2032d4 <SysTick_Handler+0x44>
      vtfunc_t fn;

      vtp = ch.vtlist.next;
      fn = vtp->func;
      vtp->func = NULL;
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
  2032b6:	681a      	ldr	r2, [r3, #0]
      fn = vtp->func;
  2032b8:	68d9      	ldr	r1, [r3, #12]
      vtp->func = NULL;
  2032ba:	60dc      	str	r4, [r3, #12]
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
  2032bc:	6056      	str	r6, [r2, #4]
      ch.vtlist.next = vtp->next;
  2032be:	61ea      	str	r2, [r5, #28]
  2032c0:	f384 8811 	msr	BASEPRI, r4
      chSysUnlockFromISR();
      fn(vtp->par);
  2032c4:	6918      	ldr	r0, [r3, #16]
  2032c6:	4788      	blx	r1
  2032c8:	f387 8811 	msr	BASEPRI, r7
    while (ch.vtlist.next->delta == (systime_t)0) {
  2032cc:	69eb      	ldr	r3, [r5, #28]
  2032ce:	891a      	ldrh	r2, [r3, #8]
  2032d0:	2a00      	cmp	r2, #0
  2032d2:	d0f0      	beq.n	2032b6 <SysTick_Handler+0x26>
  2032d4:	2300      	movs	r3, #0
  2032d6:	f383 8811 	msr	BASEPRI, r3
}
  2032da:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_EPILOGUE();
  2032de:	f7ff b9bf 	b.w	202660 <_port_irq_epilogue>
  2032e2:	bf00      	nop
  2032e4:	20000d78 	.word	0x20000d78
	...

002032f0 <Vector158>:
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  2032f0:	4b08      	ldr	r3, [pc, #32]	; (203314 <Vector158+0x24>)
  if (dma_isr_redir[15].dma_func)
  2032f2:	4809      	ldr	r0, [pc, #36]	; (203318 <Vector158+0x28>)
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  2032f4:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[15].dma_func)
  2032f6:	6f82      	ldr	r2, [r0, #120]	; 0x78
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  2032f8:	0d89      	lsrs	r1, r1, #22
  2032fa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  2032fe:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 22U;
  203300:	058c      	lsls	r4, r1, #22
  203302:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
  203304:	b10a      	cbz	r2, 20330a <Vector158+0x1a>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
  203306:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
  203308:	4790      	blx	r2
}
  20330a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  20330e:	f7ff b9a7 	b.w	202660 <_port_irq_epilogue>
  203312:	bf00      	nop
  203314:	40026400 	.word	0x40026400
  203318:	20000df8 	.word	0x20000df8
  20331c:	00000000 	.word	0x00000000

00203320 <Vector154>:
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  203320:	4b08      	ldr	r3, [pc, #32]	; (203344 <Vector154+0x24>)
  if (dma_isr_redir[14].dma_func)
  203322:	4809      	ldr	r0, [pc, #36]	; (203348 <Vector154+0x28>)
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  203324:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[14].dma_func)
  203326:	6f02      	ldr	r2, [r0, #112]	; 0x70
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  203328:	0c09      	lsrs	r1, r1, #16
  20332a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  20332e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 16U;
  203330:	040c      	lsls	r4, r1, #16
  203332:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
  203334:	b10a      	cbz	r2, 20333a <Vector154+0x1a>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
  203336:	6f40      	ldr	r0, [r0, #116]	; 0x74
  203338:	4790      	blx	r2
}
  20333a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  20333e:	f7ff b98f 	b.w	202660 <_port_irq_epilogue>
  203342:	bf00      	nop
  203344:	40026400 	.word	0x40026400
  203348:	20000df8 	.word	0x20000df8
  20334c:	00000000 	.word	0x00000000

00203350 <Vector150>:
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  203350:	4b08      	ldr	r3, [pc, #32]	; (203374 <Vector150+0x24>)
  if (dma_isr_redir[13].dma_func)
  203352:	4809      	ldr	r0, [pc, #36]	; (203378 <Vector150+0x28>)
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  203354:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[13].dma_func)
  203356:	6e82      	ldr	r2, [r0, #104]	; 0x68
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  203358:	0989      	lsrs	r1, r1, #6
  20335a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  20335e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 6U;
  203360:	018c      	lsls	r4, r1, #6
  203362:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
  203364:	b10a      	cbz	r2, 20336a <Vector150+0x1a>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
  203366:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
  203368:	4790      	blx	r2
}
  20336a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  20336e:	f7ff b977 	b.w	202660 <_port_irq_epilogue>
  203372:	bf00      	nop
  203374:	40026400 	.word	0x40026400
  203378:	20000df8 	.word	0x20000df8
  20337c:	00000000 	.word	0x00000000

00203380 <Vector130>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  203380:	b508      	push	{r3, lr}
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  203382:	4b07      	ldr	r3, [pc, #28]	; (2033a0 <Vector130+0x20>)
  if (dma_isr_redir[12].dma_func)
  203384:	4807      	ldr	r0, [pc, #28]	; (2033a4 <Vector130+0x24>)
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  203386:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[12].dma_func)
  203388:	6e02      	ldr	r2, [r0, #96]	; 0x60
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  20338a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
  20338e:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
  203390:	b10a      	cbz	r2, 203396 <Vector130+0x16>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
  203392:	6e40      	ldr	r0, [r0, #100]	; 0x64
  203394:	4790      	blx	r2
}
  203396:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  20339a:	f7ff b961 	b.w	202660 <_port_irq_epilogue>
  20339e:	bf00      	nop
  2033a0:	40026400 	.word	0x40026400
  2033a4:	20000df8 	.word	0x20000df8
	...

002033b0 <Vector12C>:
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  2033b0:	4b08      	ldr	r3, [pc, #32]	; (2033d4 <Vector12C+0x24>)
  if (dma_isr_redir[11].dma_func)
  2033b2:	4809      	ldr	r0, [pc, #36]	; (2033d8 <Vector12C+0x28>)
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  2033b4:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[11].dma_func)
  2033b6:	6d82      	ldr	r2, [r0, #88]	; 0x58
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  2033b8:	0d89      	lsrs	r1, r1, #22
  2033ba:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  2033be:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 22U;
  2033c0:	058c      	lsls	r4, r1, #22
  2033c2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
  2033c4:	b10a      	cbz	r2, 2033ca <Vector12C+0x1a>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
  2033c6:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
  2033c8:	4790      	blx	r2
}
  2033ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  2033ce:	f7ff b947 	b.w	202660 <_port_irq_epilogue>
  2033d2:	bf00      	nop
  2033d4:	40026400 	.word	0x40026400
  2033d8:	20000df8 	.word	0x20000df8
  2033dc:	00000000 	.word	0x00000000

002033e0 <Vector128>:
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  2033e0:	4b08      	ldr	r3, [pc, #32]	; (203404 <Vector128+0x24>)
  if (dma_isr_redir[10].dma_func)
  2033e2:	4809      	ldr	r0, [pc, #36]	; (203408 <Vector128+0x28>)
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  2033e4:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[10].dma_func)
  2033e6:	6d02      	ldr	r2, [r0, #80]	; 0x50
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  2033e8:	0c09      	lsrs	r1, r1, #16
  2033ea:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  2033ee:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 16U;
  2033f0:	040c      	lsls	r4, r1, #16
  2033f2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
  2033f4:	b10a      	cbz	r2, 2033fa <Vector128+0x1a>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
  2033f6:	6d40      	ldr	r0, [r0, #84]	; 0x54
  2033f8:	4790      	blx	r2
}
  2033fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  2033fe:	f7ff b92f 	b.w	202660 <_port_irq_epilogue>
  203402:	bf00      	nop
  203404:	40026400 	.word	0x40026400
  203408:	20000df8 	.word	0x20000df8
  20340c:	00000000 	.word	0x00000000

00203410 <Vector124>:
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  203410:	4b08      	ldr	r3, [pc, #32]	; (203434 <Vector124+0x24>)
  if (dma_isr_redir[9].dma_func)
  203412:	4809      	ldr	r0, [pc, #36]	; (203438 <Vector124+0x28>)
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  203414:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[9].dma_func)
  203416:	6c82      	ldr	r2, [r0, #72]	; 0x48
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  203418:	0989      	lsrs	r1, r1, #6
  20341a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  20341e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 6U;
  203420:	018c      	lsls	r4, r1, #6
  203422:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
  203424:	b10a      	cbz	r2, 20342a <Vector124+0x1a>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
  203426:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
  203428:	4790      	blx	r2
}
  20342a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  20342e:	f7ff b917 	b.w	202660 <_port_irq_epilogue>
  203432:	bf00      	nop
  203434:	40026400 	.word	0x40026400
  203438:	20000df8 	.word	0x20000df8
  20343c:	00000000 	.word	0x00000000

00203440 <Vector120>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  203440:	b508      	push	{r3, lr}
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  203442:	4b07      	ldr	r3, [pc, #28]	; (203460 <Vector120+0x20>)
  if (dma_isr_redir[8].dma_func)
  203444:	4807      	ldr	r0, [pc, #28]	; (203464 <Vector120+0x24>)
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  203446:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[8].dma_func)
  203448:	6c02      	ldr	r2, [r0, #64]	; 0x40
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  20344a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
  20344e:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
  203450:	b10a      	cbz	r2, 203456 <Vector120+0x16>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
  203452:	6c40      	ldr	r0, [r0, #68]	; 0x44
  203454:	4790      	blx	r2
}
  203456:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  20345a:	f7ff b901 	b.w	202660 <_port_irq_epilogue>
  20345e:	bf00      	nop
  203460:	40026400 	.word	0x40026400
  203464:	20000df8 	.word	0x20000df8
	...

00203470 <VectorFC>:
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  203470:	4b08      	ldr	r3, [pc, #32]	; (203494 <VectorFC+0x24>)
  if (dma_isr_redir[7].dma_func)
  203472:	4809      	ldr	r0, [pc, #36]	; (203498 <VectorFC+0x28>)
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  203474:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[7].dma_func)
  203476:	6b82      	ldr	r2, [r0, #56]	; 0x38
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  203478:	0d89      	lsrs	r1, r1, #22
  20347a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  20347e:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 22U;
  203480:	058c      	lsls	r4, r1, #22
  203482:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
  203484:	b10a      	cbz	r2, 20348a <VectorFC+0x1a>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
  203486:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
  203488:	4790      	blx	r2
}
  20348a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  20348e:	f7ff b8e7 	b.w	202660 <_port_irq_epilogue>
  203492:	bf00      	nop
  203494:	40026000 	.word	0x40026000
  203498:	20000df8 	.word	0x20000df8
  20349c:	00000000 	.word	0x00000000

002034a0 <Vector84>:
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  2034a0:	4b08      	ldr	r3, [pc, #32]	; (2034c4 <Vector84+0x24>)
  if (dma_isr_redir[6].dma_func)
  2034a2:	4809      	ldr	r0, [pc, #36]	; (2034c8 <Vector84+0x28>)
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  2034a4:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[6].dma_func)
  2034a6:	6b02      	ldr	r2, [r0, #48]	; 0x30
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  2034a8:	0c09      	lsrs	r1, r1, #16
  2034aa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  2034ae:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 16U;
  2034b0:	040c      	lsls	r4, r1, #16
  2034b2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
  2034b4:	b10a      	cbz	r2, 2034ba <Vector84+0x1a>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
  2034b6:	6b40      	ldr	r0, [r0, #52]	; 0x34
  2034b8:	4790      	blx	r2
}
  2034ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  2034be:	f7ff b8cf 	b.w	202660 <_port_irq_epilogue>
  2034c2:	bf00      	nop
  2034c4:	40026000 	.word	0x40026000
  2034c8:	20000df8 	.word	0x20000df8
  2034cc:	00000000 	.word	0x00000000

002034d0 <Vector80>:
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  2034d0:	4b08      	ldr	r3, [pc, #32]	; (2034f4 <Vector80+0x24>)
  if (dma_isr_redir[5].dma_func)
  2034d2:	4809      	ldr	r0, [pc, #36]	; (2034f8 <Vector80+0x28>)
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  2034d4:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[5].dma_func)
  2034d6:	6a82      	ldr	r2, [r0, #40]	; 0x28
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  2034d8:	0989      	lsrs	r1, r1, #6
  2034da:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  2034de:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 6U;
  2034e0:	018c      	lsls	r4, r1, #6
  2034e2:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
  2034e4:	b10a      	cbz	r2, 2034ea <Vector80+0x1a>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
  2034e6:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
  2034e8:	4790      	blx	r2
}
  2034ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  2034ee:	f7ff b8b7 	b.w	202660 <_port_irq_epilogue>
  2034f2:	bf00      	nop
  2034f4:	40026000 	.word	0x40026000
  2034f8:	20000df8 	.word	0x20000df8
  2034fc:	00000000 	.word	0x00000000

00203500 <Vector7C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  203500:	b508      	push	{r3, lr}
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  203502:	4b07      	ldr	r3, [pc, #28]	; (203520 <Vector7C+0x20>)
  if (dma_isr_redir[4].dma_func)
  203504:	4807      	ldr	r0, [pc, #28]	; (203524 <Vector7C+0x24>)
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  203506:	6859      	ldr	r1, [r3, #4]
  if (dma_isr_redir[4].dma_func)
  203508:	6a02      	ldr	r2, [r0, #32]
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  20350a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
  20350e:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
  203510:	b10a      	cbz	r2, 203516 <Vector7C+0x16>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
  203512:	6a40      	ldr	r0, [r0, #36]	; 0x24
  203514:	4790      	blx	r2
}
  203516:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  20351a:	f7ff b8a1 	b.w	202660 <_port_irq_epilogue>
  20351e:	bf00      	nop
  203520:	40026000 	.word	0x40026000
  203524:	20000df8 	.word	0x20000df8
	...

00203530 <Vector78>:
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  203530:	4b08      	ldr	r3, [pc, #32]	; (203554 <Vector78+0x24>)
  if (dma_isr_redir[3].dma_func)
  203532:	4809      	ldr	r0, [pc, #36]	; (203558 <Vector78+0x28>)
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  203534:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[3].dma_func)
  203536:	6982      	ldr	r2, [r0, #24]
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  203538:	0d89      	lsrs	r1, r1, #22
  20353a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  20353e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 22U;
  203540:	058c      	lsls	r4, r1, #22
  203542:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
  203544:	b10a      	cbz	r2, 20354a <Vector78+0x1a>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
  203546:	69c0      	ldr	r0, [r0, #28]
  203548:	4790      	blx	r2
}
  20354a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  20354e:	f7ff b887 	b.w	202660 <_port_irq_epilogue>
  203552:	bf00      	nop
  203554:	40026000 	.word	0x40026000
  203558:	20000df8 	.word	0x20000df8
  20355c:	00000000 	.word	0x00000000

00203560 <Vector74>:
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  203560:	4b08      	ldr	r3, [pc, #32]	; (203584 <Vector74+0x24>)
  if (dma_isr_redir[2].dma_func)
  203562:	4809      	ldr	r0, [pc, #36]	; (203588 <Vector74+0x28>)
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  203564:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[2].dma_func)
  203566:	6902      	ldr	r2, [r0, #16]
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  203568:	0c09      	lsrs	r1, r1, #16
  20356a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  20356e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 16U;
  203570:	040c      	lsls	r4, r1, #16
  203572:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
  203574:	b10a      	cbz	r2, 20357a <Vector74+0x1a>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
  203576:	6940      	ldr	r0, [r0, #20]
  203578:	4790      	blx	r2
}
  20357a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  20357e:	f7ff b86f 	b.w	202660 <_port_irq_epilogue>
  203582:	bf00      	nop
  203584:	40026000 	.word	0x40026000
  203588:	20000df8 	.word	0x20000df8
  20358c:	00000000 	.word	0x00000000

00203590 <Vector70>:
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  203590:	4b08      	ldr	r3, [pc, #32]	; (2035b4 <Vector70+0x24>)
  if (dma_isr_redir[1].dma_func)
  203592:	4809      	ldr	r0, [pc, #36]	; (2035b8 <Vector70+0x28>)
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  203594:	6819      	ldr	r1, [r3, #0]
  if (dma_isr_redir[1].dma_func)
  203596:	6882      	ldr	r2, [r0, #8]
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  203598:	0989      	lsrs	r1, r1, #6
  20359a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  20359e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 6U;
  2035a0:	018c      	lsls	r4, r1, #6
  2035a2:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
  2035a4:	b10a      	cbz	r2, 2035aa <Vector70+0x1a>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
  2035a6:	68c0      	ldr	r0, [r0, #12]
  2035a8:	4790      	blx	r2
}
  2035aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  2035ae:	f7ff b857 	b.w	202660 <_port_irq_epilogue>
  2035b2:	bf00      	nop
  2035b4:	40026000 	.word	0x40026000
  2035b8:	20000df8 	.word	0x20000df8
  2035bc:	00000000 	.word	0x00000000

002035c0 <Vector6C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  2035c0:	b508      	push	{r3, lr}
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  2035c2:	4b07      	ldr	r3, [pc, #28]	; (2035e0 <Vector6C+0x20>)
  if (dma_isr_redir[0].dma_func)
  2035c4:	4a07      	ldr	r2, [pc, #28]	; (2035e4 <Vector6C+0x24>)
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  2035c6:	6819      	ldr	r1, [r3, #0]
  2035c8:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
  2035cc:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
  2035ce:	6813      	ldr	r3, [r2, #0]
  2035d0:	b10b      	cbz	r3, 2035d6 <Vector6C+0x16>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
  2035d2:	6850      	ldr	r0, [r2, #4]
  2035d4:	4798      	blx	r3
}
  2035d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  2035da:	f7ff b841 	b.w	202660 <_port_irq_epilogue>
  2035de:	bf00      	nop
  2035e0:	40026000 	.word	0x40026000
  2035e4:	20000df8 	.word	0x20000df8
	...

002035f0 <serve_interrupt>:
static void serve_interrupt(SerialDriver *sdp) {
  2035f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  USART_TypeDef *u = sdp->usart;
  2035f4:	6d46      	ldr	r6, [r0, #84]	; 0x54
static void serve_interrupt(SerialDriver *sdp) {
  2035f6:	4604      	mov	r4, r0
  uint32_t cr1 = u->CR1;
  2035f8:	6837      	ldr	r7, [r6, #0]
  isr = u->ISR;
  2035fa:	69f5      	ldr	r5, [r6, #28]
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
  2035fc:	072a      	lsls	r2, r5, #28
  u->ICR = isr;
  2035fe:	6235      	str	r5, [r6, #32]
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
  203600:	d154      	bne.n	2036ac <serve_interrupt+0xbc>
  if (isr & USART_ISR_LBDF) {
  203602:	05eb      	lsls	r3, r5, #23
  203604:	d446      	bmi.n	203694 <serve_interrupt+0xa4>
  if (isr & USART_ISR_RXNE) {
  203606:	06a8      	lsls	r0, r5, #26
  203608:	d417      	bmi.n	20363a <serve_interrupt+0x4a>
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
  20360a:	0639      	lsls	r1, r7, #24
  20360c:	d501      	bpl.n	203612 <serve_interrupt+0x22>
  20360e:	062a      	lsls	r2, r5, #24
  203610:	d468      	bmi.n	2036e4 <serve_interrupt+0xf4>
  if (isr & USART_ISR_TC) {
  203612:	066b      	lsls	r3, r5, #25
  203614:	d50f      	bpl.n	203636 <serve_interrupt+0x46>
  203616:	2320      	movs	r3, #32
  203618:	f383 8811 	msr	BASEPRI, r3
    if (oqIsEmptyI(&sdp->oqueue))
  20361c:	6c62      	ldr	r2, [r4, #68]	; 0x44
  20361e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  203620:	429a      	cmp	r2, r3
  203622:	f000 8089 	beq.w	203738 <serve_interrupt+0x148>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
  203626:	f027 0740 	bic.w	r7, r7, #64	; 0x40
  20362a:	2300      	movs	r3, #0
  20362c:	6037      	str	r7, [r6, #0]
  20362e:	f383 8811 	msr	BASEPRI, r3
  203632:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  203636:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  20363a:	2320      	movs	r3, #32
  20363c:	f383 8811 	msr	BASEPRI, r3
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
  203640:	6a72      	ldr	r2, [r6, #36]	; 0x24
  203642:	f894 805c 	ldrb.w	r8, [r4, #92]	; 0x5c
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
  203646:	6963      	ldr	r3, [r4, #20]
  203648:	ea08 0802 	and.w	r8, r8, r2
  20364c:	2b00      	cmp	r3, #0
  20364e:	d07c      	beq.n	20374a <serve_interrupt+0x15a>
  if (iqIsFullI(iqp)) {
  203650:	6a23      	ldr	r3, [r4, #32]
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
  203652:	f104 010c 	add.w	r1, r4, #12
  203656:	6a62      	ldr	r2, [r4, #36]	; 0x24
  203658:	4293      	cmp	r3, r2
  20365a:	d07b      	beq.n	203754 <serve_interrupt+0x164>
  iqp->q_counter++;
  20365c:	6962      	ldr	r2, [r4, #20]
  *iqp->q_wrptr++ = b;
  20365e:	1c58      	adds	r0, r3, #1
  iqp->q_counter++;
  203660:	3201      	adds	r2, #1
  *iqp->q_wrptr++ = b;
  203662:	6220      	str	r0, [r4, #32]
  iqp->q_counter++;
  203664:	6162      	str	r2, [r4, #20]
  *iqp->q_wrptr++ = b;
  203666:	f883 8000 	strb.w	r8, [r3]
  if (iqp->q_wrptr >= iqp->q_top) {
  20366a:	6a22      	ldr	r2, [r4, #32]
  20366c:	69e3      	ldr	r3, [r4, #28]
  20366e:	429a      	cmp	r2, r3
  203670:	d25f      	bcs.n	203732 <serve_interrupt+0x142>
  return (bool)(tqp->next != (const thread_t *)tqp);
  203672:	68e3      	ldr	r3, [r4, #12]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
  203674:	4299      	cmp	r1, r3
  203676:	d009      	beq.n	20368c <serve_interrupt+0x9c>
  tqp->next             = tp->queue.next;
  203678:	681a      	ldr	r2, [r3, #0]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
  20367a:	f04f 0e00 	mov.w	lr, #0
  (void) chSchReadyI(tp);
  20367e:	4618      	mov	r0, r3
  203680:	60e2      	str	r2, [r4, #12]
  tqp->next->queue.prev = (thread_t *)tqp;
  203682:	6051      	str	r1, [r2, #4]
  tp->u.rdymsg = msg;
  203684:	f8c3 e024 	str.w	lr, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
  203688:	f7ff fbc2 	bl	202e10 <chSchReadyI>
  20368c:	2300      	movs	r3, #0
  20368e:	f383 8811 	msr	BASEPRI, r3
  203692:	e7ba      	b.n	20360a <serve_interrupt+0x1a>
  203694:	2320      	movs	r3, #32
  203696:	f383 8811 	msr	BASEPRI, r3
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
  20369a:	f44f 7100 	mov.w	r1, #512	; 0x200
  20369e:	1d20      	adds	r0, r4, #4
  2036a0:	f7ff fc66 	bl	202f70 <chEvtBroadcastFlagsI>
  2036a4:	2300      	movs	r3, #0
  2036a6:	f383 8811 	msr	BASEPRI, r3
  2036aa:	e7ac      	b.n	203606 <serve_interrupt+0x16>
    sts |= SD_OVERRUN_ERROR;
  2036ac:	f015 0f08 	tst.w	r5, #8
  2036b0:	bf0c      	ite	eq
  2036b2:	2100      	moveq	r1, #0
  2036b4:	2180      	movne	r1, #128	; 0x80
  if (isr & USART_ISR_PE)
  2036b6:	07eb      	lsls	r3, r5, #31
  2036b8:	f04f 0320 	mov.w	r3, #32
    sts |= SD_PARITY_ERROR;
  2036bc:	bf48      	it	mi
  2036be:	f041 0120 	orrmi.w	r1, r1, #32
  if (isr & USART_ISR_FE)
  2036c2:	07a8      	lsls	r0, r5, #30
    sts |= SD_FRAMING_ERROR;
  2036c4:	bf48      	it	mi
  2036c6:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (isr & USART_ISR_NE)
  2036ca:	076a      	lsls	r2, r5, #29
    sts |= SD_NOISE_ERROR;
  2036cc:	bf48      	it	mi
  2036ce:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
  2036d2:	f383 8811 	msr	BASEPRI, r3
  2036d6:	1d20      	adds	r0, r4, #4
  2036d8:	f7ff fc4a 	bl	202f70 <chEvtBroadcastFlagsI>
  2036dc:	2300      	movs	r3, #0
  2036de:	f383 8811 	msr	BASEPRI, r3
  2036e2:	e78e      	b.n	203602 <serve_interrupt+0x12>
  2036e4:	2320      	movs	r3, #32
  2036e6:	f383 8811 	msr	BASEPRI, r3
  if (oqIsEmptyI(oqp)) {
  2036ea:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    b = oqGetI(&sdp->oqueue);
  2036ec:	f104 0e30 	add.w	lr, r4, #48	; 0x30
  2036f0:	6c62      	ldr	r2, [r4, #68]	; 0x44
  2036f2:	429a      	cmp	r2, r3
  2036f4:	d037      	beq.n	203766 <serve_interrupt+0x176>
  oqp->q_counter++;
  2036f6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  b = *oqp->q_rdptr++;
  2036f8:	1c58      	adds	r0, r3, #1
  if (oqp->q_rdptr >= oqp->q_top) {
  2036fa:	6c21      	ldr	r1, [r4, #64]	; 0x40
  oqp->q_counter++;
  2036fc:	3201      	adds	r2, #1
  b = *oqp->q_rdptr++;
  2036fe:	64a0      	str	r0, [r4, #72]	; 0x48
  if (oqp->q_rdptr >= oqp->q_top) {
  203700:	4288      	cmp	r0, r1
  oqp->q_counter++;
  203702:	63a2      	str	r2, [r4, #56]	; 0x38
  b = *oqp->q_rdptr++;
  203704:	f893 8000 	ldrb.w	r8, [r3]
  if (oqp->q_rdptr >= oqp->q_top) {
  203708:	d301      	bcc.n	20370e <serve_interrupt+0x11e>
    oqp->q_rdptr = oqp->q_buffer;
  20370a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  20370c:	64a3      	str	r3, [r4, #72]	; 0x48
  return (bool)(tqp->next != (const thread_t *)tqp);
  20370e:	6b23      	ldr	r3, [r4, #48]	; 0x30
  203710:	459e      	cmp	lr, r3
  203712:	d008      	beq.n	203726 <serve_interrupt+0x136>
  tqp->next             = tp->queue.next;
  203714:	681a      	ldr	r2, [r3, #0]
  tp->u.rdymsg = msg;
  203716:	2100      	movs	r1, #0
  (void) chSchReadyI(tp);
  203718:	4618      	mov	r0, r3
  20371a:	6322      	str	r2, [r4, #48]	; 0x30
  tqp->next->queue.prev = (thread_t *)tqp;
  20371c:	f8c2 e004 	str.w	lr, [r2, #4]
  tp->u.rdymsg = msg;
  203720:	6259      	str	r1, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
  203722:	f7ff fb75 	bl	202e10 <chSchReadyI>
      u->TDR = b;
  203726:	f8c6 8028 	str.w	r8, [r6, #40]	; 0x28
  20372a:	2300      	movs	r3, #0
  20372c:	f383 8811 	msr	BASEPRI, r3
  203730:	e76f      	b.n	203612 <serve_interrupt+0x22>
    iqp->q_wrptr = iqp->q_buffer;
  203732:	69a3      	ldr	r3, [r4, #24]
  203734:	6223      	str	r3, [r4, #32]
  203736:	e79c      	b.n	203672 <serve_interrupt+0x82>
    if (oqIsEmptyI(&sdp->oqueue))
  203738:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  20373a:	2b00      	cmp	r3, #0
  20373c:	f43f af73 	beq.w	203626 <serve_interrupt+0x36>
  203740:	1d20      	adds	r0, r4, #4
  203742:	2110      	movs	r1, #16
  203744:	f7ff fc14 	bl	202f70 <chEvtBroadcastFlagsI>
  203748:	e76d      	b.n	203626 <serve_interrupt+0x36>
  20374a:	2104      	movs	r1, #4
  20374c:	1860      	adds	r0, r4, r1
  20374e:	f7ff fc0f 	bl	202f70 <chEvtBroadcastFlagsI>
  203752:	e77d      	b.n	203650 <serve_interrupt+0x60>
  if (iqIsFullI(iqp)) {
  203754:	6962      	ldr	r2, [r4, #20]
  203756:	2a00      	cmp	r2, #0
  203758:	d080      	beq.n	20365c <serve_interrupt+0x6c>
  20375a:	f44f 6180 	mov.w	r1, #1024	; 0x400
  20375e:	1d20      	adds	r0, r4, #4
  203760:	f7ff fc06 	bl	202f70 <chEvtBroadcastFlagsI>
  203764:	e792      	b.n	20368c <serve_interrupt+0x9c>
  if (oqIsEmptyI(oqp)) {
  203766:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  203768:	2a00      	cmp	r2, #0
  20376a:	d0c4      	beq.n	2036f6 <serve_interrupt+0x106>
  20376c:	2108      	movs	r1, #8
  20376e:	1d20      	adds	r0, r4, #4
  203770:	f7ff fbfe 	bl	202f70 <chEvtBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
  203774:	f027 03c0 	bic.w	r3, r7, #192	; 0xc0
  203778:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  20377c:	6033      	str	r3, [r6, #0]
  20377e:	e7d4      	b.n	20372a <serve_interrupt+0x13a>

00203780 <Vector188>:
OSAL_IRQ_HANDLER(STM32_UART7_HANDLER) {
  203780:	b508      	push	{r3, lr}
  serve_interrupt(&SD7);
  203782:	4803      	ldr	r0, [pc, #12]	; (203790 <Vector188+0x10>)
  203784:	f7ff ff34 	bl	2035f0 <serve_interrupt>
}
  203788:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  20378c:	f7fe bf68 	b.w	202660 <_port_irq_epilogue>
  203790:	20000cf0 	.word	0x20000cf0
	...

002037a0 <Vector15C>:
OSAL_IRQ_HANDLER(STM32_USART6_HANDLER) {
  2037a0:	b508      	push	{r3, lr}
  serve_interrupt(&SD6);
  2037a2:	4803      	ldr	r0, [pc, #12]	; (2037b0 <Vector15C+0x10>)
  2037a4:	f7ff ff24 	bl	2035f0 <serve_interrupt>
}
  2037a8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  2037ac:	f7fe bf58 	b.w	202660 <_port_irq_epilogue>
  2037b0:	20000880 	.word	0x20000880
	...

002037c0 <Vector114>:
OSAL_IRQ_HANDLER(STM32_UART5_HANDLER) {
  2037c0:	b508      	push	{r3, lr}
  serve_interrupt(&SD5);
  2037c2:	4803      	ldr	r0, [pc, #12]	; (2037d0 <Vector114+0x10>)
  2037c4:	f7ff ff14 	bl	2035f0 <serve_interrupt>
}
  2037c8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  2037cc:	f7fe bf48 	b.w	202660 <_port_irq_epilogue>
  2037d0:	20000820 	.word	0x20000820
	...

002037e0 <Vector88>:
OSAL_IRQ_HANDLER(STM32_ADC_HANDLER) {
  2037e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  sr = ADC1->SR;
  2037e2:	4b23      	ldr	r3, [pc, #140]	; (203870 <Vector88+0x90>)
  ADC1->SR = 0;
  2037e4:	2100      	movs	r1, #0
  sr = ADC1->SR;
  2037e6:	681a      	ldr	r2, [r3, #0]
  ADC1->SR = 0;
  2037e8:	6019      	str	r1, [r3, #0]
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
  2037ea:	0693      	lsls	r3, r2, #26
  2037ec:	d535      	bpl.n	20385a <Vector88+0x7a>
  2037ee:	4c21      	ldr	r4, [pc, #132]	; (203874 <Vector88+0x94>)
  2037f0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  2037f2:	6802      	ldr	r2, [r0, #0]
  2037f4:	6853      	ldr	r3, [r2, #4]
  2037f6:	2b00      	cmp	r3, #0
  2037f8:	d02f      	beq.n	20385a <Vector88+0x7a>
    if (ADCD1.grpp != NULL)
  2037fa:	6921      	ldr	r1, [r4, #16]
  2037fc:	b369      	cbz	r1, 20385a <Vector88+0x7a>
  dmaStreamDisable(adcp->dmastp);
  2037fe:	6813      	ldr	r3, [r2, #0]
  203800:	f023 031f 	bic.w	r3, r3, #31
  203804:	6013      	str	r3, [r2, #0]
  203806:	6813      	ldr	r3, [r2, #0]
  203808:	f013 0301 	ands.w	r3, r3, #1
  20380c:	d1fb      	bne.n	203806 <Vector88+0x26>
  20380e:	7a07      	ldrb	r7, [r0, #8]
  203810:	223d      	movs	r2, #61	; 0x3d
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
  203812:	688d      	ldr	r5, [r1, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
  203814:	2101      	movs	r1, #1
  dmaStreamDisable(adcp->dmastp);
  203816:	6846      	ldr	r6, [r0, #4]
  203818:	fa02 f707 	lsl.w	r7, r2, r7
  adcp->adc->CR1 = 0;
  20381c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  dmaStreamDisable(adcp->dmastp);
  20381e:	6037      	str	r7, [r6, #0]
  adcp->adc->CR1 = 0;
  203820:	6053      	str	r3, [r2, #4]
  adcp->adc->CR2 = 0;
  203822:	6093      	str	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
  203824:	6091      	str	r1, [r2, #8]
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
  203826:	b1fd      	cbz	r5, 203868 <Vector88+0x88>
  203828:	2305      	movs	r3, #5
  20382a:	4812      	ldr	r0, [pc, #72]	; (203874 <Vector88+0x94>)
  20382c:	7023      	strb	r3, [r4, #0]
  20382e:	47a8      	blx	r5
  203830:	7823      	ldrb	r3, [r4, #0]
  203832:	2b05      	cmp	r3, #5
  203834:	d015      	beq.n	203862 <Vector88+0x82>
  203836:	2300      	movs	r3, #0
  203838:	6123      	str	r3, [r4, #16]
  20383a:	2320      	movs	r3, #32
  20383c:	f383 8811 	msr	BASEPRI, r3
  if (*trp != NULL) {
  203840:	6963      	ldr	r3, [r4, #20]
  203842:	b13b      	cbz	r3, 203854 <Vector88+0x74>
    tp->u.rdymsg = msg;
  203844:	f04f 31ff 	mov.w	r1, #4294967295
    *trp = NULL;
  203848:	2200      	movs	r2, #0
    (void) chSchReadyI(tp);
  20384a:	4618      	mov	r0, r3
    tp->u.rdymsg = msg;
  20384c:	6259      	str	r1, [r3, #36]	; 0x24
    *trp = NULL;
  20384e:	6162      	str	r2, [r4, #20]
    (void) chSchReadyI(tp);
  203850:	f7ff fade 	bl	202e10 <chSchReadyI>
  203854:	2300      	movs	r3, #0
  203856:	f383 8811 	msr	BASEPRI, r3
}
  20385a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_EPILOGUE();
  20385e:	f7fe beff 	b.w	202660 <_port_irq_epilogue>
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
  203862:	2302      	movs	r3, #2
  203864:	7023      	strb	r3, [r4, #0]
  203866:	e7e6      	b.n	203836 <Vector88+0x56>
  203868:	2302      	movs	r3, #2
  20386a:	6125      	str	r5, [r4, #16]
  20386c:	7023      	strb	r3, [r4, #0]
  20386e:	e7e4      	b.n	20383a <Vector88+0x5a>
  203870:	40012000 	.word	0x40012000
  203874:	20000c28 	.word	0x20000c28
	...

00203880 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
  203880:	b430      	push	{r4, r5}
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enabled.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCEN;
  203882:	4b33      	ldr	r3, [pc, #204]	; (203950 <__early_init+0xd0>)
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
#endif

  /* PWR initialization.*/
  PWR->CR1 = STM32_VOS;
  203884:	f44f 4040 	mov.w	r0, #49152	; 0xc000
  203888:	4a32      	ldr	r2, [pc, #200]	; (203954 <__early_init+0xd4>)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCEN;
  20388a:	4c33      	ldr	r4, [pc, #204]	; (203958 <__early_init+0xd8>)

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
  20388c:	4619      	mov	r1, r3
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCEN;
  20388e:	641c      	str	r4, [r3, #64]	; 0x40
  PWR->CR1 = STM32_VOS;
  203890:	6010      	str	r0, [r2, #0]
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  203892:	681a      	ldr	r2, [r3, #0]
  203894:	f042 0201 	orr.w	r2, r2, #1
  203898:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
  20389a:	680b      	ldr	r3, [r1, #0]
  20389c:	079b      	lsls	r3, r3, #30
  20389e:	d5fc      	bpl.n	20389a <__early_init+0x1a>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
  2038a0:	688b      	ldr	r3, [r1, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
  2038a2:	4a2b      	ldr	r2, [pc, #172]	; (203950 <__early_init+0xd0>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
  2038a4:	f023 0303 	bic.w	r3, r3, #3
  2038a8:	608b      	str	r3, [r1, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  2038aa:	688b      	ldr	r3, [r1, #8]
  2038ac:	608b      	str	r3, [r1, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
  2038ae:	6893      	ldr	r3, [r2, #8]
  2038b0:	f013 030c 	ands.w	r3, r3, #12
  2038b4:	d1fb      	bne.n	2038ae <__early_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  2038b6:	6810      	ldr	r0, [r2, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
  2038b8:	4925      	ldr	r1, [pc, #148]	; (203950 <__early_init+0xd0>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  2038ba:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
  2038be:	6010      	str	r0, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
  2038c0:	6093      	str	r3, [r2, #8]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
  2038c2:	6813      	ldr	r3, [r2, #0]
  2038c4:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
  2038c8:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
  2038ca:	680b      	ldr	r3, [r1, #0]
  2038cc:	039d      	lsls	r5, r3, #14
  2038ce:	d5fc      	bpl.n	2038ca <__early_init+0x4a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
  2038d0:	4b22      	ldr	r3, [pc, #136]	; (20395c <__early_init+0xdc>)
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;

  /* Synchronization with voltage regulator stabilization.*/
  while ((PWR->CSR1 & PWR_CSR1_VOSRDY) == 0)
  2038d2:	4820      	ldr	r0, [pc, #128]	; (203954 <__early_init+0xd4>)
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
  2038d4:	604b      	str	r3, [r1, #4]
  RCC->CR |= RCC_CR_PLLON;
  2038d6:	680b      	ldr	r3, [r1, #0]
  2038d8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  2038dc:	600b      	str	r3, [r1, #0]
  while ((PWR->CSR1 & PWR_CSR1_VOSRDY) == 0)
  2038de:	6843      	ldr	r3, [r0, #4]
  2038e0:	045c      	lsls	r4, r3, #17
  2038e2:	d5fc      	bpl.n	2038de <__early_init+0x5e>
    ;                           /* Waits until power regulator is stable.   */

#if STM32_OVERDRIVE_REQUIRED
  /* Overdrive activation performed after activating the PLL in order to save
     time as recommended in RM in "Entering Over-drive mode" paragraph.*/
  PWR->CR1 |= PWR_CR1_ODEN;
  2038e4:	6803      	ldr	r3, [r0, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODRDY))
  2038e6:	4a1b      	ldr	r2, [pc, #108]	; (203954 <__early_init+0xd4>)
  PWR->CR1 |= PWR_CR1_ODEN;
  2038e8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  2038ec:	6003      	str	r3, [r0, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODRDY))
  2038ee:	6853      	ldr	r3, [r2, #4]
  2038f0:	03d9      	lsls	r1, r3, #15
  2038f2:	d5fc      	bpl.n	2038ee <__early_init+0x6e>
      ;
  PWR->CR1 |= PWR_CR1_ODSWEN;
  2038f4:	6813      	ldr	r3, [r2, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODSWRDY))
  2038f6:	4917      	ldr	r1, [pc, #92]	; (203954 <__early_init+0xd4>)
  PWR->CR1 |= PWR_CR1_ODSWEN;
  2038f8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  2038fc:	6013      	str	r3, [r2, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODSWRDY))
  2038fe:	684b      	ldr	r3, [r1, #4]
  203900:	039a      	lsls	r2, r3, #14
  203902:	d5fc      	bpl.n	2038fe <__early_init+0x7e>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
  203904:	4a12      	ldr	r2, [pc, #72]	; (203950 <__early_init+0xd0>)
  203906:	6813      	ldr	r3, [r2, #0]
  203908:	019b      	lsls	r3, r3, #6
  20390a:	d5fc      	bpl.n	203906 <__early_init+0x86>
                  STM32_UART7SEL  | STM32_USART6SEL | STM32_UART5SEL  |
                  STM32_UART4SEL  | STM32_USART3SEL | STM32_USART2SEL |
                  STM32_USART1SEL;

  /* Flash setup.*/
  FLASH->ACR = FLASH_ACR_ARTEN | FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  20390c:	4b14      	ldr	r3, [pc, #80]	; (203960 <__early_init+0xe0>)
  20390e:	f240 3109 	movw	r1, #777	; 0x309
  RCC->CFGR = STM32_MCO2SEL | STM32_MCO2PRE | STM32_MCO1PRE | STM32_I2SSRC |
  203912:	4d14      	ldr	r5, [pc, #80]	; (203964 <__early_init+0xe4>)
    RCC->DCKCFGR1 = dckcfgr1;
  203914:	f240 2402 	movw	r4, #514	; 0x202
  RCC->DCKCFGR2 = STM32_SDMMCSEL  | STM32_CK48MSEL  | STM32_CECSEL    |
  203918:	2000      	movs	r0, #0
  RCC->CFGR = STM32_MCO2SEL | STM32_MCO2PRE | STM32_MCO1PRE | STM32_I2SSRC |
  20391a:	6095      	str	r5, [r2, #8]
    RCC->DCKCFGR1 = dckcfgr1;
  20391c:	f8c2 408c 	str.w	r4, [r2, #140]	; 0x8c
  RCC->DCKCFGR2 = STM32_SDMMCSEL  | STM32_CK48MSEL  | STM32_CECSEL    |
  203920:	f8c2 0090 	str.w	r0, [r2, #144]	; 0x90
  FLASH->ACR = FLASH_ACR_ARTEN | FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  203924:	6019      	str	r1, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
  203926:	6893      	ldr	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
  203928:	4909      	ldr	r1, [pc, #36]	; (203950 <__early_init+0xd0>)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
  20392a:	f043 0302 	orr.w	r3, r3, #2
  20392e:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
  203930:	688b      	ldr	r3, [r1, #8]
  203932:	f003 030c 	and.w	r3, r3, #12
  203936:	2b08      	cmp	r3, #8
  203938:	d1fa      	bne.n	203930 <__early_init+0xb0>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
  20393a:	6c4b      	ldr	r3, [r1, #68]	; 0x44
  20393c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  203940:	644b      	str	r3, [r1, #68]	; 0x44
  203942:	6e4b      	ldr	r3, [r1, #100]	; 0x64
  203944:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000

  stm32_clock_init();
}
  203948:	bc30      	pop	{r4, r5}
  20394a:	664b      	str	r3, [r1, #100]	; 0x64
  20394c:	4770      	bx	lr
  20394e:	bf00      	nop
  203950:	40023800 	.word	0x40023800
  203954:	40007000 	.word	0x40007000
  203958:	10000400 	.word	0x10000400
  20395c:	09406c08 	.word	0x09406c08
  203960:	40023c00 	.word	0x40023c00
  203964:	30999400 	.word	0x30999400
	...

00203970 <usart_init.lto_priv.59>:
  u->CR3 = config->cr3 | USART_CR3_EIE;
  203970:	68cb      	ldr	r3, [r1, #12]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
  203972:	684a      	ldr	r2, [r1, #4]
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  203974:	b4f0      	push	{r4, r5, r6, r7}
  u->BRR = (uint32_t)(sdp->clock / config->speed);
  203976:	680e      	ldr	r6, [r1, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
  203978:	f240 142d 	movw	r4, #301	; 0x12d
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  20397c:	688d      	ldr	r5, [r1, #8]
  u->CR3 = config->cr3 | USART_CR3_EIE;
  20397e:	f043 0101 	orr.w	r1, r3, #1
  u->BRR = (uint32_t)(sdp->clock / config->speed);
  203982:	6d83      	ldr	r3, [r0, #88]	; 0x58
  u->ICR = 0xFFFFFFFFU;
  203984:	f04f 37ff 	mov.w	r7, #4294967295
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  203988:	f045 0540 	orr.w	r5, r5, #64	; 0x40
                         USART_CR1_RXNEIE | USART_CR1_TE |
  20398c:	4314      	orrs	r4, r2
  u->BRR = (uint32_t)(sdp->clock / config->speed);
  20398e:	fbb3 f6f6 	udiv	r6, r3, r6
  USART_TypeDef *u = sdp->usart;
  203992:	6d43      	ldr	r3, [r0, #84]	; 0x54
  u->BRR = (uint32_t)(sdp->clock / config->speed);
  203994:	60de      	str	r6, [r3, #12]
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  203996:	605d      	str	r5, [r3, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
  203998:	6099      	str	r1, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
  20399a:	601c      	str	r4, [r3, #0]
  u->ICR = 0xFFFFFFFFU;
  20399c:	621f      	str	r7, [r3, #32]
  if ((config->cr1 & USART_CR1_PCE) != 0U) {
  20399e:	0553      	lsls	r3, r2, #21
  2039a0:	d505      	bpl.n	2039ae <usart_init.lto_priv.59+0x3e>
    switch (config->cr1 & (USART_CR1_M_1 | USART_CR1_M_0)) {
  2039a2:	f012 2210 	ands.w	r2, r2, #268439552	; 0x10001000
  2039a6:	d00a      	beq.n	2039be <usart_init.lto_priv.59+0x4e>
  2039a8:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
  2039ac:	d003      	beq.n	2039b6 <usart_init.lto_priv.59+0x46>
    sdp->rxmask = 0xFF;
  2039ae:	f880 705c 	strb.w	r7, [r0, #92]	; 0x5c
}
  2039b2:	bcf0      	pop	{r4, r5, r6, r7}
  2039b4:	4770      	bx	lr
      sdp->rxmask = 0x3F;
  2039b6:	233f      	movs	r3, #63	; 0x3f
  2039b8:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
  2039bc:	e7f9      	b.n	2039b2 <usart_init.lto_priv.59+0x42>
      sdp->rxmask = 0x7F;
  2039be:	237f      	movs	r3, #127	; 0x7f
  2039c0:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c
  2039c4:	e7f5      	b.n	2039b2 <usart_init.lto_priv.59+0x42>
  2039c6:	bf00      	nop
	...

002039d0 <pwm_lld_start>:
void pwm_lld_start(PWMDriver *pwmp) {
  2039d0:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (pwmp->state == PWM_STOP) {
  2039d2:	7803      	ldrb	r3, [r0, #0]
  2039d4:	2b01      	cmp	r3, #1
  2039d6:	d05a      	beq.n	203a8e <pwm_lld_start+0xbe>
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
  2039d8:	6983      	ldr	r3, [r0, #24]
  2039da:	2200      	movs	r2, #0
  2039dc:	601a      	str	r2, [r3, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
  2039de:	635a      	str	r2, [r3, #52]	; 0x34
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
  2039e0:	639a      	str	r2, [r3, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
  2039e2:	63da      	str	r2, [r3, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
  2039e4:	641a      	str	r2, [r3, #64]	; 0x40
    if (pwmp->channels > 4) {
  2039e6:	7c01      	ldrb	r1, [r0, #16]
  2039e8:	2904      	cmp	r1, #4
  2039ea:	d849      	bhi.n	203a80 <pwm_lld_start+0xb0>
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
  2039ec:	2200      	movs	r2, #0
  2039ee:	625a      	str	r2, [r3, #36]	; 0x24
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
  2039f0:	6841      	ldr	r1, [r0, #4]
  2039f2:	6944      	ldr	r4, [r0, #20]
  2039f4:	680e      	ldr	r6, [r1, #0]
  pwmp->tim->ARR  = pwmp->period - 1;
  2039f6:	6885      	ldr	r5, [r0, #8]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
  2039f8:	68ca      	ldr	r2, [r1, #12]
  pwmp->tim->CR2  = pwmp->config->cr2;
  2039fa:	6bcf      	ldr	r7, [r1, #60]	; 0x3c
  pwmp->tim->ARR  = pwmp->period - 1;
  2039fc:	3d01      	subs	r5, #1
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
  2039fe:	f002 020f 	and.w	r2, r2, #15
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
  203a02:	fbb4 f0f6 	udiv	r0, r4, r6
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
  203a06:	2a01      	cmp	r2, #1
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
  203a08:	f100 30ff 	add.w	r0, r0, #4294967295
  pwmp->tim->PSC  = psc;
  203a0c:	6298      	str	r0, [r3, #40]	; 0x28
  pwmp->tim->ARR  = pwmp->period - 1;
  203a0e:	62dd      	str	r5, [r3, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
  203a10:	605f      	str	r7, [r3, #4]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
  203a12:	d03a      	beq.n	203a8a <pwm_lld_start+0xba>
  203a14:	2a02      	cmp	r2, #2
  203a16:	d136      	bne.n	203a86 <pwm_lld_start+0xb6>
    ccer |= STM32_TIM_CCER_CC1E;
  203a18:	f042 0201 	orr.w	r2, r2, #1
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
  203a1c:	6948      	ldr	r0, [r1, #20]
  203a1e:	f000 000f 	and.w	r0, r0, #15
  203a22:	2801      	cmp	r0, #1
  203a24:	d029      	beq.n	203a7a <pwm_lld_start+0xaa>
  203a26:	2802      	cmp	r0, #2
  203a28:	d025      	beq.n	203a76 <pwm_lld_start+0xa6>
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
  203a2a:	69c8      	ldr	r0, [r1, #28]
  203a2c:	f000 000f 	and.w	r0, r0, #15
  203a30:	2801      	cmp	r0, #1
  203a32:	d01d      	beq.n	203a70 <pwm_lld_start+0xa0>
  203a34:	2802      	cmp	r0, #2
  203a36:	d019      	beq.n	203a6c <pwm_lld_start+0x9c>
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
  203a38:	6a48      	ldr	r0, [r1, #36]	; 0x24
  203a3a:	f000 000f 	and.w	r0, r0, #15
  203a3e:	2801      	cmp	r0, #1
  203a40:	d003      	beq.n	203a4a <pwm_lld_start+0x7a>
  203a42:	2802      	cmp	r0, #2
  203a44:	d103      	bne.n	203a4e <pwm_lld_start+0x7e>
    ccer |= STM32_TIM_CCER_CC4P;
  203a46:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    ccer |= STM32_TIM_CCER_CC4E;
  203a4a:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
  203a4e:	6c09      	ldr	r1, [r1, #64]	; 0x40
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
  203a50:	2601      	movs	r6, #1
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
  203a52:	2500      	movs	r5, #0
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
  203a54:	f44f 4400 	mov.w	r4, #32768	; 0x8000
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
  203a58:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
  203a5c:	2085      	movs	r0, #133	; 0x85
  pwmp->tim->CCER  = ccer;
  203a5e:	621a      	str	r2, [r3, #32]
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
  203a60:	615e      	str	r6, [r3, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
  203a62:	611d      	str	r5, [r3, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
  203a64:	60d9      	str	r1, [r3, #12]
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
  203a66:	645c      	str	r4, [r3, #68]	; 0x44
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
  203a68:	6018      	str	r0, [r3, #0]
  203a6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ccer |= STM32_TIM_CCER_CC3P;
  203a6c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    ccer |= STM32_TIM_CCER_CC3E;
  203a70:	f442 7280 	orr.w	r2, r2, #256	; 0x100
  203a74:	e7e0      	b.n	203a38 <pwm_lld_start+0x68>
    ccer |= STM32_TIM_CCER_CC2P;
  203a76:	f042 0220 	orr.w	r2, r2, #32
    ccer |= STM32_TIM_CCER_CC2E;
  203a7a:	f042 0210 	orr.w	r2, r2, #16
  203a7e:	e7d4      	b.n	203a2a <pwm_lld_start+0x5a>
      pwmp->tim->CCXR[0] = 0;               /* Comparator 5 disabled.       */
  203a80:	659a      	str	r2, [r3, #88]	; 0x58
      pwmp->tim->CCXR[1] = 0;               /* Comparator 6 disabled.       */
  203a82:	65da      	str	r2, [r3, #92]	; 0x5c
  203a84:	e7b2      	b.n	2039ec <pwm_lld_start+0x1c>
  ccer = 0;
  203a86:	2200      	movs	r2, #0
  203a88:	e7c8      	b.n	203a1c <pwm_lld_start+0x4c>
  203a8a:	2200      	movs	r2, #0
  203a8c:	e7c4      	b.n	203a18 <pwm_lld_start+0x48>
    if (&PWMD1 == pwmp) {
  203a8e:	4b22      	ldr	r3, [pc, #136]	; (203b18 <pwm_lld_start+0x148>)
  203a90:	4298      	cmp	r0, r3
  203a92:	d00a      	beq.n	203aaa <pwm_lld_start+0xda>
    if (&PWMD2 == pwmp) {
  203a94:	4b21      	ldr	r3, [pc, #132]	; (203b1c <pwm_lld_start+0x14c>)
  203a96:	4298      	cmp	r0, r3
  203a98:	d027      	beq.n	203aea <pwm_lld_start+0x11a>
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
  203a9a:	6983      	ldr	r3, [r0, #24]
  203a9c:	f646 0268 	movw	r2, #26728	; 0x6868
    pwmp->tim->CCMR3 = STM32_TIM_CCMR3_OC5M(6) | STM32_TIM_CCMR3_OC5PE |
  203aa0:	491f      	ldr	r1, [pc, #124]	; (203b20 <pwm_lld_start+0x150>)
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
  203aa2:	619a      	str	r2, [r3, #24]
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
  203aa4:	61da      	str	r2, [r3, #28]
    pwmp->tim->CCMR3 = STM32_TIM_CCMR3_OC5M(6) | STM32_TIM_CCMR3_OC5PE |
  203aa6:	6559      	str	r1, [r3, #84]	; 0x54
  203aa8:	e7a2      	b.n	2039f0 <pwm_lld_start+0x20>
      rccEnableTIM1(FALSE);
  203aaa:	4a1e      	ldr	r2, [pc, #120]	; (203b24 <pwm_lld_start+0x154>)
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  203aac:	2570      	movs	r5, #112	; 0x70
  203aae:	4b1e      	ldr	r3, [pc, #120]	; (203b28 <pwm_lld_start+0x158>)
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  203ab0:	f04f 7600 	mov.w	r6, #33554432	; 0x2000000
  203ab4:	6c51      	ldr	r1, [r2, #68]	; 0x44
  203ab6:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
      rccResetTIM1();
  203aba:	f04f 0e00 	mov.w	lr, #0
      pwmp->clock = STM32_TIMCLK2;
  203abe:	4f1b      	ldr	r7, [pc, #108]	; (203b2c <pwm_lld_start+0x15c>)
      rccEnableTIM1(FALSE);
  203ac0:	f041 0101 	orr.w	r1, r1, #1
  203ac4:	6451      	str	r1, [r2, #68]	; 0x44
      rccResetTIM1();
  203ac6:	6a51      	ldr	r1, [r2, #36]	; 0x24
  203ac8:	f041 0101 	orr.w	r1, r1, #1
  203acc:	6251      	str	r1, [r2, #36]	; 0x24
  203ace:	f8c2 e024 	str.w	lr, [r2, #36]	; 0x24
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  203ad2:	f883 5319 	strb.w	r5, [r3, #793]	; 0x319
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  203ad6:	f8c3 6180 	str.w	r6, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  203ada:	601e      	str	r6, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  203adc:	f883 531b 	strb.w	r5, [r3, #795]	; 0x31b
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  203ae0:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  203ae4:	601c      	str	r4, [r3, #0]
      pwmp->clock = STM32_TIMCLK2;
  203ae6:	6147      	str	r7, [r0, #20]
  203ae8:	e7d4      	b.n	203a94 <pwm_lld_start+0xc4>
      rccEnableTIM2(FALSE);
  203aea:	4b0e      	ldr	r3, [pc, #56]	; (203b24 <pwm_lld_start+0x154>)
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  203aec:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  203af0:	4a0d      	ldr	r2, [pc, #52]	; (203b28 <pwm_lld_start+0x158>)
      rccResetTIM2();
  203af2:	2700      	movs	r7, #0
      rccEnableTIM2(FALSE);
  203af4:	6c19      	ldr	r1, [r3, #64]	; 0x40
  203af6:	2670      	movs	r6, #112	; 0x70
      pwmp->clock = STM32_TIMCLK1;
  203af8:	4d0d      	ldr	r5, [pc, #52]	; (203b30 <pwm_lld_start+0x160>)
      rccEnableTIM2(FALSE);
  203afa:	f041 0101 	orr.w	r1, r1, #1
  203afe:	6419      	str	r1, [r3, #64]	; 0x40
      rccResetTIM2();
  203b00:	6a19      	ldr	r1, [r3, #32]
  203b02:	f041 0101 	orr.w	r1, r1, #1
  203b06:	6219      	str	r1, [r3, #32]
  203b08:	621f      	str	r7, [r3, #32]
  203b0a:	f882 631c 	strb.w	r6, [r2, #796]	; 0x31c
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  203b0e:	f8c2 4180 	str.w	r4, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  203b12:	6014      	str	r4, [r2, #0]
      pwmp->clock = STM32_TIMCLK1;
  203b14:	6145      	str	r5, [r0, #20]
  203b16:	e7c0      	b.n	203a9a <pwm_lld_start+0xca>
  203b18:	20000cb4 	.word	0x20000cb4
  203b1c:	20000cd0 	.word	0x20000cd0
  203b20:	01016868 	.word	0x01016868
  203b24:	40023800 	.word	0x40023800
  203b28:	e000e100 	.word	0xe000e100
  203b2c:	0cdfe600 	.word	0x0cdfe600
  203b30:	066ff300 	.word	0x066ff300
	...

00203b40 <gpt_lld_start_timer>:
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {
  203b40:	b430      	push	{r4, r5}
  if (NULL != gptp->config->callback)
  203b42:	6845      	ldr	r5, [r0, #4]
  gptp->tim->CNT = 0;                           /* Reset counter.           */
  203b44:	2200      	movs	r2, #0
  gptp->tim->ARR = (uint32_t)(interval);        /* Time constant.           */
  203b46:	68c3      	ldr	r3, [r0, #12]
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
  203b48:	2401      	movs	r4, #1
  if (NULL != gptp->config->callback)
  203b4a:	6868      	ldr	r0, [r5, #4]
  gptp->tim->ARR = (uint32_t)(interval);        /* Time constant.           */
  203b4c:	62d9      	str	r1, [r3, #44]	; 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
  203b4e:	615c      	str	r4, [r3, #20]
  gptp->tim->CNT = 0;                           /* Reset counter.           */
  203b50:	625a      	str	r2, [r3, #36]	; 0x24
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  203b52:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
  203b54:	b110      	cbz	r0, 203b5c <gpt_lld_start_timer+0x1c>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
  203b56:	68da      	ldr	r2, [r3, #12]
  203b58:	4322      	orrs	r2, r4
  203b5a:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
  203b5c:	2285      	movs	r2, #133	; 0x85
}
  203b5e:	bc30      	pop	{r4, r5}
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
  203b60:	601a      	str	r2, [r3, #0]
}
  203b62:	4770      	bx	lr
	...

00203b70 <gpt_lld_start>:
void gpt_lld_start(GPTDriver *gptp) {
  203b70:	b4f0      	push	{r4, r5, r6, r7}
  if (gptp->state == GPT_STOP) {
  203b72:	7803      	ldrb	r3, [r0, #0]
  203b74:	2b01      	cmp	r3, #1
  203b76:	d013      	beq.n	203ba0 <gpt_lld_start+0x30>
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
  203b78:	6844      	ldr	r4, [r0, #4]
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  203b7a:	2500      	movs	r5, #0
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
  203b7c:	6883      	ldr	r3, [r0, #8]
  203b7e:	6826      	ldr	r6, [r4, #0]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
  203b80:	68e1      	ldr	r1, [r4, #12]
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  203b82:	68c2      	ldr	r2, [r0, #12]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
  203b84:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  gptp->tim->CR2 = gptp->config->cr2;
  203b88:	68a0      	ldr	r0, [r4, #8]
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  203b8a:	6015      	str	r5, [r2, #0]
  gptp->tim->CR2 = gptp->config->cr2;
  203b8c:	6050      	str	r0, [r2, #4]
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
  203b8e:	fbb3 f3f6 	udiv	r3, r3, r6
  203b92:	3b01      	subs	r3, #1
  203b94:	b29b      	uxth	r3, r3
  gptp->tim->PSC = psc;                         /* Prescaler value.         */
  203b96:	6293      	str	r3, [r2, #40]	; 0x28
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  203b98:	6115      	str	r5, [r2, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
  203b9a:	60d1      	str	r1, [r2, #12]
}
  203b9c:	bcf0      	pop	{r4, r5, r6, r7}
  203b9e:	4770      	bx	lr
    if (&GPTD6 == gptp) {
  203ba0:	4b19      	ldr	r3, [pc, #100]	; (203c08 <gpt_lld_start+0x98>)
  203ba2:	4298      	cmp	r0, r3
  203ba4:	d019      	beq.n	203bda <gpt_lld_start+0x6a>
    if (&GPTD9 == gptp) {
  203ba6:	4b19      	ldr	r3, [pc, #100]	; (203c0c <gpt_lld_start+0x9c>)
  203ba8:	4298      	cmp	r0, r3
  203baa:	d1e5      	bne.n	203b78 <gpt_lld_start+0x8>
      rccEnableTIM9(FALSE);
  203bac:	4b18      	ldr	r3, [pc, #96]	; (203c10 <gpt_lld_start+0xa0>)
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  203bae:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  203bb2:	4a18      	ldr	r2, [pc, #96]	; (203c14 <gpt_lld_start+0xa4>)
      rccResetTIM9();
  203bb4:	2700      	movs	r7, #0
      rccEnableTIM9(FALSE);
  203bb6:	6c59      	ldr	r1, [r3, #68]	; 0x44
  203bb8:	2670      	movs	r6, #112	; 0x70
      gptp->clock = STM32_TIMCLK2;
  203bba:	4d17      	ldr	r5, [pc, #92]	; (203c18 <gpt_lld_start+0xa8>)
      rccEnableTIM9(FALSE);
  203bbc:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
  203bc0:	6459      	str	r1, [r3, #68]	; 0x44
      rccResetTIM9();
  203bc2:	6a59      	ldr	r1, [r3, #36]	; 0x24
  203bc4:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
  203bc8:	6259      	str	r1, [r3, #36]	; 0x24
  203bca:	625f      	str	r7, [r3, #36]	; 0x24
  203bcc:	f882 6318 	strb.w	r6, [r2, #792]	; 0x318
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  203bd0:	f8c2 4180 	str.w	r4, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  203bd4:	6014      	str	r4, [r2, #0]
      gptp->clock = STM32_TIMCLK2;
  203bd6:	6085      	str	r5, [r0, #8]
  203bd8:	e7ce      	b.n	203b78 <gpt_lld_start+0x8>
      rccEnableTIM6(FALSE);
  203bda:	4b0d      	ldr	r3, [pc, #52]	; (203c10 <gpt_lld_start+0xa0>)
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  203bdc:	f44f 0480 	mov.w	r4, #4194304	; 0x400000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  203be0:	4a0c      	ldr	r2, [pc, #48]	; (203c14 <gpt_lld_start+0xa4>)
      rccResetTIM6();
  203be2:	2700      	movs	r7, #0
      rccEnableTIM6(FALSE);
  203be4:	6c19      	ldr	r1, [r3, #64]	; 0x40
  203be6:	2670      	movs	r6, #112	; 0x70
      gptp->clock = STM32_TIMCLK1;
  203be8:	4d0c      	ldr	r5, [pc, #48]	; (203c1c <gpt_lld_start+0xac>)
      rccEnableTIM6(FALSE);
  203bea:	f041 0110 	orr.w	r1, r1, #16
  203bee:	6419      	str	r1, [r3, #64]	; 0x40
      rccResetTIM6();
  203bf0:	6a19      	ldr	r1, [r3, #32]
  203bf2:	f041 0110 	orr.w	r1, r1, #16
  203bf6:	6219      	str	r1, [r3, #32]
  203bf8:	621f      	str	r7, [r3, #32]
  203bfa:	f882 6336 	strb.w	r6, [r2, #822]	; 0x336
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  203bfe:	f8c2 4184 	str.w	r4, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  203c02:	6054      	str	r4, [r2, #4]
      gptp->clock = STM32_TIMCLK1;
  203c04:	6085      	str	r5, [r0, #8]
  203c06:	e7ce      	b.n	203ba6 <gpt_lld_start+0x36>
  203c08:	20000c90 	.word	0x20000c90
  203c0c:	2000080c 	.word	0x2000080c
  203c10:	40023800 	.word	0x40023800
  203c14:	e000e100 	.word	0xe000e100
  203c18:	0cdfe600 	.word	0x0cdfe600
  203c1c:	066ff300 	.word	0x066ff300

00203c20 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  203c20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  203c24:	f002 0903 	and.w	r9, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  203c28:	f3c2 0880 	ubfx	r8, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  203c2c:	f3c2 0cc1 	ubfx	ip, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  203c30:	f3c2 1e41 	ubfx	lr, r2, #5, #2
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  203c34:	2600      	movs	r6, #0
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  203c36:	464f      	mov	r7, r9
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  203c38:	f3c2 12c3 	ubfx	r2, r2, #7, #4
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
  203c3c:	f04f 0a0f 	mov.w	sl, #15
  203c40:	e00e      	b.n	203c60 <_pal_lld_setgroupmode+0x40>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
  203c42:	6a03      	ldr	r3, [r0, #32]
  203c44:	ea23 0404 	bic.w	r4, r3, r4
  203c48:	4325      	orrs	r5, r4
  203c4a:	6205      	str	r5, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
  203c4c:	0849      	lsrs	r1, r1, #1
  203c4e:	d047      	beq.n	203ce0 <_pal_lld_setgroupmode+0xc0>
      return;
    otyper <<= 1;
  203c50:	ea4f 0848 	mov.w	r8, r8, lsl #1
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
  203c54:	3601      	adds	r6, #1
    ospeedr <<= 2;
  203c56:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
    pupdr <<= 2;
  203c5a:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
    moder <<= 2;
  203c5e:	00bf      	lsls	r7, r7, #2
    if ((mask & 1) != 0) {
  203c60:	07cb      	lsls	r3, r1, #31
  203c62:	d5f3      	bpl.n	203c4c <_pal_lld_setgroupmode+0x2c>
      m1 = 1 << bit;
  203c64:	2301      	movs	r3, #1
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
  203c66:	6845      	ldr	r5, [r0, #4]
      altrmask = altr << ((bit & 7) * 4);
  203c68:	f006 0407 	and.w	r4, r6, #7
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
  203c6c:	f1b9 0f02 	cmp.w	r9, #2
      m1 = 1 << bit;
  203c70:	fa03 fb06 	lsl.w	fp, r3, r6
      m2 = 3 << (bit * 2);
  203c74:	fa06 f303 	lsl.w	r3, r6, r3
      altrmask = altr << ((bit & 7) * 4);
  203c78:	ea4f 0484 	mov.w	r4, r4, lsl #2
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
  203c7c:	ea25 0b0b 	bic.w	fp, r5, fp
      m2 = 3 << (bit * 2);
  203c80:	f04f 0503 	mov.w	r5, #3
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
  203c84:	ea4b 0b08 	orr.w	fp, fp, r8
      m2 = 3 << (bit * 2);
  203c88:	fa05 f303 	lsl.w	r3, r5, r3
      altrmask = altr << ((bit & 7) * 4);
  203c8c:	fa02 f504 	lsl.w	r5, r2, r4
      m4 = 15 << ((bit & 7) * 4);
  203c90:	fa0a f404 	lsl.w	r4, sl, r4
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
  203c94:	f8c0 b004 	str.w	fp, [r0, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
  203c98:	ea6f 0303 	mvn.w	r3, r3
  203c9c:	f8d0 b008 	ldr.w	fp, [r0, #8]
  203ca0:	ea0b 0b03 	and.w	fp, fp, r3
  203ca4:	ea4b 0b0c 	orr.w	fp, fp, ip
  203ca8:	f8c0 b008 	str.w	fp, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
  203cac:	f8d0 b00c 	ldr.w	fp, [r0, #12]
  203cb0:	ea03 0b0b 	and.w	fp, r3, fp
  203cb4:	ea4b 0b0e 	orr.w	fp, fp, lr
  203cb8:	f8c0 b00c 	str.w	fp, [r0, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
  203cbc:	d012      	beq.n	203ce4 <_pal_lld_setgroupmode+0xc4>
        port->MODER   = (port->MODER & ~m2) | moder;
  203cbe:	f8d0 b000 	ldr.w	fp, [r0]
        if (bit < 8)
  203cc2:	2e07      	cmp	r6, #7
        port->MODER   = (port->MODER & ~m2) | moder;
  203cc4:	ea03 030b 	and.w	r3, r3, fp
  203cc8:	ea43 0307 	orr.w	r3, r3, r7
  203ccc:	6003      	str	r3, [r0, #0]
        if (bit < 8)
  203cce:	d9b8      	bls.n	203c42 <_pal_lld_setgroupmode+0x22>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
  203cd0:	6a43      	ldr	r3, [r0, #36]	; 0x24
    if (!mask)
  203cd2:	0849      	lsrs	r1, r1, #1
          port->AFRH = (port->AFRH & ~m4) | altrmask;
  203cd4:	ea23 0404 	bic.w	r4, r3, r4
  203cd8:	ea45 0504 	orr.w	r5, r5, r4
  203cdc:	6245      	str	r5, [r0, #36]	; 0x24
    if (!mask)
  203cde:	d1b7      	bne.n	203c50 <_pal_lld_setgroupmode+0x30>
  203ce0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (bit < 8)
  203ce4:	2e07      	cmp	r6, #7
  203ce6:	d80a      	bhi.n	203cfe <_pal_lld_setgroupmode+0xde>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
  203ce8:	f8d0 b020 	ldr.w	fp, [r0, #32]
  203cec:	ea2b 0404 	bic.w	r4, fp, r4
  203cf0:	4325      	orrs	r5, r4
  203cf2:	6205      	str	r5, [r0, #32]
        port->MODER   = (port->MODER & ~m2) | moder;
  203cf4:	6804      	ldr	r4, [r0, #0]
  203cf6:	4023      	ands	r3, r4
  203cf8:	433b      	orrs	r3, r7
  203cfa:	6003      	str	r3, [r0, #0]
  203cfc:	e7a6      	b.n	203c4c <_pal_lld_setgroupmode+0x2c>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
  203cfe:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
  203d02:	ea2b 0404 	bic.w	r4, fp, r4
  203d06:	4325      	orrs	r5, r4
  203d08:	6245      	str	r5, [r0, #36]	; 0x24
  203d0a:	e7f3      	b.n	203cf4 <_pal_lld_setgroupmode+0xd4>
  203d0c:	0000      	movs	r0, r0
	...

00203d10 <GPT_CB>:
{
  203d10:	b570      	push	{r4, r5, r6, lr}
    prevDistance = currentDistance;
  203d12:	4c13      	ldr	r4, [pc, #76]	; (203d60 <GPT_CB+0x50>)
  203d14:	4a13      	ldr	r2, [pc, #76]	; (203d64 <GPT_CB+0x54>)
 * @brief       Counts encoder turnovers
 * @return      Number of turnovers
 */
encoderTurnoverValue_t get_turnover(void)
{
    return((float)encoderTicks/ENC_MAX_TICK);
  203d16:	4b14      	ldr	r3, [pc, #80]	; (203d68 <GPT_CB+0x58>)
  203d18:	6825      	ldr	r5, [r4, #0]
  203d1a:	6818      	ldr	r0, [r3, #0]
  203d1c:	6015      	str	r5, [r2, #0]
  203d1e:	f7fd f891 	bl	200e44 <__aeabi_i2f>
  203d22:	4912      	ldr	r1, [pc, #72]	; (203d6c <GPT_CB+0x5c>)
  203d24:	f7fd f996 	bl	201054 <__aeabi_fdiv>
    diffDistance = currentDistance - prevDistance;
  203d28:	4e11      	ldr	r6, [pc, #68]	; (203d70 <GPT_CB+0x60>)
    float distance = get_turnover()*(2*M_PI*RADIUS)*TRANSMITION_RATIO;
  203d2a:	f7fc fc4b 	bl	2005c4 <__aeabi_f2d>
  203d2e:	a30a      	add	r3, pc, #40	; (adr r3, 203d58 <GPT_CB+0x48>)
  203d30:	e9d3 2300 	ldrd	r2, r3, [r3]
  203d34:	f7fc fc9a 	bl	20066c <__aeabi_dmul>
  203d38:	2200      	movs	r2, #0
  203d3a:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
  203d3e:	f7fc fc95 	bl	20066c <__aeabi_dmul>
  203d42:	f7fc ff75 	bl	200c30 <__aeabi_d2f>
    diffDistance = currentDistance - prevDistance;
  203d46:	4629      	mov	r1, r5
    currentDistance = get_distance();
  203d48:	6020      	str	r0, [r4, #0]
    diffDistance = currentDistance - prevDistance;
  203d4a:	f7fc ffc5 	bl	200cd8 <__aeabi_fsub>
  203d4e:	6030      	str	r0, [r6, #0]
  203d50:	bd70      	pop	{r4, r5, r6, pc}
  203d52:	bf00      	nop
  203d54:	f3af 8000 	nop.w
  203d58:	4d659f8a 	.word	0x4d659f8a
  203d5c:	3ffa2357 	.word	0x3ffa2357
  203d60:	20000dec 	.word	0x20000dec
  203d64:	20000ea4 	.word	0x20000ea4
  203d68:	20000e80 	.word	0x20000e80
  203d6c:	43b40000 	.word	0x43b40000
  203d70:	20000df4 	.word	0x20000df4
	...

00203d80 <lldSetPowerMotor>:
bool almost_turned = false;


void lldSetPowerMotor(int8_t powerPrct) //WORKING     (  aaaa)
{
    powerPrct = CLIP_VALUE(powerPrct,-100,100);
  203d80:	f110 0f64 	cmn.w	r0, #100	; 0x64
{
  203d84:	b538      	push	{r3, r4, r5, lr}
    powerPrct = CLIP_VALUE(powerPrct,-100,100);
  203d86:	db15      	blt.n	203db4 <lldSetPowerMotor+0x34>
  203d88:	2864      	cmp	r0, #100	; 0x64
  203d8a:	bfa8      	it	ge
  203d8c:	2064      	movge	r0, #100	; 0x64
  203d8e:	4604      	mov	r4, r0
    if(powerPrct == 0)
  203d90:	b300      	cbz	r0, 203dd4 <lldSetPowerMotor+0x54>
    {
        pwmEnableChannel( PWMDriver1, PWM1_CHANNEL_P9, 6000 - 160);
    }
    else if(powerPrct > 0 && powerPrct <= 100)
  203d92:	b2c3      	uxtb	r3, r0
  203d94:	1e5a      	subs	r2, r3, #1
  203d96:	2a63      	cmp	r2, #99	; 0x63
  203d98:	d824      	bhi.n	203de4 <lldSetPowerMotor+0x64>
    {
        pwmEnableChannel( PWMDriver1, PWM1_CHANNEL_P9, 6000+20*powerPrct - 160 );
  203d9a:	f241 63d0 	movw	r3, #5840	; 0x16d0
  203d9e:	2214      	movs	r2, #20
  203da0:	2100      	movs	r1, #0
  203da2:	481c      	ldr	r0, [pc, #112]	; (203e14 <lldSetPowerMotor+0x94>)
  203da4:	fb02 3204 	mla	r2, r2, r4, r3
  203da8:	f7fe fc3a 	bl	202620 <pwmEnableChannel>
        turn_dir = true;
  203dac:	4b1a      	ldr	r3, [pc, #104]	; (203e18 <lldSetPowerMotor+0x98>)
  203dae:	2201      	movs	r2, #1
  203db0:	701a      	strb	r2, [r3, #0]
  203db2:	bd38      	pop	{r3, r4, r5, pc}
    powerPrct = CLIP_VALUE(powerPrct,-100,100);
  203db4:	f06f 0463 	mvn.w	r4, #99	; 0x63
    }
    else if(powerPrct < 0 && powerPrct >= -100)
    {
        if(turn_dir == true)
  203db8:	4b17      	ldr	r3, [pc, #92]	; (203e18 <lldSetPowerMotor+0x98>)
  203dba:	781a      	ldrb	r2, [r3, #0]
  203dbc:	b9aa      	cbnz	r2, 203dea <lldSetPowerMotor+0x6a>
            pwmEnableChannel( PWMDriver1, PWM1_CHANNEL_P9, 6000-1000 - 160);
            chThdSleepMilliseconds(10);
            pwmEnableChannel( PWMDriver1, PWM1_CHANNEL_P9, 6000 - 160);
            chThdSleepMilliseconds(10);
        }
        pwmEnableChannel( PWMDriver1, PWM1_CHANNEL_P9, 6000+20*powerPrct - 160 );
  203dbe:	f241 63d0 	movw	r3, #5840	; 0x16d0
  203dc2:	2214      	movs	r2, #20
  203dc4:	2100      	movs	r1, #0
  203dc6:	4813      	ldr	r0, [pc, #76]	; (203e14 <lldSetPowerMotor+0x94>)
  203dc8:	fb02 3204 	mla	r2, r2, r4, r3
    }

}
  203dcc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        pwmEnableChannel( PWMDriver1, PWM1_CHANNEL_P9, 6000+20*powerPrct - 160 );
  203dd0:	f7fe bc26 	b.w	202620 <pwmEnableChannel>
        pwmEnableChannel( PWMDriver1, PWM1_CHANNEL_P9, 6000 - 160);
  203dd4:	4601      	mov	r1, r0
  203dd6:	f241 62d0 	movw	r2, #5840	; 0x16d0
  203dda:	480e      	ldr	r0, [pc, #56]	; (203e14 <lldSetPowerMotor+0x94>)
}
  203ddc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        pwmEnableChannel( PWMDriver1, PWM1_CHANNEL_P9, 6000 - 160);
  203de0:	f7fe bc1e 	b.w	202620 <pwmEnableChannel>
    else if(powerPrct < 0 && powerPrct >= -100)
  203de4:	2b00      	cmp	r3, #0
  203de6:	d1e7      	bne.n	203db8 <lldSetPowerMotor+0x38>
  203de8:	bd38      	pop	{r3, r4, r5, pc}
            turn_dir = false;
  203dea:	2500      	movs	r5, #0
            pwmEnableChannel( PWMDriver1, PWM1_CHANNEL_P9, 6000-1000 - 160);
  203dec:	f241 22e8 	movw	r2, #4840	; 0x12e8
  203df0:	4808      	ldr	r0, [pc, #32]	; (203e14 <lldSetPowerMotor+0x94>)
  203df2:	4629      	mov	r1, r5
            turn_dir = false;
  203df4:	701d      	strb	r5, [r3, #0]
            pwmEnableChannel( PWMDriver1, PWM1_CHANNEL_P9, 6000-1000 - 160);
  203df6:	f7fe fc13 	bl	202620 <pwmEnableChannel>
            chThdSleepMilliseconds(10);
  203dfa:	200a      	movs	r0, #10
  203dfc:	f7fe fff8 	bl	202df0 <chThdSleep>
            pwmEnableChannel( PWMDriver1, PWM1_CHANNEL_P9, 6000 - 160);
  203e00:	4629      	mov	r1, r5
  203e02:	f241 62d0 	movw	r2, #5840	; 0x16d0
  203e06:	4803      	ldr	r0, [pc, #12]	; (203e14 <lldSetPowerMotor+0x94>)
  203e08:	f7fe fc0a 	bl	202620 <pwmEnableChannel>
            chThdSleepMilliseconds(10);
  203e0c:	200a      	movs	r0, #10
  203e0e:	f7fe ffef 	bl	202df0 <chThdSleep>
  203e12:	e7d4      	b.n	203dbe <lldSetPowerMotor+0x3e>
  203e14:	20000cb4 	.word	0x20000cb4
  203e18:	20000eac 	.word	0x20000eac
  203e1c:	00000000 	.word	0x00000000

00203e20 <TurnMotor.part.1>:
    if(turn_enable == false)
    {
        return 0;
    }

    now_err = turn_to - get_wheel_pos();
  203e20:	4b7e      	ldr	r3, [pc, #504]	; (20401c <TurnMotor.part.1+0x1fc>)
int8_t TurnMotor(void)
  203e22:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    now_err = turn_to - get_wheel_pos();
  203e26:	f8b3 9000 	ldrh.w	r9, [r3]
int8_t TurnMotor(void)
  203e2a:	b083      	sub	sp, #12
    now_err = turn_to - get_wheel_pos();
  203e2c:	f000 fef8 	bl	204c20 <get_wheel_pos>
    P = kp*now_err;
    D = kd*(now_err - prev_err);
  203e30:	f8df b220 	ldr.w	fp, [pc, #544]	; 204054 <TurnMotor.part.1+0x234>
    now_err = turn_to - get_wheel_pos();
  203e34:	eba9 0900 	sub.w	r9, r9, r0
    P = kp*now_err;
  203e38:	f8df a21c 	ldr.w	sl, [pc, #540]	; 204058 <TurnMotor.part.1+0x238>
    I += ki*now_err;
  203e3c:	4c78      	ldr	r4, [pc, #480]	; (204020 <TurnMotor.part.1+0x200>)
    now_err = turn_to - get_wheel_pos();
  203e3e:	fa0f f989 	sxth.w	r9, r9
    P = kp*now_err;
  203e42:	4648      	mov	r0, r9
  203e44:	f7fc fffe 	bl	200e44 <__aeabi_i2f>
  203e48:	4b76      	ldr	r3, [pc, #472]	; (204024 <TurnMotor.part.1+0x204>)
  203e4a:	4606      	mov	r6, r0
  203e4c:	6819      	ldr	r1, [r3, #0]
  203e4e:	f7fd f84d 	bl	200eec <__aeabi_fmul>
  203e52:	4605      	mov	r5, r0
    D = kd*(now_err - prev_err);
  203e54:	f9bb 0000 	ldrsh.w	r0, [fp]
    P = kp*now_err;
  203e58:	f8ca 5000 	str.w	r5, [sl]
    D = kd*(now_err - prev_err);
  203e5c:	eba9 0000 	sub.w	r0, r9, r0
  203e60:	f7fc fff0 	bl	200e44 <__aeabi_i2f>
  203e64:	4b70      	ldr	r3, [pc, #448]	; (204028 <TurnMotor.part.1+0x208>)
  203e66:	6819      	ldr	r1, [r3, #0]
  203e68:	f7fd f840 	bl	200eec <__aeabi_fmul>
    I += ki*now_err;
  203e6c:	4b6f      	ldr	r3, [pc, #444]	; (20402c <TurnMotor.part.1+0x20c>)
    D = kd*(now_err - prev_err);
  203e6e:	4a70      	ldr	r2, [pc, #448]	; (204030 <TurnMotor.part.1+0x210>)
  203e70:	4680      	mov	r8, r0
    I += ki*now_err;
  203e72:	6819      	ldr	r1, [r3, #0]
  203e74:	4630      	mov	r0, r6
    D = kd*(now_err - prev_err);
  203e76:	f8c2 8000 	str.w	r8, [r2]
    I += ki*now_err;
  203e7a:	f7fd f837 	bl	200eec <__aeabi_fmul>
  203e7e:	f7fc fba1 	bl	2005c4 <__aeabi_f2d>
  203e82:	e9d4 2300 	ldrd	r2, r3, [r4]
  203e86:	e9cd 0100 	strd	r0, r1, [sp]
  203e8a:	f7fc fa3d 	bl	200308 <__adddf3>
  203e8e:	4606      	mov	r6, r0
  203e90:	460f      	mov	r7, r1
    prev_err = now_err;
  203e92:	f8ab 9000 	strh.w	r9, [fp]
    I += ki*now_err;
  203e96:	e9c4 6700 	strd	r6, r7, [r4]
    if(abs(now_err)<1)
  203e9a:	f1b9 0f00 	cmp.w	r9, #0
  203e9e:	d17a      	bne.n	203f96 <TurnMotor.part.1+0x176>
    {
        almost_turned = true;
  203ea0:	f8df 91b8 	ldr.w	r9, [pc, #440]	; 20405c <TurnMotor.part.1+0x23c>
  203ea4:	2301      	movs	r3, #1
  203ea6:	f889 3000 	strb.w	r3, [r9]
    }
    if(almost_turned == true)
    {
        I = I-I/40-ki*now_err;
  203eaa:	2200      	movs	r2, #0
  203eac:	4b61      	ldr	r3, [pc, #388]	; (204034 <TurnMotor.part.1+0x214>)
  203eae:	4630      	mov	r0, r6
  203eb0:	4639      	mov	r1, r7
  203eb2:	f7fc fd05 	bl	2008c0 <__aeabi_ddiv>
  203eb6:	4602      	mov	r2, r0
  203eb8:	460b      	mov	r3, r1
  203eba:	4630      	mov	r0, r6
  203ebc:	4639      	mov	r1, r7
  203ebe:	f7fc fa21 	bl	200304 <__aeabi_dsub>
  203ec2:	e9dd 2300 	ldrd	r2, r3, [sp]
  203ec6:	f7fc fa1d 	bl	200304 <__aeabi_dsub>
  203eca:	4606      	mov	r6, r0
  203ecc:	460f      	mov	r7, r1
        if(I<5 && I>-5)
  203ece:	2200      	movs	r2, #0
  203ed0:	4b59      	ldr	r3, [pc, #356]	; (204038 <TurnMotor.part.1+0x218>)
        I = I-I/40-ki*now_err;
  203ed2:	e9c4 6700 	strd	r6, r7, [r4]
        if(I<5 && I>-5)
  203ed6:	f7fc fe3b 	bl	200b50 <__aeabi_dcmplt>
  203eda:	2800      	cmp	r0, #0
  203edc:	d167      	bne.n	203fae <TurnMotor.part.1+0x18e>
  203ede:	4641      	mov	r1, r8
  203ee0:	4628      	mov	r0, r5
  203ee2:	f7fc fefb 	bl	200cdc <__addsf3>
  203ee6:	4d55      	ldr	r5, [pc, #340]	; (20403c <TurnMotor.part.1+0x21c>)
  203ee8:	f7fc fb6c 	bl	2005c4 <__aeabi_f2d>
  203eec:	4632      	mov	r2, r6
  203eee:	463b      	mov	r3, r7
  203ef0:	f7fc fa0a 	bl	200308 <__adddf3>
  203ef4:	f7fc fe54 	bl	200ba0 <__aeabi_d2iz>
  203ef8:	b200      	sxth	r0, r0
            I = 0;
            P = 0;
            D = 0;
        }
    }
    PID = P+D+I;
  203efa:	4e51      	ldr	r6, [pc, #324]	; (204040 <TurnMotor.part.1+0x220>)
    CurrP = kpcur*CLIP_VALUE(abs(get_current()/1000)-11,0,100);
  203efc:	4c51      	ldr	r4, [pc, #324]	; (204044 <TurnMotor.part.1+0x224>)
    PID = P+D+I;
  203efe:	8030      	strh	r0, [r6, #0]
    CurrP = kpcur*CLIP_VALUE(abs(get_current()/1000)-11,0,100);
  203f00:	f000 febe 	bl	204c80 <get_current>
  203f04:	fb84 2300 	smull	r2, r3, r4, r0
  203f08:	17c0      	asrs	r0, r0, #31
  203f0a:	ebc0 10a3 	rsb	r0, r0, r3, asr #6
  203f0e:	b200      	sxth	r0, r0
  203f10:	2800      	cmp	r0, #0
  203f12:	bfb8      	it	lt
  203f14:	4240      	neglt	r0, r0
  203f16:	280a      	cmp	r0, #10
  203f18:	dc65      	bgt.n	203fe6 <TurnMotor.part.1+0x1c6>
  203f1a:	2000      	movs	r0, #0
  203f1c:	4604      	mov	r4, r0
    CurrI += kicur*CurrP/kpcur;
  203f1e:	6829      	ldr	r1, [r5, #0]
  203f20:	f7fc fedc 	bl	200cdc <__addsf3>
    Curr = (CurrP+CurrI)*abs(PID)/PID;
  203f24:	f9b6 7000 	ldrsh.w	r7, [r6]
    CurrI += kicur*CurrP/kpcur;
  203f28:	6028      	str	r0, [r5, #0]
    Curr = (CurrP+CurrI)*abs(PID)/PID;
  203f2a:	4621      	mov	r1, r4
  203f2c:	ea87 75e7 	eor.w	r5, r7, r7, asr #31
  203f30:	f7fc fed4 	bl	200cdc <__addsf3>
  203f34:	4680      	mov	r8, r0
  203f36:	eba5 75e7 	sub.w	r5, r5, r7, asr #31
    PID = PID - CLIP_VALUE(Curr,(-1)*abs(PID),abs(PID));
  203f3a:	b2bc      	uxth	r4, r7
    Curr = (CurrP+CurrI)*abs(PID)/PID;
  203f3c:	4628      	mov	r0, r5
  203f3e:	f7fc ff81 	bl	200e44 <__aeabi_i2f>
  203f42:	4601      	mov	r1, r0
  203f44:	4640      	mov	r0, r8
  203f46:	f7fc ffd1 	bl	200eec <__aeabi_fmul>
  203f4a:	4680      	mov	r8, r0
  203f4c:	4638      	mov	r0, r7
  203f4e:	f7fc ff79 	bl	200e44 <__aeabi_i2f>
  203f52:	4601      	mov	r1, r0
  203f54:	4640      	mov	r0, r8
  203f56:	f7fd f87d 	bl	201054 <__aeabi_fdiv>
  203f5a:	f7fd f98d 	bl	201278 <__aeabi_f2iz>
    PID = PID - CLIP_VALUE(Curr,(-1)*abs(PID),abs(PID));
  203f5e:	426b      	negs	r3, r5
  203f60:	b200      	sxth	r0, r0
  203f62:	4298      	cmp	r0, r3
  203f64:	da1e      	bge.n	203fa4 <TurnMotor.part.1+0x184>
  203f66:	b29b      	uxth	r3, r3
  203f68:	1ae3      	subs	r3, r4, r3
  203f6a:	b29b      	uxth	r3, r3
  203f6c:	b21a      	sxth	r2, r3

    lldSetPowerMotor(PID - CLIP_VALUE(Curr,(-1)*abs(PID),abs(PID)));
  203f6e:	b2db      	uxtb	r3, r3
  203f70:	ea82 71e2 	eor.w	r1, r2, r2, asr #31
    PID = PID - CLIP_VALUE(Curr,(-1)*abs(PID),abs(PID));
  203f74:	8032      	strh	r2, [r6, #0]
    lldSetPowerMotor(PID - CLIP_VALUE(Curr,(-1)*abs(PID),abs(PID)));
  203f76:	eba1 71e2 	sub.w	r1, r1, r2, asr #31
  203f7a:	424a      	negs	r2, r1
  203f7c:	4290      	cmp	r0, r2
  203f7e:	db30      	blt.n	203fe2 <TurnMotor.part.1+0x1c2>
  203f80:	4288      	cmp	r0, r1
  203f82:	bfa8      	it	ge
  203f84:	4608      	movge	r0, r1
  203f86:	b2c0      	uxtb	r0, r0
  203f88:	1a18      	subs	r0, r3, r0
  203f8a:	b240      	sxtb	r0, r0
  203f8c:	f7ff fef8 	bl	203d80 <lldSetPowerMotor>
}
  203f90:	b003      	add	sp, #12
  203f92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(almost_turned == true)
  203f96:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 20405c <TurnMotor.part.1+0x23c>
  203f9a:	f899 3000 	ldrb.w	r3, [r9]
  203f9e:	2b00      	cmp	r3, #0
  203fa0:	d09d      	beq.n	203ede <TurnMotor.part.1+0xbe>
  203fa2:	e782      	b.n	203eaa <TurnMotor.part.1+0x8a>
    PID = PID - CLIP_VALUE(Curr,(-1)*abs(PID),abs(PID));
  203fa4:	4285      	cmp	r5, r0
  203fa6:	bfa8      	it	ge
  203fa8:	4605      	movge	r5, r0
  203faa:	b2ab      	uxth	r3, r5
  203fac:	e7dc      	b.n	203f68 <TurnMotor.part.1+0x148>
        if(I<5 && I>-5)
  203fae:	2200      	movs	r2, #0
  203fb0:	4b25      	ldr	r3, [pc, #148]	; (204048 <TurnMotor.part.1+0x228>)
  203fb2:	4630      	mov	r0, r6
  203fb4:	4639      	mov	r1, r7
  203fb6:	f7fc fde9 	bl	200b8c <__aeabi_dcmpgt>
  203fba:	2800      	cmp	r0, #0
  203fbc:	d08f      	beq.n	203ede <TurnMotor.part.1+0xbe>
            turned = true;
  203fbe:	4e23      	ldr	r6, [pc, #140]	; (20404c <TurnMotor.part.1+0x22c>)
  203fc0:	2701      	movs	r7, #1
            CurrI = 0;
  203fc2:	2100      	movs	r1, #0
            almost_turned = false;
  203fc4:	2000      	movs	r0, #0
            turned = true;
  203fc6:	7037      	strb	r7, [r6, #0]
            I = 0;
  203fc8:	2200      	movs	r2, #0
            CurrI = 0;
  203fca:	4d1c      	ldr	r5, [pc, #112]	; (20403c <TurnMotor.part.1+0x21c>)
            I = 0;
  203fcc:	2300      	movs	r3, #0
            D = 0;
  203fce:	4e18      	ldr	r6, [pc, #96]	; (204030 <TurnMotor.part.1+0x210>)
            almost_turned = false;
  203fd0:	f889 0000 	strb.w	r0, [r9]
            CurrI = 0;
  203fd4:	6029      	str	r1, [r5, #0]
            P = 0;
  203fd6:	f8ca 1000 	str.w	r1, [sl]
            D = 0;
  203fda:	6031      	str	r1, [r6, #0]
            I = 0;
  203fdc:	e9c4 2300 	strd	r2, r3, [r4]
  203fe0:	e78b      	b.n	203efa <TurnMotor.part.1+0xda>
    lldSetPowerMotor(PID - CLIP_VALUE(Curr,(-1)*abs(PID),abs(PID)));
  203fe2:	b2d0      	uxtb	r0, r2
  203fe4:	e7d0      	b.n	203f88 <TurnMotor.part.1+0x168>
    CurrP = kpcur*CLIP_VALUE(abs(get_current()/1000)-11,0,100);
  203fe6:	f000 fe4b 	bl	204c80 <get_current>
  203fea:	f000 fe49 	bl	204c80 <get_current>
  203fee:	fb84 3400 	smull	r3, r4, r4, r0
  203ff2:	17c0      	asrs	r0, r0, #31
  203ff4:	ebc0 10a4 	rsb	r0, r0, r4, asr #6
  203ff8:	b200      	sxth	r0, r0
  203ffa:	2800      	cmp	r0, #0
  203ffc:	bfb8      	it	lt
  203ffe:	4240      	neglt	r0, r0
  204000:	380b      	subs	r0, #11
  204002:	f7fc ff1f 	bl	200e44 <__aeabi_i2f>
  204006:	4912      	ldr	r1, [pc, #72]	; (204050 <TurnMotor.part.1+0x230>)
  204008:	f7fc ff70 	bl	200eec <__aeabi_fmul>
  20400c:	4910      	ldr	r1, [pc, #64]	; (204050 <TurnMotor.part.1+0x230>)
  20400e:	4604      	mov	r4, r0
  204010:	f7fc ff6c 	bl	200eec <__aeabi_fmul>
  204014:	490e      	ldr	r1, [pc, #56]	; (204050 <TurnMotor.part.1+0x230>)
  204016:	f7fd f81d 	bl	201054 <__aeabi_fdiv>
  20401a:	e780      	b.n	203f1e <TurnMotor.part.1+0xfe>
  20401c:	20000eae 	.word	0x20000eae
  204020:	20000ca0 	.word	0x20000ca0
  204024:	20000ea0 	.word	0x20000ea0
  204028:	20000e98 	.word	0x20000e98
  20402c:	20000e9c 	.word	0x20000e9c
  204030:	20000c60 	.word	0x20000c60
  204034:	40440000 	.word	0x40440000
  204038:	40140000 	.word	0x40140000
  20403c:	20000c5c 	.word	0x20000c5c
  204040:	20000cac 	.word	0x20000cac
  204044:	10624dd3 	.word	0x10624dd3
  204048:	c0140000 	.word	0xc0140000
  20404c:	20000eb0 	.word	0x20000eb0
  204050:	41700000 	.word	0x41700000
  204054:	20000ea8 	.word	0x20000ea8
  204058:	20000ca8 	.word	0x20000ca8
  20405c:	20000d74 	.word	0x20000d74

00204060 <transm>:
  PWMFiltrationCounter++;
  204060:	4976      	ldr	r1, [pc, #472]	; (20423c <transm+0x1dc>)
  204062:	4b77      	ldr	r3, [pc, #476]	; (204240 <transm+0x1e0>)
  204064:	880a      	ldrh	r2, [r1, #0]
  204066:	681b      	ldr	r3, [r3, #0]
  204068:	3201      	adds	r2, #1
  PWMAverage += commonADC1UnitGetValue(0) & 0b1111111111110000; //0xfffc
  20406a:	f023 030f 	bic.w	r3, r3, #15
  PWMFiltrationCounter++;
  20406e:	b212      	sxth	r2, r2
  PWMAverage += commonADC1UnitGetValue(0) & 0b1111111111110000; //0xfffc
  204070:	b29b      	uxth	r3, r3
  if (PWMFiltrationCounter == 20)
  204072:	2a14      	cmp	r2, #20
{
  204074:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  PWMAverage += commonADC1UnitGetValue(0) & 0b1111111111110000; //0xfffc
  204078:	4c72      	ldr	r4, [pc, #456]	; (204244 <transm+0x1e4>)
  PWMFiltrationCounter++;
  20407a:	800a      	strh	r2, [r1, #0]
  PWMAverage += commonADC1UnitGetValue(0) & 0b1111111111110000; //0xfffc
  20407c:	6820      	ldr	r0, [r4, #0]
  20407e:	4403      	add	r3, r0
  204080:	6023      	str	r3, [r4, #0]
  if (PWMFiltrationCounter == 20)
  204082:	d001      	beq.n	204088 <transm+0x28>
  204084:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      PWMAverage /= 20;
  204088:	486f      	ldr	r0, [pc, #444]	; (204248 <transm+0x1e8>)
  20408a:	17df      	asrs	r7, r3, #31
    if ( tfconf.k > 0 )
  20408c:	f8df 81d0 	ldr.w	r8, [pc, #464]	; 204260 <transm+0x200>
      PWMFiltrationCounter = 0;
  204090:	2200      	movs	r2, #0
      PWMAverage /= 20;
  204092:	fb80 0303 	smull	r0, r3, r0, r3
  204096:	f04f 0900 	mov.w	r9, #0
  20409a:	f8d8 6000 	ldr.w	r6, [r8]
  20409e:	ebc7 07e3 	rsb	r7, r7, r3, asr #3
      PWMFiltrationCounter = 0;
  2040a2:	800a      	strh	r2, [r1, #0]
  2040a4:	4630      	mov	r0, r6
  2040a6:	4649      	mov	r1, r9
      PWMAverage /= 20;
  2040a8:	6027      	str	r7, [r4, #0]
  2040aa:	f7fd f8db 	bl	201264 <__aeabi_fcmpgt>
  2040ae:	2800      	cmp	r0, #0
  2040b0:	f000 8087 	beq.w	2041c2 <transm+0x162>
  return fuzzyCurrent;
  2040b4:	4d65      	ldr	r5, [pc, #404]	; (20424c <transm+0x1ec>)
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2040b6:	23c8      	movs	r3, #200	; 0xc8
         tfconf.input = 1;
  2040b8:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
                 pidCtx.err = controlCurrent;
  2040bc:	4f64      	ldr	r7, [pc, #400]	; (204250 <transm+0x1f0>)
         currentNow = map((currentNow-zeroPoint), -2048, 2048, -100, 100); // 100 - 4.8 A
  2040be:	882a      	ldrh	r2, [r5, #0]
         tfconf.input = 1;
  2040c0:	f8c8 1004 	str.w	r1, [r8, #4]
         currentNow = map((currentNow-zeroPoint), -2048, 2048, -100, 100); // 100 - 4.8 A
  2040c4:	f5a2 6200 	sub.w	r2, r2, #2048	; 0x800
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2040c8:	b212      	sxth	r2, r2
  2040ca:	f502 6200 	add.w	r2, r2, #2048	; 0x800
  2040ce:	fb03 f302 	mul.w	r3, r3, r2
  2040d2:	2b00      	cmp	r3, #0
  2040d4:	bfb8      	it	lt
  2040d6:	f603 73ff 	addwlt	r3, r3, #4095	; 0xfff
  2040da:	1318      	asrs	r0, r3, #12
         currentNow = map((currentNow-zeroPoint), -2048, 2048, -100, 100); // 100 - 4.8 A
  2040dc:	4b5d      	ldr	r3, [pc, #372]	; (204254 <transm+0x1f4>)
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  2040de:	3864      	subs	r0, #100	; 0x64
  2040e0:	b200      	sxth	r0, r0
         currentNow = map((currentNow-zeroPoint), -2048, 2048, -100, 100); // 100 - 4.8 A
  2040e2:	8018      	strh	r0, [r3, #0]
         error = (outp - currentNow);
  2040e4:	f7fc feae 	bl	200e44 <__aeabi_i2f>
  2040e8:	4601      	mov	r1, r0
  2040ea:	4630      	mov	r0, r6
  2040ec:	f7fc fdf4 	bl	200cd8 <__aeabi_fsub>
  2040f0:	f7fd f8c2 	bl	201278 <__aeabi_f2iz>
                 pidCtx.err = controlCurrent;
  2040f4:	f06f 0363 	mvn.w	r3, #99	; 0x63
         controlCurrent = constrain(error, -100, 100);
  2040f8:	b200      	sxth	r0, r0
                 pidCtx.err = controlCurrent;
  2040fa:	2864      	cmp	r0, #100	; 0x64
  2040fc:	bfa8      	it	ge
  2040fe:	2064      	movge	r0, #100	; 0x64
  204100:	4298      	cmp	r0, r3
  204102:	bfb8      	it	lt
  204104:	4618      	movlt	r0, r3
  204106:	f7fc fe9d 	bl	200e44 <__aeabi_i2f>

controllerRensponse_t PIControlResponse ( PIControllerContext_t *ctx )
{
    controllerRensponse_t control = 0;
//    if( (ctx->err < ctx->integZone_abs) && (ctx->err > -ctx->integZone_abs))
        ctx->integrSum += ctx->ki * ctx->err;
  20410a:	6879      	ldr	r1, [r7, #4]
                 pidCtx.err = controlCurrent;
  20410c:	6138      	str	r0, [r7, #16]
  20410e:	4606      	mov	r6, r0
        ctx->integrSum += ctx->ki * ctx->err;
  204110:	f7fc feec 	bl	200eec <__aeabi_fmul>
  204114:	6979      	ldr	r1, [r7, #20]
  204116:	f7fc fde1 	bl	200cdc <__addsf3>
//    else
//        ctx->integrSum = 0;
    /* Symmetric limits */
    ctx->integrSum = constrain( ctx->integrSum, -ctx->integrLimit, ctx->integrLimit );
  20411a:	f8d7 900c 	ldr.w	r9, [r7, #12]
        ctx->integrSum += ctx->ki * ctx->err;
  20411e:	4682      	mov	sl, r0
    ctx->integrSum = constrain( ctx->integrSum, -ctx->integrLimit, ctx->integrLimit );
  204120:	f109 4800 	add.w	r8, r9, #2147483648	; 0x80000000
  204124:	4641      	mov	r1, r8
  204126:	f7fd f87f 	bl	201228 <__aeabi_fcmplt>
  20412a:	b930      	cbnz	r0, 20413a <transm+0xda>
  20412c:	4649      	mov	r1, r9
  20412e:	4650      	mov	r0, sl
  204130:	f7fd f898 	bl	201264 <__aeabi_fcmpgt>
  204134:	2800      	cmp	r0, #0
  204136:	d056      	beq.n	2041e6 <transm+0x186>
  204138:	46c8      	mov	r8, r9

    control = ctx->kp * ctx->err +
                ctx->integrSum +
                ctx->kd * (ctx->err - ctx->prevErr);
  20413a:	69b9      	ldr	r1, [r7, #24]
  20413c:	4630      	mov	r0, r6
    ctx->integrSum = constrain( ctx->integrSum, -ctx->integrLimit, ctx->integrLimit );
  20413e:	f8c7 8014 	str.w	r8, [r7, #20]
                ctx->kd * (ctx->err - ctx->prevErr);
  204142:	f7fc fdc9 	bl	200cd8 <__aeabi_fsub>
  204146:	68b9      	ldr	r1, [r7, #8]
  204148:	f7fc fed0 	bl	200eec <__aeabi_fmul>
    control = ctx->kp * ctx->err +
  20414c:	6839      	ldr	r1, [r7, #0]
                ctx->kd * (ctx->err - ctx->prevErr);
  20414e:	4681      	mov	r9, r0
    control = ctx->kp * ctx->err +
  204150:	4630      	mov	r0, r6
  204152:	f7fc fecb 	bl	200eec <__aeabi_fmul>
  204156:	4641      	mov	r1, r8
  204158:	f7fc fdc0 	bl	200cdc <__addsf3>
  20415c:	4601      	mov	r1, r0
  20415e:	4648      	mov	r0, r9
  204160:	f7fc fdbc 	bl	200cdc <__addsf3>

    ctx->prevErr = ctx->err;
  204164:	61be      	str	r6, [r7, #24]
                 Speed = PIControlResponse( &pidCtx );
  204166:	f7fd f887 	bl	201278 <__aeabi_f2iz>
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  20416a:	f241 1194 	movw	r1, #4500	; 0x1194
                 Speed = constrain(Speed,0,1000);
  20416e:	b203      	sxth	r3, r0
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  204170:	f8df c0f0 	ldr.w	ip, [pc, #240]	; 204264 <transm+0x204>
  204174:	f241 567c 	movw	r6, #5500	; 0x157c
         pwmEnableChannel( &PWMD2, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD2, SpeedPWM) );
  204178:	4837      	ldr	r0, [pc, #220]	; (204258 <transm+0x1f8>)
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  20417a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
         pwmEnableChannel( &PWMD2, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD2, SpeedPWM) );
  20417e:	4f37      	ldr	r7, [pc, #220]	; (20425c <transm+0x1fc>)
  204180:	6882      	ldr	r2, [r0, #8]
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  204182:	bfa8      	it	ge
  204184:	f44f 737a 	movge.w	r3, #1000	; 0x3e8
                 SpeedPWM = map(Speed,0,1000,5500,10000);
  204188:	f8df e0dc 	ldr.w	lr, [pc, #220]	; 204268 <transm+0x208>
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  20418c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  204190:	fb13 f301 	smulbb	r3, r3, r1
         pwmEnableChannel( &PWMD2, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD2, SpeedPWM) );
  204194:	2102      	movs	r1, #2
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  204196:	fb8c 8c03 	smull	r8, ip, ip, r3
  20419a:	17db      	asrs	r3, r3, #31
  20419c:	ebc3 13ac 	rsb	r3, r3, ip, asr #6
  2041a0:	441e      	add	r6, r3
  2041a2:	b2b6      	uxth	r6, r6
         pwmEnableChannel( &PWMD2, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD2, SpeedPWM) );
  2041a4:	fb02 f206 	mul.w	r2, r2, r6
                 SpeedPWM = map(Speed,0,1000,5500,10000);
  2041a8:	f8ae 6000 	strh.w	r6, [lr]
         pwmEnableChannel( &PWMD2, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD2, SpeedPWM) );
  2041ac:	fba7 3202 	umull	r3, r2, r7, r2
  2041b0:	0b52      	lsrs	r2, r2, #13
  2041b2:	f7fe fa35 	bl	202620 <pwmEnableChannel>
  2041b6:	6827      	ldr	r7, [r4, #0]
      PWMAverage = 0;
  2041b8:	2300      	movs	r3, #0
      fuzzyCurrent = PWMAverage;
  2041ba:	802f      	strh	r7, [r5, #0]
      PWMAverage = 0;
  2041bc:	6023      	str	r3, [r4, #0]
  2041be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if( tfconf.k < 0 )
  2041c2:	4630      	mov	r0, r6
  2041c4:	4649      	mov	r1, r9
  2041c6:	f7fd f82f 	bl	201228 <__aeabi_fcmplt>
  2041ca:	b970      	cbnz	r0, 2041ea <transm+0x18a>
         pidCtx.err =0;
  2041cc:	4b20      	ldr	r3, [pc, #128]	; (204250 <transm+0x1f0>)
  2041ce:	4d1f      	ldr	r5, [pc, #124]	; (20424c <transm+0x1ec>)
         tfconf.input = 0;
  2041d0:	f8c8 9004 	str.w	r9, [r8, #4]
         tfconf.k = 0;
  2041d4:	f8c8 9000 	str.w	r9, [r8]
         pidCtx.err =0;
  2041d8:	f8c3 9010 	str.w	r9, [r3, #16]
         pidCtx.prevErr =0;
  2041dc:	f8c3 9018 	str.w	r9, [r3, #24]
         pidCtx.integrSum=0;
  2041e0:	f8c3 9014 	str.w	r9, [r3, #20]
  2041e4:	e7e8      	b.n	2041b8 <transm+0x158>
    ctx->integrSum = constrain( ctx->integrSum, -ctx->integrLimit, ctx->integrLimit );
  2041e6:	46d0      	mov	r8, sl
  2041e8:	e7a7      	b.n	20413a <transm+0xda>
        if ( brakeSensorIsPressed() )
  2041ea:	f000 fcf9 	bl	204be0 <brakeSensorIsPressed>
  2041ee:	b188      	cbz	r0, 204214 <transm+0x1b4>
            pwmEnableChannel( &PWMD2, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD2, 6000) );
  2041f0:	4819      	ldr	r0, [pc, #100]	; (204258 <transm+0x1f8>)
  2041f2:	f241 7270 	movw	r2, #6000	; 0x1770
  2041f6:	4b19      	ldr	r3, [pc, #100]	; (20425c <transm+0x1fc>)
  2041f8:	2102      	movs	r1, #2
  2041fa:	6885      	ldr	r5, [r0, #8]
            tfconf.input = 0;
  2041fc:	f8c8 9004 	str.w	r9, [r8, #4]
            pwmEnableChannel( &PWMD2, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD2, 6000) );
  204200:	fb02 f205 	mul.w	r2, r2, r5
  204204:	4d11      	ldr	r5, [pc, #68]	; (20424c <transm+0x1ec>)
  204206:	fba3 3202 	umull	r3, r2, r3, r2
  20420a:	0b52      	lsrs	r2, r2, #13
  20420c:	f7fe fa08 	bl	202620 <pwmEnableChannel>
  204210:	6827      	ldr	r7, [r4, #0]
  204212:	e7d1      	b.n	2041b8 <transm+0x158>
          pidCtx.err =0;
  204214:	4b0e      	ldr	r3, [pc, #56]	; (204250 <transm+0x1f0>)
          pwmEnableChannel( &PWMD2, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD2, 0) );
  204216:	4602      	mov	r2, r0
  204218:	2102      	movs	r1, #2
  20421a:	480f      	ldr	r0, [pc, #60]	; (204258 <transm+0x1f8>)
          tfconf.input = 0;
  20421c:	f8c8 9004 	str.w	r9, [r8, #4]
          tfconf.k = 0;
  204220:	f8c8 9000 	str.w	r9, [r8]
          pidCtx.err =0;
  204224:	f8c3 9010 	str.w	r9, [r3, #16]
          pidCtx.prevErr =0;
  204228:	f8c3 9018 	str.w	r9, [r3, #24]
          pidCtx.integrSum=0;
  20422c:	f8c3 9014 	str.w	r9, [r3, #20]
          pwmEnableChannel( &PWMD2, 2, PWM_PERCENTAGE_TO_WIDTH(&PWMD2, 0) );
  204230:	f7fe f9f6 	bl	202620 <pwmEnableChannel>
  204234:	4d05      	ldr	r5, [pc, #20]	; (20424c <transm+0x1ec>)
  204236:	6827      	ldr	r7, [r4, #0]
  204238:	e7be      	b.n	2041b8 <transm+0x158>
  20423a:	bf00      	nop
  20423c:	20000cec 	.word	0x20000cec
  204240:	20000e84 	.word	0x20000e84
  204244:	20000cb0 	.word	0x20000cb0
  204248:	66666667 	.word	0x66666667
  20424c:	20000e94 	.word	0x20000e94
  204250:	20020098 	.word	0x20020098
  204254:	20000df0 	.word	0x20000df0
  204258:	20000cd0 	.word	0x20000cd0
  20425c:	d1b71759 	.word	0xd1b71759
  204260:	200200bc 	.word	0x200200bc
  204264:	10624dd3 	.word	0x10624dd3
  204268:	20000d50 	.word	0x20000d50
  20426c:	00000000 	.word	0x00000000

00204270 <chSchWakeupS.constprop.34>:
  thread_t *otp = currp;
  204270:	4b15      	ldr	r3, [pc, #84]	; (2042c8 <chSchWakeupS.constprop.34+0x58>)
  if (ntp->prio <= otp->prio) {
  204272:	6881      	ldr	r1, [r0, #8]
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  204274:	b4f0      	push	{r4, r5, r6, r7}
  ntp->u.rdymsg = msg;
  204276:	2600      	movs	r6, #0
  thread_t *otp = currp;
  204278:	699d      	ldr	r5, [r3, #24]
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  20427a:	4604      	mov	r4, r0
  ntp->u.rdymsg = msg;
  20427c:	6246      	str	r6, [r0, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
  20427e:	68a8      	ldr	r0, [r5, #8]
  204280:	4281      	cmp	r1, r0
  204282:	d80c      	bhi.n	20429e <chSchWakeupS.constprop.34+0x2e>
  tp->state = CH_STATE_READY;
  204284:	f884 6020 	strb.w	r6, [r4, #32]
    cp = cp->queue.next;
  204288:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
  20428a:	689a      	ldr	r2, [r3, #8]
  20428c:	4291      	cmp	r1, r2
  20428e:	d9fb      	bls.n	204288 <chSchWakeupS.constprop.34+0x18>
  tp->queue.prev             = cp->queue.prev;
  204290:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
  204292:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  204294:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  204296:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
  204298:	605c      	str	r4, [r3, #4]
}
  20429a:	bcf0      	pop	{r4, r5, r6, r7}
  20429c:	4770      	bx	lr
  cp = (thread_t *)&ch.rlist.queue;
  20429e:	461a      	mov	r2, r3
  tp->state = CH_STATE_READY;
  2042a0:	f885 6020 	strb.w	r6, [r5, #32]
    cp = cp->queue.next;
  2042a4:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
  2042a6:	6891      	ldr	r1, [r2, #8]
  2042a8:	4288      	cmp	r0, r1
  2042aa:	d9fb      	bls.n	2042a4 <chSchWakeupS.constprop.34+0x34>
  tp->queue.prev             = cp->queue.prev;
  2042ac:	6856      	ldr	r6, [r2, #4]
    ntp->state = CH_STATE_CURRENT;
  2042ae:	2701      	movs	r7, #1
  tp->queue.next             = cp;
  2042b0:	602a      	str	r2, [r5, #0]
    chSysSwitch(ntp, otp);
  2042b2:	4629      	mov	r1, r5
  tp->queue.prev             = cp->queue.prev;
  2042b4:	606e      	str	r6, [r5, #4]
    chSysSwitch(ntp, otp);
  2042b6:	4620      	mov	r0, r4
  tp->queue.prev->queue.next = tp;
  2042b8:	6035      	str	r5, [r6, #0]
  cp->queue.prev             = tp;
  2042ba:	6055      	str	r5, [r2, #4]
    ntp->state = CH_STATE_CURRENT;
  2042bc:	f884 7020 	strb.w	r7, [r4, #32]
    currp = ntp;
  2042c0:	619c      	str	r4, [r3, #24]
}
  2042c2:	bcf0      	pop	{r4, r5, r6, r7}
    chSysSwitch(ntp, otp);
  2042c4:	f7fc b806 	b.w	2002d4 <_port_switch>
  2042c8:	20000d78 	.word	0x20000d78
  2042cc:	00000000 	.word	0x00000000

002042d0 <chTMStartMeasurementX.constprop.30>:
  2042d0:	4b01      	ldr	r3, [pc, #4]	; (2042d8 <chTMStartMeasurementX.constprop.30+0x8>)
  2042d2:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
  2042d4:	6083      	str	r3, [r0, #8]
  2042d6:	4770      	bx	lr
  2042d8:	e0001000 	.word	0xe0001000
  2042dc:	00000000 	.word	0x00000000

002042e0 <dac_lld_put_channel.constprop.14>:
 */
void dac_lld_put_channel(DACDriver *dacp,
                         dacchannel_t channel,
                         dacsample_t sample) {

  switch (dacp->config->datamode) {
  2042e0:	6903      	ldr	r3, [r0, #16]
  2042e2:	789b      	ldrb	r3, [r3, #2]
  2042e4:	2b01      	cmp	r3, #1
  2042e6:	d011      	beq.n	20430c <dac_lld_put_channel.constprop.14+0x2c>
  2042e8:	d309      	bcc.n	2042fe <dac_lld_put_channel.constprop.14+0x1e>
  2042ea:	2b02      	cmp	r3, #2
  2042ec:	d106      	bne.n	2042fc <dac_lld_put_channel.constprop.14+0x1c>
#endif
    if (channel == 0U) {
#if STM32_DAC_DUAL_MODE
      dacp->params->dac->DHR8R1 = (uint32_t)sample;
#else
      *(&dacp->params->dac->DHR8R1 + dacp->params->dataoffset) = (uint32_t)sample;
  2042ee:	6a82      	ldr	r2, [r0, #40]	; 0x28
  2042f0:	6813      	ldr	r3, [r2, #0]
  2042f2:	6852      	ldr	r2, [r2, #4]
  2042f4:	3310      	adds	r3, #16
  2042f6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  2042fa:	4770      	bx	lr
  2042fc:	4770      	bx	lr
      *(&dacp->params->dac->DHR12R1 + dacp->params->dataoffset) = (uint32_t)sample;
  2042fe:	6a82      	ldr	r2, [r0, #40]	; 0x28
  204300:	6813      	ldr	r3, [r2, #0]
  204302:	6852      	ldr	r2, [r2, #4]
  204304:	3308      	adds	r3, #8
  204306:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  20430a:	4770      	bx	lr
      *(&dacp->params->dac->DHR12L1 + dacp->params->dataoffset) = (uint32_t)sample;
  20430c:	6a82      	ldr	r2, [r0, #40]	; 0x28
  20430e:	6813      	ldr	r3, [r2, #0]
  204310:	6852      	ldr	r2, [r2, #4]
  204312:	330c      	adds	r3, #12
  204314:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  204318:	4770      	bx	lr
  20431a:	bf00      	nop
  20431c:	0000      	movs	r0, r0
	...

00204320 <chprintf.constprop.3>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  204320:	b40e      	push	{r1, r2, r3}
  204322:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  204326:	b086      	sub	sp, #24
  int n = 0;
  204328:	f04f 0900 	mov.w	r9, #0
  20432c:	f8df a298 	ldr.w	sl, [pc, #664]	; 2045c8 <chprintf.constprop.3+0x2a8>
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  204330:	ab0f      	add	r3, sp, #60	; 0x3c
  204332:	f853 5b04 	ldr.w	r5, [r3], #4
  204336:	461e      	mov	r6, r3
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  204338:	9302      	str	r3, [sp, #8]
    c = *fmt++;
  20433a:	7829      	ldrb	r1, [r5, #0]
  20433c:	1c6a      	adds	r2, r5, #1
    if (c == 0)
  20433e:	b169      	cbz	r1, 20435c <chprintf.constprop.3+0x3c>
    if (c != '%') {
  204340:	2925      	cmp	r1, #37	; 0x25
  204342:	d011      	beq.n	204368 <chprintf.constprop.3+0x48>
      streamPut(chp, (uint8_t)c);
  204344:	f8da 3000 	ldr.w	r3, [sl]
    c = *fmt++;
  204348:	4615      	mov	r5, r2
      streamPut(chp, (uint8_t)c);
  20434a:	489f      	ldr	r0, [pc, #636]	; (2045c8 <chprintf.constprop.3+0x2a8>)
      n++;
  20434c:	f109 0901 	add.w	r9, r9, #1
      streamPut(chp, (uint8_t)c);
  204350:	689b      	ldr	r3, [r3, #8]
  204352:	4798      	blx	r3
    c = *fmt++;
  204354:	7829      	ldrb	r1, [r5, #0]
  204356:	1c6a      	adds	r2, r5, #1
    if (c == 0)
  204358:	2900      	cmp	r1, #0
  20435a:	d1f1      	bne.n	204340 <chprintf.constprop.3+0x20>
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
  20435c:	4648      	mov	r0, r9
  20435e:	b006      	add	sp, #24
  204360:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  204364:	b003      	add	sp, #12
  204366:	4770      	bx	lr
    if (*fmt == '-') {
  204368:	7869      	ldrb	r1, [r5, #1]
  20436a:	292d      	cmp	r1, #45	; 0x2d
  20436c:	f000 818a 	beq.w	204684 <chprintf.constprop.3+0x364>
    left_align = FALSE;
  204370:	2300      	movs	r3, #0
  204372:	9301      	str	r3, [sp, #4]
    if (*fmt == '0') {
  204374:	2930      	cmp	r1, #48	; 0x30
  204376:	f000 8180 	beq.w	20467a <chprintf.constprop.3+0x35a>
    filler = ' ';
  20437a:	f04f 0820 	mov.w	r8, #32
  20437e:	3201      	adds	r2, #1
    width = 0;
  204380:	2400      	movs	r4, #0
  204382:	e005      	b.n	204390 <chprintf.constprop.3+0x70>
        c = va_arg(ap, int);
  204384:	7833      	ldrb	r3, [r6, #0]
  204386:	3604      	adds	r6, #4
  204388:	f812 1b01 	ldrb.w	r1, [r2], #1
      width = width * 10 + c;
  20438c:	eb03 0440 	add.w	r4, r3, r0, lsl #1
      if (c >= '0' && c <= '9')
  204390:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
      c = *fmt++;
  204394:	4615      	mov	r5, r2
      width = width * 10 + c;
  204396:	eb04 0084 	add.w	r0, r4, r4, lsl #2
      if (c >= '0' && c <= '9')
  20439a:	b2db      	uxtb	r3, r3
  20439c:	2b09      	cmp	r3, #9
  20439e:	d9f3      	bls.n	204388 <chprintf.constprop.3+0x68>
      else if (c == '*')
  2043a0:	292a      	cmp	r1, #42	; 0x2a
  2043a2:	d0ef      	beq.n	204384 <chprintf.constprop.3+0x64>
    if (c == '.') {
  2043a4:	292e      	cmp	r1, #46	; 0x2e
  2043a6:	f04f 0200 	mov.w	r2, #0
  2043aa:	d047      	beq.n	20443c <chprintf.constprop.3+0x11c>
    if (c == 'l' || c == 'L') {
  2043ac:	f001 03df 	and.w	r3, r1, #223	; 0xdf
  2043b0:	2b4c      	cmp	r3, #76	; 0x4c
  2043b2:	d152      	bne.n	20445a <chprintf.constprop.3+0x13a>
      if (*fmt)
  2043b4:	782b      	ldrb	r3, [r5, #0]
  2043b6:	b10b      	cbz	r3, 2043bc <chprintf.constprop.3+0x9c>
        c = *fmt++;
  2043b8:	3501      	adds	r5, #1
  2043ba:	4619      	mov	r1, r3
    switch (c) {
  2043bc:	f1a1 0344 	sub.w	r3, r1, #68	; 0x44
  2043c0:	2b34      	cmp	r3, #52	; 0x34
  2043c2:	f200 814d 	bhi.w	204660 <chprintf.constprop.3+0x340>
  2043c6:	e8df f013 	tbh	[pc, r3, lsl #1]
  2043ca:	0122      	.short	0x0122
  2043cc:	014b014b 	.word	0x014b014b
  2043d0:	014b014b 	.word	0x014b014b
  2043d4:	014b0122 	.word	0x014b0122
  2043d8:	014b014b 	.word	0x014b014b
  2043dc:	014b014b 	.word	0x014b014b
  2043e0:	014b00ed 	.word	0x014b00ed
  2043e4:	014b014b 	.word	0x014b014b
  2043e8:	014b014b 	.word	0x014b014b
  2043ec:	014b0084 	.word	0x014b0084
  2043f0:	011f014b 	.word	0x011f014b
  2043f4:	014b014b 	.word	0x014b014b
  2043f8:	014b014b 	.word	0x014b014b
  2043fc:	014b014b 	.word	0x014b014b
  204400:	014b014b 	.word	0x014b014b
  204404:	014b014b 	.word	0x014b014b
  204408:	01220114 	.word	0x01220114
  20440c:	014b014b 	.word	0x014b014b
  204410:	014b014b 	.word	0x014b014b
  204414:	014b0122 	.word	0x014b0122
  204418:	014b014b 	.word	0x014b014b
  20441c:	014b014b 	.word	0x014b014b
  204420:	014b00ed 	.word	0x014b00ed
  204424:	014b014b 	.word	0x014b014b
  204428:	014b00f0 	.word	0x014b00f0
  20442c:	014b0084 	.word	0x014b0084
  204430:	011f014b 	.word	0x011f014b
          c = va_arg(ap, int);
  204434:	7833      	ldrb	r3, [r6, #0]
  204436:	3604      	adds	r6, #4
        precision += c;
  204438:	eb03 0240 	add.w	r2, r3, r0, lsl #1
        c = *fmt++;
  20443c:	f815 1b01 	ldrb.w	r1, [r5], #1
        precision *= 10;
  204440:	eb02 0082 	add.w	r0, r2, r2, lsl #2
        if (c >= '0' && c <= '9')
  204444:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
  204448:	b2db      	uxtb	r3, r3
  20444a:	2b09      	cmp	r3, #9
  20444c:	d9f4      	bls.n	204438 <chprintf.constprop.3+0x118>
        else if (c == '*')
  20444e:	292a      	cmp	r1, #42	; 0x2a
  204450:	d0f0      	beq.n	204434 <chprintf.constprop.3+0x114>
    if (c == 'l' || c == 'L') {
  204452:	f001 03df 	and.w	r3, r1, #223	; 0xdf
  204456:	2b4c      	cmp	r3, #76	; 0x4c
  204458:	d0ac      	beq.n	2043b4 <chprintf.constprop.3+0x94>
    switch (c) {
  20445a:	f1a1 0044 	sub.w	r0, r1, #68	; 0x44
  20445e:	2834      	cmp	r0, #52	; 0x34
  204460:	f200 80fe 	bhi.w	204660 <chprintf.constprop.3+0x340>
  204464:	e8df f010 	tbh	[pc, r0, lsl #1]
  204468:	00fc00d3 	.word	0x00fc00d3
  20446c:	00fc00fc 	.word	0x00fc00fc
  204470:	00d300fc 	.word	0x00d300fc
  204474:	00fc00fc 	.word	0x00fc00fc
  204478:	00fc00fc 	.word	0x00fc00fc
  20447c:	009e00fc 	.word	0x009e00fc
  204480:	00fc00fc 	.word	0x00fc00fc
  204484:	00fc00fc 	.word	0x00fc00fc
  204488:	003500fc 	.word	0x003500fc
  20448c:	00fc00fc 	.word	0x00fc00fc
  204490:	00fc00d0 	.word	0x00fc00d0
  204494:	00fc00fc 	.word	0x00fc00fc
  204498:	00fc00fc 	.word	0x00fc00fc
  20449c:	00fc00fc 	.word	0x00fc00fc
  2044a0:	00fc00fc 	.word	0x00fc00fc
  2044a4:	00c500fc 	.word	0x00c500fc
  2044a8:	00fc00d3 	.word	0x00fc00d3
  2044ac:	00fc00fc 	.word	0x00fc00fc
  2044b0:	00d300fc 	.word	0x00d300fc
  2044b4:	00fc00fc 	.word	0x00fc00fc
  2044b8:	00fc00fc 	.word	0x00fc00fc
  2044bc:	009e00fc 	.word	0x009e00fc
  2044c0:	00fc00fc 	.word	0x00fc00fc
  2044c4:	00a100fc 	.word	0x00a100fc
  2044c8:	003500fc 	.word	0x003500fc
  2044cc:	00fc00fc 	.word	0x00fc00fc
  2044d0:	00d0      	.short	0x00d0
  2044d2:	f04f 0e0a 	mov.w	lr, #10
        l = va_arg(ap, unsigned int);
  2044d6:	6837      	ldr	r7, [r6, #0]
  q = p + MAX_FILLER;
  2044d8:	f10d 0117 	add.w	r1, sp, #23
        l = va_arg(ap, unsigned int);
  2044dc:	3604      	adds	r6, #4
  2044de:	e000      	b.n	2044e2 <chprintf.constprop.3+0x1c2>
  } while ((ll /= radix) != 0);
  2044e0:	4601      	mov	r1, r0
    *--q = i;
  2044e2:	1e48      	subs	r0, r1, #1
    i = (int)(l % radix);
  2044e4:	fbb7 f2fe 	udiv	r2, r7, lr
  2044e8:	fb0e 7c12 	mls	ip, lr, r2, r7
    l /= radix;
  2044ec:	4617      	mov	r7, r2
    i += '0';
  2044ee:	f10c 0330 	add.w	r3, ip, #48	; 0x30
    if (i > '9')
  2044f2:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
  2044f4:	bfc8      	it	gt
  2044f6:	f10c 0337 	addgt.w	r3, ip, #55	; 0x37
    *--q = i;
  2044fa:	b2db      	uxtb	r3, r3
  2044fc:	f801 3c01 	strb.w	r3, [r1, #-1]
  } while ((ll /= radix) != 0);
  204500:	2a00      	cmp	r2, #0
  204502:	d1ed      	bne.n	2044e0 <chprintf.constprop.3+0x1c0>
  i = (int)(p + MAX_FILLER - q);
  204504:	f10d 0217 	add.w	r2, sp, #23
  204508:	af03      	add	r7, sp, #12
  20450a:	1a12      	subs	r2, r2, r0
  20450c:	46be      	mov	lr, r7
  20450e:	4410      	add	r0, r2
  204510:	e001      	b.n	204516 <chprintf.constprop.3+0x1f6>
  204512:	f811 3b01 	ldrb.w	r3, [r1], #1
  while (--i);
  204516:	4288      	cmp	r0, r1
    *p++ = *q++;
  204518:	f80e 3b01 	strb.w	r3, [lr], #1
  while (--i);
  20451c:	d1f9      	bne.n	204512 <chprintf.constprop.3+0x1f2>
  20451e:	1e53      	subs	r3, r2, #1
  204520:	9300      	str	r3, [sp, #0]
    if ((width -= i) < 0)
  204522:	1aa4      	subs	r4, r4, r2
  204524:	d45f      	bmi.n	2045e6 <chprintf.constprop.3+0x2c6>
    if (left_align == FALSE)
  204526:	9b01      	ldr	r3, [sp, #4]
  204528:	2b00      	cmp	r3, #0
  20452a:	f040 80a1 	bne.w	204670 <chprintf.constprop.3+0x350>
  20452e:	f1c4 0b00 	rsb	fp, r4, #0
    if (width < 0) {
  204532:	2c00      	cmp	r4, #0
  204534:	f000 809b 	beq.w	20466e <chprintf.constprop.3+0x34e>
      if (*s == '-' && filler == '0') {
  204538:	783b      	ldrb	r3, [r7, #0]
  20453a:	2b2d      	cmp	r3, #45	; 0x2d
  20453c:	d103      	bne.n	204546 <chprintf.constprop.3+0x226>
  20453e:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
  204542:	f000 80b4 	beq.w	2046ae <chprintf.constprop.3+0x38e>
        streamPut(chp, (uint8_t)filler);
  204546:	f8da 3000 	ldr.w	r3, [sl]
  20454a:	4641      	mov	r1, r8
  20454c:	4650      	mov	r0, sl
  20454e:	689b      	ldr	r3, [r3, #8]
  204550:	4798      	blx	r3
      } while (++width != 0);
  204552:	f11b 0b01 	adds.w	fp, fp, #1
  204556:	d1f6      	bne.n	204546 <chprintf.constprop.3+0x226>
    while (--i >= 0) {
  204558:	9b00      	ldr	r3, [sp, #0]
  20455a:	44a1      	add	r9, r4
  20455c:	2b00      	cmp	r3, #0
  20455e:	f6ff aeec 	blt.w	20433a <chprintf.constprop.3+0x1a>
  204562:	465c      	mov	r4, fp
  204564:	f8dd b000 	ldr.w	fp, [sp]
      streamPut(chp, (uint8_t)*s++);
  204568:	f8da 3000 	ldr.w	r3, [sl]
    while (--i >= 0) {
  20456c:	f10b 3bff 	add.w	fp, fp, #4294967295
      streamPut(chp, (uint8_t)*s++);
  204570:	f817 1b01 	ldrb.w	r1, [r7], #1
  204574:	4650      	mov	r0, sl
  204576:	689b      	ldr	r3, [r3, #8]
  204578:	4798      	blx	r3
    while (--i >= 0) {
  20457a:	f1bb 3fff 	cmp.w	fp, #4294967295
  20457e:	d1f3      	bne.n	204568 <chprintf.constprop.3+0x248>
  204580:	f109 0901 	add.w	r9, r9, #1
  204584:	9b00      	ldr	r3, [sp, #0]
  204586:	4499      	add	r9, r3
    while (width) {
  204588:	2c00      	cmp	r4, #0
  20458a:	f43f aed6 	beq.w	20433a <chprintf.constprop.3+0x1a>
  20458e:	4627      	mov	r7, r4
      streamPut(chp, (uint8_t)filler);
  204590:	f8da 3000 	ldr.w	r3, [sl]
  204594:	4641      	mov	r1, r8
  204596:	4650      	mov	r0, sl
  204598:	689b      	ldr	r3, [r3, #8]
  20459a:	4798      	blx	r3
    while (width) {
  20459c:	3f01      	subs	r7, #1
  20459e:	d1f7      	bne.n	204590 <chprintf.constprop.3+0x270>
  2045a0:	44a1      	add	r9, r4
  2045a2:	e6ca      	b.n	20433a <chprintf.constprop.3+0x1a>
    switch (c) {
  2045a4:	f04f 0e08 	mov.w	lr, #8
  2045a8:	e795      	b.n	2044d6 <chprintf.constprop.3+0x1b6>
      if ((s = va_arg(ap, char *)) == 0)
  2045aa:	6837      	ldr	r7, [r6, #0]
  2045ac:	3604      	adds	r6, #4
  2045ae:	2f00      	cmp	r7, #0
  2045b0:	d078      	beq.n	2046a4 <chprintf.constprop.3+0x384>
      for (p = s; *p && (--precision >= 0); p++)
  2045b2:	783b      	ldrb	r3, [r7, #0]
      if (precision == 0)
  2045b4:	2a00      	cmp	r2, #0
  2045b6:	d16a      	bne.n	20468e <chprintf.constprop.3+0x36e>
      for (p = s; *p && (--precision >= 0); p++)
  2045b8:	2b00      	cmp	r3, #0
  2045ba:	f000 8085 	beq.w	2046c8 <chprintf.constprop.3+0x3a8>
  2045be:	f647 73fe 	movw	r3, #32766	; 0x7ffe
  2045c2:	463a      	mov	r2, r7
  2045c4:	e004      	b.n	2045d0 <chprintf.constprop.3+0x2b0>
  2045c6:	bf00      	nop
  2045c8:	20000cf0 	.word	0x20000cf0
  2045cc:	3b01      	subs	r3, #1
  2045ce:	d403      	bmi.n	2045d8 <chprintf.constprop.3+0x2b8>
  2045d0:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  2045d4:	2900      	cmp	r1, #0
  2045d6:	d1f9      	bne.n	2045cc <chprintf.constprop.3+0x2ac>
  2045d8:	1bd2      	subs	r2, r2, r7
      filler = ' ';
  2045da:	f04f 0820 	mov.w	r8, #32
  2045de:	1e53      	subs	r3, r2, #1
    if ((width -= i) < 0)
  2045e0:	1aa4      	subs	r4, r4, r2
  2045e2:	9300      	str	r3, [sp, #0]
  2045e4:	d59f      	bpl.n	204526 <chprintf.constprop.3+0x206>
    while (--i >= 0) {
  2045e6:	9b00      	ldr	r3, [sp, #0]
  2045e8:	2b00      	cmp	r3, #0
  2045ea:	f6ff aea6 	blt.w	20433a <chprintf.constprop.3+0x1a>
      width = 0;
  2045ee:	2400      	movs	r4, #0
  2045f0:	e7b8      	b.n	204564 <chprintf.constprop.3+0x244>
      *p++ = va_arg(ap, int);
  2045f2:	6833      	ldr	r3, [r6, #0]
  2045f4:	2200      	movs	r2, #0
  2045f6:	af06      	add	r7, sp, #24
  2045f8:	3604      	adds	r6, #4
  2045fa:	9200      	str	r2, [sp, #0]
      filler = ' ';
  2045fc:	f04f 0820 	mov.w	r8, #32
      *p++ = va_arg(ap, int);
  204600:	f807 3d0c 	strb.w	r3, [r7, #-12]!
  204604:	2201      	movs	r2, #1
  204606:	e78c      	b.n	204522 <chprintf.constprop.3+0x202>
    switch (c) {
  204608:	f04f 0e10 	mov.w	lr, #16
  20460c:	e763      	b.n	2044d6 <chprintf.constprop.3+0x1b6>
        l = va_arg(ap, int);
  20460e:	6831      	ldr	r1, [r6, #0]
  204610:	3604      	adds	r6, #4
      if (l < 0) {
  204612:	2900      	cmp	r1, #0
  204614:	db3e      	blt.n	204694 <chprintf.constprop.3+0x374>
    p = tmpbuf;
  204616:	af03      	add	r7, sp, #12
  204618:	463a      	mov	r2, r7
  q = p + MAX_FILLER;
  20461a:	f102 030b 	add.w	r3, r2, #11
    i = (int)(l % radix);
  20461e:	f8df b0bc 	ldr.w	fp, [pc, #188]	; 2046dc <chprintf.constprop.3+0x3bc>
  q = p + MAX_FILLER;
  204622:	4618      	mov	r0, r3
  204624:	9300      	str	r3, [sp, #0]
    i = (int)(l % radix);
  204626:	fbab e301 	umull	lr, r3, fp, r1
  20462a:	08db      	lsrs	r3, r3, #3
  20462c:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
  204630:	469e      	mov	lr, r3
  204632:	eba1 034c 	sub.w	r3, r1, ip, lsl #1
  } while ((ll /= radix) != 0);
  204636:	4671      	mov	r1, lr
    i += '0';
  204638:	3330      	adds	r3, #48	; 0x30
    *--q = i;
  20463a:	b2db      	uxtb	r3, r3
  20463c:	f800 3d01 	strb.w	r3, [r0, #-1]!
  } while ((ll /= radix) != 0);
  204640:	2900      	cmp	r1, #0
  204642:	d1f0      	bne.n	204626 <chprintf.constprop.3+0x306>
  i = (int)(p + MAX_FILLER - q);
  204644:	9900      	ldr	r1, [sp, #0]
  204646:	1a09      	subs	r1, r1, r0
  204648:	4411      	add	r1, r2
  20464a:	e001      	b.n	204650 <chprintf.constprop.3+0x330>
  20464c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    *p++ = *q++;
  204650:	f802 3b01 	strb.w	r3, [r2], #1
  while (--i);
  204654:	428a      	cmp	r2, r1
  204656:	d1f9      	bne.n	20464c <chprintf.constprop.3+0x32c>
  204658:	1bd2      	subs	r2, r2, r7
  20465a:	1e53      	subs	r3, r2, #1
  20465c:	9300      	str	r3, [sp, #0]
  20465e:	e760      	b.n	204522 <chprintf.constprop.3+0x202>
      *p++ = c;
  204660:	af06      	add	r7, sp, #24
  204662:	2300      	movs	r3, #0
  204664:	2201      	movs	r2, #1
  204666:	9300      	str	r3, [sp, #0]
  204668:	f807 1d0c 	strb.w	r1, [r7, #-12]!
  20466c:	e759      	b.n	204522 <chprintf.constprop.3+0x202>
    if (width < 0) {
  20466e:	465c      	mov	r4, fp
    while (--i >= 0) {
  204670:	9b00      	ldr	r3, [sp, #0]
  204672:	2b00      	cmp	r3, #0
  204674:	f6bf af76 	bge.w	204564 <chprintf.constprop.3+0x244>
  204678:	e786      	b.n	204588 <chprintf.constprop.3+0x268>
  20467a:	7851      	ldrb	r1, [r2, #1]
      filler = '0';
  20467c:	f04f 0830 	mov.w	r8, #48	; 0x30
      fmt++;
  204680:	3201      	adds	r2, #1
  204682:	e67c      	b.n	20437e <chprintf.constprop.3+0x5e>
      left_align = TRUE;
  204684:	2301      	movs	r3, #1
      fmt++;
  204686:	1caa      	adds	r2, r5, #2
  204688:	78a9      	ldrb	r1, [r5, #2]
      left_align = TRUE;
  20468a:	9301      	str	r3, [sp, #4]
  20468c:	e672      	b.n	204374 <chprintf.constprop.3+0x54>
      for (p = s; *p && (--precision >= 0); p++)
  20468e:	b1db      	cbz	r3, 2046c8 <chprintf.constprop.3+0x3a8>
  204690:	1e53      	subs	r3, r2, #1
  204692:	e796      	b.n	2045c2 <chprintf.constprop.3+0x2a2>
        *p++ = '-';
  204694:	232d      	movs	r3, #45	; 0x2d
        l = -l;
  204696:	4249      	negs	r1, r1
        *p++ = '-';
  204698:	f10d 020d 	add.w	r2, sp, #13
  20469c:	af03      	add	r7, sp, #12
  20469e:	f88d 300c 	strb.w	r3, [sp, #12]
  2046a2:	e7ba      	b.n	20461a <chprintf.constprop.3+0x2fa>
      if (precision == 0)
  2046a4:	b90a      	cbnz	r2, 2046aa <chprintf.constprop.3+0x38a>
        precision = 32767;
  2046a6:	f647 72ff 	movw	r2, #32767	; 0x7fff
        s = "(null)";
  2046aa:	4f0a      	ldr	r7, [pc, #40]	; (2046d4 <chprintf.constprop.3+0x3b4>)
  2046ac:	e7f0      	b.n	204690 <chprintf.constprop.3+0x370>
  2046ae:	9a00      	ldr	r2, [sp, #0]
        streamPut(chp, (uint8_t)*s++);
  2046b0:	212d      	movs	r1, #45	; 0x2d
  2046b2:	f8da 3000 	ldr.w	r3, [sl]
  2046b6:	3701      	adds	r7, #1
  2046b8:	3a01      	subs	r2, #1
  2046ba:	4807      	ldr	r0, [pc, #28]	; (2046d8 <chprintf.constprop.3+0x3b8>)
  2046bc:	689b      	ldr	r3, [r3, #8]
        n++;
  2046be:	f109 0901 	add.w	r9, r9, #1
  2046c2:	9200      	str	r2, [sp, #0]
        streamPut(chp, (uint8_t)*s++);
  2046c4:	4798      	blx	r3
  2046c6:	e73e      	b.n	204546 <chprintf.constprop.3+0x226>
      for (p = s; *p && (--precision >= 0); p++)
  2046c8:	f04f 33ff 	mov.w	r3, #4294967295
  2046cc:	f04f 0820 	mov.w	r8, #32
  2046d0:	9300      	str	r3, [sp, #0]
  2046d2:	e728      	b.n	204526 <chprintf.constprop.3+0x206>
  2046d4:	08005154 	.word	0x08005154
  2046d8:	20000cf0 	.word	0x20000cf0
  2046dc:	cccccccd 	.word	0xcccccccd

002046e0 <steerUnitCSSetPosition>:
{
  2046e0:	b510      	push	{r4, lr}
  2046e2:	4604      	mov	r4, r0
    if(abs(position - get_wheel_pos())>9)
  2046e4:	f000 fa9c 	bl	204c20 <get_wheel_pos>
  2046e8:	1a20      	subs	r0, r4, r0
  2046ea:	2800      	cmp	r0, #0
  2046ec:	bfb8      	it	lt
  2046ee:	4240      	neglt	r0, r0
  2046f0:	2809      	cmp	r0, #9
  2046f2:	dd0d      	ble.n	204710 <steerUnitCSSetPosition+0x30>
        turn_to = CLIP_VALUE(position, -100, 100);
  2046f4:	2c64      	cmp	r4, #100	; 0x64
  2046f6:	f06f 0363 	mvn.w	r3, #99	; 0x63
  2046fa:	4906      	ldr	r1, [pc, #24]	; (204714 <steerUnitCSSetPosition+0x34>)
        turned = false;
  2046fc:	f04f 0200 	mov.w	r2, #0
        turn_to = CLIP_VALUE(position, -100, 100);
  204700:	bfa8      	it	ge
  204702:	2464      	movge	r4, #100	; 0x64
  204704:	429c      	cmp	r4, r3
  204706:	bfb8      	it	lt
  204708:	461c      	movlt	r4, r3
        turned = false;
  20470a:	4b03      	ldr	r3, [pc, #12]	; (204718 <steerUnitCSSetPosition+0x38>)
        turn_to = CLIP_VALUE(position, -100, 100);
  20470c:	800c      	strh	r4, [r1, #0]
        turned = false;
  20470e:	701a      	strb	r2, [r3, #0]
  204710:	bd10      	pop	{r4, pc}
  204712:	bf00      	nop
  204714:	20000eae 	.word	0x20000eae
  204718:	20000eb0 	.word	0x20000eb0
  20471c:	00000000 	.word	0x00000000

00204720 <get_speed>:
/*
 * @brief       Counts moving speed: distance changing divides by time changing
 * @return      Speed in meters/seconds
 */
odometrySpeedValue_t get_speed (void)
{
  204720:	b538      	push	{r3, r4, r5, lr}
    float delta_time = (float)GPT9cfg.frequency/(TMR_TICKS_2_OVRFLOW);
  204722:	4b0a      	ldr	r3, [pc, #40]	; (20474c <get_speed+0x2c>)
  204724:	681c      	ldr	r4, [r3, #0]
  204726:	4620      	mov	r0, r4
  204728:	f7fc fb88 	bl	200e3c <__aeabi_ui2f>
  20472c:	4605      	mov	r5, r0
  20472e:	4808      	ldr	r0, [pc, #32]	; (204750 <get_speed+0x30>)
  204730:	fba0 3004 	umull	r3, r0, r0, r4
  204734:	0940      	lsrs	r0, r0, #5
  204736:	f7fc fb81 	bl	200e3c <__aeabi_ui2f>
  20473a:	4601      	mov	r1, r0
  20473c:	4628      	mov	r0, r5
  20473e:	f7fc fc89 	bl	201054 <__aeabi_fdiv>
    float speed = diffDistance*delta_time;
  204742:	4b04      	ldr	r3, [pc, #16]	; (204754 <get_speed+0x34>)
  204744:	6819      	ldr	r1, [r3, #0]
  204746:	f7fc fbd1 	bl	200eec <__aeabi_fmul>
    return(speed);
}
  20474a:	bd38      	pop	{r3, r4, r5, pc}
  20474c:	20020088 	.word	0x20020088
  204750:	51eb851f 	.word	0x51eb851f
  204754:	20000df4 	.word	0x20000df4
	...

00204760 <TURNING_WHEELS.lto_priv.44>:

systime_t time_potok = 0;

static THD_WORKING_AREA(waTURNING_WHEELS, 256);        // just for checking
static THD_FUNCTION(TURNING_WHEELS, arg)
{
  204760:	e92d 4888 	stmdb	sp!, {r3, r7, fp, lr}
  204764:	2320      	movs	r3, #32
  204766:	f383 8811 	msr	BASEPRI, r3
  return ch.vtlist.systime;
  20476a:	4e2b      	ldr	r6, [pc, #172]	; (204818 <TURNING_WHEELS.lto_priv.44+0xb8>)
  20476c:	2500      	movs	r5, #0
  20476e:	8cf3      	ldrh	r3, [r6, #38]	; 0x26
  204770:	b29b      	uxth	r3, r3
  204772:	f385 8811 	msr	BASEPRI, r5
    int cnt = 0;
     time_potok= chVTGetSystemTime();
  204776:	4c29      	ldr	r4, [pc, #164]	; (20481c <TURNING_WHEELS.lto_priv.44+0xbc>)
    {
        if(turn_enable == true)
        {
            if(turned == false)
            {
                if(get_speed() > 1.5)
  204778:	f04f 597f 	mov.w	r9, #1069547520	; 0x3fc00000
  20477c:	4f28      	ldr	r7, [pc, #160]	; (204820 <TURNING_WHEELS.lto_priv.44+0xc0>)
                    TurnMotor();
                }
                else if(get_speed() <= 1.5)
                {
                    kp = 0.15;
                    kd = 0;
  20477e:	f04f 0b00 	mov.w	fp, #0
  204782:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 20483c <TURNING_WHEELS.lto_priv.44+0xdc>
     time_potok= chVTGetSystemTime();
  204786:	8023      	strh	r3, [r4, #0]
  204788:	e01a      	b.n	2047c0 <TURNING_WHEELS.lto_priv.44+0x60>
            if(turned == false)
  20478a:	f898 3000 	ldrb.w	r3, [r8]
  20478e:	b1eb      	cbz	r3, 2047cc <TURNING_WHEELS.lto_priv.44+0x6c>
        else
        {
            lldSetPowerMotor(0);
        }
//        pwmEnableChannel( PWMDriver1, PWM1_CHANNEL_P9, 5840 );
        time_potok = chThdSleepUntilWindowed(time_potok,time_potok+MS2ST(20));
  204790:	8823      	ldrh	r3, [r4, #0]
  204792:	2220      	movs	r2, #32
  204794:	f103 0a14 	add.w	sl, r3, #20
  204798:	fa1f fa8a 	uxth.w	sl, sl
  20479c:	f382 8811 	msr	BASEPRI, r2
  2047a0:	8cf1      	ldrh	r1, [r6, #38]	; 0x26
  2047a2:	b289      	uxth	r1, r1
  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
  2047a4:	1acb      	subs	r3, r1, r3
  if (chVTIsTimeWithinX(time, prev, next)) {
  2047a6:	b29b      	uxth	r3, r3
  2047a8:	2b13      	cmp	r3, #19
  2047aa:	d805      	bhi.n	2047b8 <TURNING_WHEELS.lto_priv.44+0x58>
    chThdSleepS(next - time);
  2047ac:	ebaa 0101 	sub.w	r1, sl, r1
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
  2047b0:	2008      	movs	r0, #8
  2047b2:	b289      	uxth	r1, r1
  2047b4:	f7fe f964 	bl	202a80 <chSchGoSleepTimeoutS>
  2047b8:	f385 8811 	msr	BASEPRI, r5
  2047bc:	f8a4 a000 	strh.w	sl, [r4]
        if(turn_enable == true)
  2047c0:	7838      	ldrb	r0, [r7, #0]
  2047c2:	2800      	cmp	r0, #0
  2047c4:	d1e1      	bne.n	20478a <TURNING_WHEELS.lto_priv.44+0x2a>
            lldSetPowerMotor(0);
  2047c6:	f7ff fadb 	bl	203d80 <lldSetPowerMotor>
  2047ca:	e7e1      	b.n	204790 <TURNING_WHEELS.lto_priv.44+0x30>
                if(get_speed() > 1.5)
  2047cc:	f7ff ffa8 	bl	204720 <get_speed>
  2047d0:	4649      	mov	r1, r9
  2047d2:	4682      	mov	sl, r0
  2047d4:	f7fc fd46 	bl	201264 <__aeabi_fcmpgt>
  2047d8:	b158      	cbz	r0, 2047f2 <TURNING_WHEELS.lto_priv.44+0x92>
                    kp = 0.15;
  2047da:	4b12      	ldr	r3, [pc, #72]	; (204824 <TURNING_WHEELS.lto_priv.44+0xc4>)
  2047dc:	4a12      	ldr	r2, [pc, #72]	; (204828 <TURNING_WHEELS.lto_priv.44+0xc8>)
  2047de:	601a      	str	r2, [r3, #0]
                    kd = 0;
  2047e0:	4b12      	ldr	r3, [pc, #72]	; (20482c <TURNING_WHEELS.lto_priv.44+0xcc>)
                    ki = 0.005;
  2047e2:	4a13      	ldr	r2, [pc, #76]	; (204830 <TURNING_WHEELS.lto_priv.44+0xd0>)
                    kd = 0;
  2047e4:	f8c3 b000 	str.w	fp, [r3]
                    ki = 0.005;
  2047e8:	4b12      	ldr	r3, [pc, #72]	; (204834 <TURNING_WHEELS.lto_priv.44+0xd4>)
  2047ea:	601a      	str	r2, [r3, #0]
  2047ec:	f7ff fb18 	bl	203e20 <TurnMotor.part.1>
  2047f0:	e7ce      	b.n	204790 <TURNING_WHEELS.lto_priv.44+0x30>
                else if(get_speed() <= 1.5)
  2047f2:	4650      	mov	r0, sl
  2047f4:	4649      	mov	r1, r9
  2047f6:	f7fc fd21 	bl	20123c <__aeabi_fcmple>
  2047fa:	2800      	cmp	r0, #0
  2047fc:	d0c8      	beq.n	204790 <TURNING_WHEELS.lto_priv.44+0x30>
                    kp = 0.15;
  2047fe:	4b09      	ldr	r3, [pc, #36]	; (204824 <TURNING_WHEELS.lto_priv.44+0xc4>)
  204800:	4a09      	ldr	r2, [pc, #36]	; (204828 <TURNING_WHEELS.lto_priv.44+0xc8>)
  204802:	601a      	str	r2, [r3, #0]
                    kd = 0;
  204804:	4b09      	ldr	r3, [pc, #36]	; (20482c <TURNING_WHEELS.lto_priv.44+0xcc>)
                    ki = 0.05;
  204806:	4a0c      	ldr	r2, [pc, #48]	; (204838 <TURNING_WHEELS.lto_priv.44+0xd8>)
                    kd = 0;
  204808:	f8c3 b000 	str.w	fp, [r3]
                    ki = 0.05;
  20480c:	4b09      	ldr	r3, [pc, #36]	; (204834 <TURNING_WHEELS.lto_priv.44+0xd4>)
  20480e:	601a      	str	r2, [r3, #0]
  204810:	f7ff fb06 	bl	203e20 <TurnMotor.part.1>
  204814:	e7bc      	b.n	204790 <TURNING_WHEELS.lto_priv.44+0x30>
  204816:	bf00      	nop
  204818:	20000d78 	.word	0x20000d78
  20481c:	20000eaa 	.word	0x20000eaa
  204820:	200200c4 	.word	0x200200c4
  204824:	20000ea0 	.word	0x20000ea0
  204828:	3e19999a 	.word	0x3e19999a
  20482c:	20000e98 	.word	0x20000e98
  204830:	3ba3d70a 	.word	0x3ba3d70a
  204834:	20000e9c 	.word	0x20000e9c
  204838:	3d4ccccd 	.word	0x3d4ccccd
  20483c:	20000eb0 	.word	0x20000eb0

00204840 <get_distance>:
{
  204840:	b508      	push	{r3, lr}
  204842:	4b0d      	ldr	r3, [pc, #52]	; (204878 <get_distance+0x38>)
  204844:	6818      	ldr	r0, [r3, #0]
  204846:	f7fc fafd 	bl	200e44 <__aeabi_i2f>
  20484a:	490c      	ldr	r1, [pc, #48]	; (20487c <get_distance+0x3c>)
  20484c:	f7fc fc02 	bl	201054 <__aeabi_fdiv>
    float distance = get_turnover()*(2*M_PI*RADIUS)*TRANSMITION_RATIO;
  204850:	f7fb feb8 	bl	2005c4 <__aeabi_f2d>
  204854:	a306      	add	r3, pc, #24	; (adr r3, 204870 <get_distance+0x30>)
  204856:	e9d3 2300 	ldrd	r2, r3, [r3]
  20485a:	f7fb ff07 	bl	20066c <__aeabi_dmul>
  20485e:	2200      	movs	r2, #0
  204860:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
  204864:	f7fb ff02 	bl	20066c <__aeabi_dmul>
  204868:	f7fc f9e2 	bl	200c30 <__aeabi_d2f>
}
  20486c:	bd08      	pop	{r3, pc}
  20486e:	bf00      	nop
  204870:	4d659f8a 	.word	0x4d659f8a
  204874:	3ffa2357 	.word	0x3ffa2357
  204878:	20000e80 	.word	0x20000e80
  20487c:	43b40000 	.word	0x43b40000

00204880 <drive_Speed_Control>:
 * @brief   Set motor direction
 * @param   voltage 3V - max speed
 *                  0V - no speed
 */
void drive_Speed_Control( float voltage )
{
  204880:	b508      	push	{r3, lr}
    if(!drive_enable) return;
  204882:	4b0d      	ldr	r3, [pc, #52]	; (2048b8 <drive_Speed_Control+0x38>)
  204884:	781b      	ldrb	r3, [r3, #0]
  204886:	b903      	cbnz	r3, 20488a <drive_Speed_Control+0xa>
  204888:	bd08      	pop	{r3, pc}
    uint16_t dacValue = VOLTAGE_2_DAC(voltage);
  20488a:	f7fb fe9b 	bl	2005c4 <__aeabi_f2d>
  20488e:	2200      	movs	r2, #0
  204890:	4b0a      	ldr	r3, [pc, #40]	; (2048bc <drive_Speed_Control+0x3c>)
  204892:	f7fc f815 	bl	2008c0 <__aeabi_ddiv>
  204896:	a306      	add	r3, pc, #24	; (adr r3, 2048b0 <drive_Speed_Control+0x30>)
  204898:	e9d3 2300 	ldrd	r2, r3, [r3]
  20489c:	f7fb fee6 	bl	20066c <__aeabi_dmul>
  2048a0:	f7fc f9a6 	bl	200bf0 <__aeabi_d2uiz>
void dacPutChannelX(DACDriver *dacp, dacchannel_t channel, dacsample_t sample) {

  osalDbgCheck(channel < DAC_MAX_CHANNELS);
  osalDbgAssert(dacp->state == DAC_READY, "invalid state");

  dac_lld_put_channel(dacp, channel, sample);
  2048a4:	b281      	uxth	r1, r0
  2048a6:	4806      	ldr	r0, [pc, #24]	; (2048c0 <drive_Speed_Control+0x40>)
    dacPutChannelX( dacDriver , 0 , dacValue );
}
  2048a8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  2048ac:	f7ff bd18 	b.w	2042e0 <dac_lld_put_channel.constprop.14>
  2048b0:	00000000 	.word	0x00000000
  2048b4:	40affe00 	.word	0x40affe00
  2048b8:	20000e7c 	.word	0x20000e7c
  2048bc:	40090000 	.word	0x40090000
  2048c0:	20000c64 	.word	0x20000c64
	...

002048d0 <commonADC1UnitInit.part.2>:
    memset( filtered_buffer, 0, sizeof( filtered_buffer ) );
  2048d0:	4a69      	ldr	r2, [pc, #420]	; (204a78 <commonADC1UnitInit.part.2+0x1a8>)
  2048d2:	2300      	movs	r3, #0
  2048d4:	2120      	movs	r1, #32
void commonADC1UnitInit ( void )
  2048d6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    memset( filtered_buffer, 0, sizeof( filtered_buffer ) );
  2048da:	6013      	str	r3, [r2, #0]
  2048dc:	6053      	str	r3, [r2, #4]
  2048de:	6093      	str	r3, [r2, #8]
  2048e0:	60d3      	str	r3, [r2, #12]
  2048e2:	f381 8811 	msr	BASEPRI, r1
  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
  2048e6:	4c65      	ldr	r4, [pc, #404]	; (204a7c <commonADC1UnitInit.part.2+0x1ac>)
  if (adcp->state == ADC_STOP) {
  2048e8:	7822      	ldrb	r2, [r4, #0]
  2048ea:	6063      	str	r3, [r4, #4]
  2048ec:	2a01      	cmp	r2, #1
  2048ee:	d068      	beq.n	2049c2 <commonADC1UnitInit.part.2+0xf2>
  adc_lld_start(adcp);
  adcp->state = ADC_READY;
  2048f0:	f04f 0802 	mov.w	r8, #2
  2048f4:	2500      	movs	r5, #0
  2048f6:	f884 8000 	strb.w	r8, [r4]
  2048fa:	f385 8811 	msr	BASEPRI, r5
    palSetLineMode( COMMON_ADC_SEQ1_LINE, PAL_MODE_INPUT_ANALOG );
  2048fe:	2203      	movs	r2, #3
  204900:	2108      	movs	r1, #8
  204902:	485f      	ldr	r0, [pc, #380]	; (204a80 <commonADC1UnitInit.part.2+0x1b0>)
  204904:	2720      	movs	r7, #32
  204906:	f7ff f98b 	bl	203c20 <_pal_lld_setgroupmode>
    palSetLineMode( COMMON_ADC_SEQ2_LINE, PAL_MODE_INPUT_ANALOG );
  20490a:	4641      	mov	r1, r8
  20490c:	2203      	movs	r2, #3
  20490e:	485d      	ldr	r0, [pc, #372]	; (204a84 <commonADC1UnitInit.part.2+0x1b4>)
  204910:	f7ff f986 	bl	203c20 <_pal_lld_setgroupmode>
    palSetLineMode( COMMON_ADC_SEQ3_LINE, PAL_MODE_INPUT_ANALOG );
  204914:	2203      	movs	r2, #3
  204916:	2108      	movs	r1, #8
  204918:	485b      	ldr	r0, [pc, #364]	; (204a88 <commonADC1UnitInit.part.2+0x1b8>)
  20491a:	f7ff f981 	bl	203c20 <_pal_lld_setgroupmode>
    palSetLineMode( COMMON_ADC_SEQ4_LINE, PAL_MODE_INPUT_ANALOG );
  20491e:	2203      	movs	r2, #3
  204920:	2104      	movs	r1, #4
  204922:	4859      	ldr	r0, [pc, #356]	; (204a88 <commonADC1UnitInit.part.2+0x1b8>)
  204924:	f7ff f97c 	bl	203c20 <_pal_lld_setgroupmode>
  204928:	f387 8811 	msr	BASEPRI, r7
  gptp->config = config;
  20492c:	4e57      	ldr	r6, [pc, #348]	; (204a8c <commonADC1UnitInit.part.2+0x1bc>)
  20492e:	4b58      	ldr	r3, [pc, #352]	; (204a90 <commonADC1UnitInit.part.2+0x1c0>)
  gpt_lld_start(gptp);
  204930:	4630      	mov	r0, r6
  gptp->config = config;
  204932:	6073      	str	r3, [r6, #4]
  gpt_lld_start(gptp);
  204934:	f7ff f91c 	bl	203b70 <gpt_lld_start>
  gptp->state = GPT_READY;
  204938:	f886 8000 	strb.w	r8, [r6]
  20493c:	f385 8811 	msr	BASEPRI, r5
  204940:	f387 8811 	msr	BASEPRI, r7
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
  adcp->grpp     = grpp;
  adcp->state    = ADC_ACTIVE;
  204944:	f04f 0e03 	mov.w	lr, #3
  mode = adcp->dmamode;
  204948:	6b23      	ldr	r3, [r4, #48]	; 0x30
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  20494a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  adcp->depth    = depth;
  20494c:	2104      	movs	r1, #4
  adcp->state    = ADC_ACTIVE;
  20494e:	f884 e000 	strb.w	lr, [r4]
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
  204952:	2010      	movs	r0, #16
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  204954:	6812      	ldr	r2, [r2, #0]
      mode |= STM32_DMA_CR_HTIE;
  204956:	f443 7384 	orr.w	r3, r3, #264	; 0x108
  adcp->depth    = depth;
  20495a:	60e1      	str	r1, [r4, #12]
  adcp->adc->SMPR1 = grpp->smpr1;
  20495c:	f640 78c7 	movw	r8, #4039	; 0xfc7
  adcp->samples  = samples;
  204960:	494c      	ldr	r1, [pc, #304]	; (204a94 <commonADC1UnitInit.part.2+0x1c4>)
  adcp->grpp     = grpp;
  204962:	f8df c160 	ldr.w	ip, [pc, #352]	; 204ac4 <commonADC1UnitInit.part.2+0x1f4>
  adcp->samples  = samples;
  204966:	60a1      	str	r1, [r4, #8]
  adcp->grpp     = grpp;
  204968:	f8c4 c010 	str.w	ip, [r4, #16]
  adcp->adc->SMPR2 = grpp->smpr2;
  20496c:	f44f 6c60 	mov.w	ip, #3584	; 0xe00
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  204970:	60d1      	str	r1, [r2, #12]
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
  204972:	6050      	str	r0, [r2, #4]
  adcp->adc->SQR1  = grpp->sqr1 | ADC_SQR1_NUM_CH(grpp->num_channels);
  204974:	f44f 1040 	mov.w	r0, #3145728	; 0x300000
  dmaStreamSetMode(adcp->dmastp, mode);
  204978:	6013      	str	r3, [r2, #0]
  dmaStreamEnable(adcp->dmastp);
  20497a:	6811      	ldr	r1, [r2, #0]
  adcp->adc->SR    = 0;
  20497c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  dmaStreamEnable(adcp->dmastp);
  20497e:	f041 0101 	orr.w	r1, r1, #1
  adcp->adc->SQR3  = grpp->sqr3;
  204982:	4c45      	ldr	r4, [pc, #276]	; (204a98 <commonADC1UnitInit.part.2+0x1c8>)
  dmaStreamEnable(adcp->dmastp);
  204984:	6011      	str	r1, [r2, #0]
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
  204986:	4945      	ldr	r1, [pc, #276]	; (204a9c <commonADC1UnitInit.part.2+0x1cc>)
    adcp->adc->CR2 = cr2;
  204988:	4a45      	ldr	r2, [pc, #276]	; (204aa0 <commonADC1UnitInit.part.2+0x1d0>)
  adcp->adc->SR    = 0;
  20498a:	601d      	str	r5, [r3, #0]
  adcp->adc->SMPR1 = grpp->smpr1;
  20498c:	f8c3 800c 	str.w	r8, [r3, #12]
  adcp->adc->SMPR2 = grpp->smpr2;
  204990:	f8c3 c010 	str.w	ip, [r3, #16]
  adcp->adc->SQR1  = grpp->sqr1 | ADC_SQR1_NUM_CH(grpp->num_channels);
  204994:	62d8      	str	r0, [r3, #44]	; 0x2c
  adcp->adc->SQR2  = grpp->sqr2;
  204996:	631d      	str	r5, [r3, #48]	; 0x30
  adcp->adc->SQR3  = grpp->sqr3;
  204998:	635c      	str	r4, [r3, #52]	; 0x34
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
  20499a:	6059      	str	r1, [r3, #4]
    adcp->adc->CR2 = cr2;
  20499c:	609a      	str	r2, [r3, #8]
  20499e:	f385 8811 	msr	BASEPRI, r5
  2049a2:	f387 8811 	msr	BASEPRI, r7
  gpt_lld_start_timer(gptp, interval);
  2049a6:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
  2049aa:	4630      	mov	r0, r6
  gptp->state = GPT_CONTINUOUS;
  2049ac:	f886 e000 	strb.w	lr, [r6]
  gpt_lld_start_timer(gptp, interval);
  2049b0:	f7ff f8c6 	bl	203b40 <gpt_lld_start_timer>
  2049b4:	f385 8811 	msr	BASEPRI, r5
    adcInitialized = true;
  2049b8:	4b3a      	ldr	r3, [pc, #232]	; (204aa4 <commonADC1UnitInit.part.2+0x1d4>)
  2049ba:	2201      	movs	r2, #1
  2049bc:	701a      	strb	r2, [r3, #0]
  2049be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      b = dmaStreamAllocate(adcp->dmastp,
  2049c2:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
                       void *param) {

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
  2049c4:	4838      	ldr	r0, [pc, #224]	; (204aa8 <commonADC1UnitInit.part.2+0x1d8>)
  2049c6:	7a4b      	ldrb	r3, [r1, #9]
  2049c8:	6805      	ldr	r5, [r0, #0]
  2049ca:	409a      	lsls	r2, r3
  2049cc:	422a      	tst	r2, r5
  2049ce:	d13d      	bne.n	204a4c <commonADC1UnitInit.part.2+0x17c>
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1U << dmastp->selfindex);
  2049d0:	432a      	orrs	r2, r5
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  2049d2:	4e36      	ldr	r6, [pc, #216]	; (204aac <commonADC1UnitInit.part.2+0x1dc>)
  2049d4:	4f36      	ldr	r7, [pc, #216]	; (204ab0 <commonADC1UnitInit.part.2+0x1e0>)
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  2049d6:	eb06 05c3 	add.w	r5, r6, r3, lsl #3

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
  2049da:	f012 0fff 	tst.w	r2, #255	; 0xff
  dma_streams_mask |= (1U << dmastp->selfindex);
  2049de:	6002      	str	r2, [r0, #0]
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  2049e0:	f846 7033 	str.w	r7, [r6, r3, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  2049e4:	606c      	str	r4, [r5, #4]
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
  2049e6:	d004      	beq.n	2049f2 <commonADC1UnitInit.part.2+0x122>
    rccEnableDMA1(false);
  2049e8:	4832      	ldr	r0, [pc, #200]	; (204ab4 <commonADC1UnitInit.part.2+0x1e4>)
  2049ea:	6b03      	ldr	r3, [r0, #48]	; 0x30
  2049ec:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  2049f0:	6303      	str	r3, [r0, #48]	; 0x30
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
  2049f2:	f412 4f7f 	tst.w	r2, #65280	; 0xff00
  2049f6:	d004      	beq.n	204a02 <commonADC1UnitInit.part.2+0x132>
    rccEnableDMA2(false);
  2049f8:	4a2e      	ldr	r2, [pc, #184]	; (204ab4 <commonADC1UnitInit.part.2+0x1e4>)
  2049fa:	6b13      	ldr	r3, [r2, #48]	; 0x30
  2049fc:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
  204a00:	6313      	str	r3, [r2, #48]	; 0x30
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
  204a02:	680a      	ldr	r2, [r1, #0]
  204a04:	6813      	ldr	r3, [r2, #0]
  204a06:	f023 031f 	bic.w	r3, r3, #31
  204a0a:	6013      	str	r3, [r2, #0]
  204a0c:	6813      	ldr	r3, [r2, #0]
  204a0e:	f013 0301 	ands.w	r3, r3, #1
  204a12:	d1fb      	bne.n	204a0c <commonADC1UnitInit.part.2+0x13c>
  204a14:	7a08      	ldrb	r0, [r1, #8]
  204a16:	263d      	movs	r6, #61	; 0x3d
  204a18:	684f      	ldr	r7, [r1, #4]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
  204a1a:	f04f 0e21 	mov.w	lr, #33	; 0x21
  dmaStreamDisable(dmastp);
  204a1e:	4086      	lsls	r6, r0
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  204a20:	4d25      	ldr	r5, [pc, #148]	; (204ab8 <commonADC1UnitInit.part.2+0x1e8>)
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204a22:	2001      	movs	r0, #1
  204a24:	603e      	str	r6, [r7, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  204a26:	2760      	movs	r7, #96	; 0x60
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  204a28:	6013      	str	r3, [r2, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
  204a2a:	f8c2 e014 	str.w	lr, [r2, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
    nvicEnableVector(dmastp->vector, priority);
  204a2e:	7a8b      	ldrb	r3, [r1, #10]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204a30:	095e      	lsrs	r6, r3, #5
  204a32:	f003 021f 	and.w	r2, r3, #31
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  204a36:	442b      	add	r3, r5
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204a38:	fa00 f202 	lsl.w	r2, r0, r2
  204a3c:	eb05 0086 	add.w	r0, r5, r6, lsl #2
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  204a40:	f883 7300 	strb.w	r7, [r3, #768]	; 0x300
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204a44:	f8c0 2180 	str.w	r2, [r0, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  204a48:	f845 2026 	str.w	r2, [r5, r6, lsl #2]
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
  204a4c:	680b      	ldr	r3, [r1, #0]
    adcp->adc->CR2 = ADC_CR2_ADON;
  204a4e:	2601      	movs	r6, #1
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
  204a50:	4a1a      	ldr	r2, [pc, #104]	; (204abc <commonADC1UnitInit.part.2+0x1ec>)
    adcp->adc->CR1 = 0;
  204a52:	2100      	movs	r1, #0
      rccEnableADC1(FALSE);
  204a54:	4d17      	ldr	r5, [pc, #92]	; (204ab4 <commonADC1UnitInit.part.2+0x1e4>)
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
  204a56:	609a      	str	r2, [r3, #8]
      rccEnableADC1(FALSE);
  204a58:	6c6b      	ldr	r3, [r5, #68]	; 0x44
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
  204a5a:	4819      	ldr	r0, [pc, #100]	; (204ac0 <commonADC1UnitInit.part.2+0x1f0>)
      rccEnableADC1(FALSE);
  204a5c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    adcp->adc->CR1 = 0;
  204a60:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      rccEnableADC1(FALSE);
  204a62:	646b      	str	r3, [r5, #68]	; 0x44
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
  204a64:	6843      	ldr	r3, [r0, #4]
  204a66:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
  204a6a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  204a6e:	6043      	str	r3, [r0, #4]
    adcp->adc->CR1 = 0;
  204a70:	6051      	str	r1, [r2, #4]
    adcp->adc->CR2 = 0;
  204a72:	6091      	str	r1, [r2, #8]
    adcp->adc->CR2 = ADC_CR2_ADON;
  204a74:	6096      	str	r6, [r2, #8]
  204a76:	e73b      	b.n	2048f0 <commonADC1UnitInit.part.2+0x20>
  204a78:	20000e84 	.word	0x20000e84
  204a7c:	20000c28 	.word	0x20000c28
  204a80:	40020000 	.word	0x40020000
  204a84:	40020400 	.word	0x40020400
  204a88:	40020800 	.word	0x40020800
  204a8c:	20000c90 	.word	0x20000c90
  204a90:	08005184 	.word	0x08005184
  204a94:	20000d54 	.word	0x20000d54
  204a98:	00063523 	.word	0x00063523
  204a9c:	04000100 	.word	0x04000100
  204aa0:	1d000301 	.word	0x1d000301
  204aa4:	20000d52 	.word	0x20000d52
  204aa8:	20000e78 	.word	0x20000e78
  204aac:	20000df8 	.word	0x20000df8
  204ab0:	00202e41 	.word	0x00202e41
  204ab4:	40023800 	.word	0x40023800
  204ab8:	e000e100 	.word	0xe000e100
  204abc:	4001204c 	.word	0x4001204c
  204ac0:	40012300 	.word	0x40012300
  204ac4:	0800515c 	.word	0x0800515c
	...

00204ad0 <adc_cb.lto_priv.38>:
    if ( buffer != adc_raw_buffer )
  204ad0:	4b1f      	ldr	r3, [pc, #124]	; (204b50 <adc_cb.lto_priv.38+0x80>)
  204ad2:	428b      	cmp	r3, r1
  204ad4:	d03a      	beq.n	204b4c <adc_cb.lto_priv.38+0x7c>
        const float lpf_rates[COMMON_ADC_CHANNELS_NUMBER]     = {0.2, 0.1, 0.1, 0.1};
  204ad6:	4b1f      	ldr	r3, [pc, #124]	; (204b54 <adc_cb.lto_priv.38+0x84>)
{
  204ad8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        const float lpf_rates_inv[COMMON_ADC_CHANNELS_NUMBER] = {0.8, 0.9, 0.9, 0.1};
  204adc:	f103 0410 	add.w	r4, r3, #16
{
  204ae0:	b089      	sub	sp, #36	; 0x24
  204ae2:	f8df 9074 	ldr.w	r9, [pc, #116]	; 204b58 <adc_cb.lto_priv.38+0x88>
        const float lpf_rates_inv[COMMON_ADC_CHANNELS_NUMBER] = {0.8, 0.9, 0.9, 0.1};
  204ae6:	2500      	movs	r5, #0
        const float lpf_rates[COMMON_ADC_CHANNELS_NUMBER]     = {0.2, 0.1, 0.1, 0.1};
  204ae8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  204aea:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
        const float lpf_rates_inv[COMMON_ADC_CHANNELS_NUMBER] = {0.8, 0.9, 0.9, 0.1};
  204aee:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
  204af2:	ac04      	add	r4, sp, #16
  204af4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  204af8:	ab04      	add	r3, sp, #16
  204afa:	f8d9 a000 	ldr.w	sl, [r9]
{
  204afe:	2400      	movs	r4, #0
  204b00:	f85d 6015 	ldr.w	r6, [sp, r5, lsl #1]
  204b04:	f853 8015 	ldr.w	r8, [r3, r5, lsl #1]
                                        adc_raw_buffer[d*COMMON_ADC_CHANNELS_NUMBER + ch] * lpf_rates[ch];
  204b08:	4b11      	ldr	r3, [pc, #68]	; (204b50 <adc_cb.lto_priv.38+0x80>)
  204b0a:	195f      	adds	r7, r3, r5
  204b0c:	f837 0034 	ldrh.w	r0, [r7, r4, lsl #3]
            for ( int d = 0; d < COMMON_ADC_BUFFER_DEPTH; d++ )
  204b10:	3401      	adds	r4, #1
                                        adc_raw_buffer[d*COMMON_ADC_CHANNELS_NUMBER + ch] * lpf_rates[ch];
  204b12:	f7fc f997 	bl	200e44 <__aeabi_i2f>
  204b16:	4631      	mov	r1, r6
  204b18:	f7fc f9e8 	bl	200eec <__aeabi_fmul>
  204b1c:	4683      	mov	fp, r0
                filtered_buffer[ch] = filtered_buffer[ch] * lpf_rates_inv[ch] +
  204b1e:	4650      	mov	r0, sl
  204b20:	f7fc f98c 	bl	200e3c <__aeabi_ui2f>
  204b24:	4641      	mov	r1, r8
  204b26:	f7fc f9e1 	bl	200eec <__aeabi_fmul>
  204b2a:	4601      	mov	r1, r0
  204b2c:	4658      	mov	r0, fp
  204b2e:	f7fc f8d5 	bl	200cdc <__addsf3>
  204b32:	f7fc fbc7 	bl	2012c4 <__aeabi_f2uiz>
            for ( int d = 0; d < COMMON_ADC_BUFFER_DEPTH; d++ )
  204b36:	2c04      	cmp	r4, #4
                filtered_buffer[ch] = filtered_buffer[ch] * lpf_rates_inv[ch] +
  204b38:	4682      	mov	sl, r0
            for ( int d = 0; d < COMMON_ADC_BUFFER_DEPTH; d++ )
  204b3a:	d1e7      	bne.n	204b0c <adc_cb.lto_priv.38+0x3c>
  204b3c:	3502      	adds	r5, #2
  204b3e:	f849 0b04 	str.w	r0, [r9], #4
        for ( int ch = 0; ch < COMMON_ADC_CHANNELS_NUMBER; ch++ )
  204b42:	2d08      	cmp	r5, #8
  204b44:	d1d8      	bne.n	204af8 <adc_cb.lto_priv.38+0x28>
}
  204b46:	b009      	add	sp, #36	; 0x24
  204b48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  204b4c:	4770      	bx	lr
  204b4e:	bf00      	nop
  204b50:	20000d54 	.word	0x20000d54
  204b54:	08004ea8 	.word	0x08004ea8
  204b58:	20000e84 	.word	0x20000e84
  204b5c:	00000000 	.word	0x00000000

00204b60 <EXT_CB_PARK_ENABLE>:
    if(palReadPad(GPIOG,6) == PAL_HIGH)
  204b60:	4b10      	ldr	r3, [pc, #64]	; (204ba4 <EXT_CB_PARK_ENABLE+0x44>)
  204b62:	691b      	ldr	r3, [r3, #16]
  204b64:	f3c3 1380 	ubfx	r3, r3, #6, #1
{
  204b68:	b4f0      	push	{r4, r5, r6, r7}
    if(palReadPad(GPIOG,6) == PAL_HIGH)
  204b6a:	b97b      	cbnz	r3, 204b8c <EXT_CB_PARK_ENABLE+0x2c>
            turn_enable = false;
  204b6c:	4a0e      	ldr	r2, [pc, #56]	; (204ba8 <EXT_CB_PARK_ENABLE+0x48>)
        I = 0;
  204b6e:	2400      	movs	r4, #0
  204b70:	2500      	movs	r5, #0
        drive_enable = false;
  204b72:	4f0e      	ldr	r7, [pc, #56]	; (204bac <EXT_CB_PARK_ENABLE+0x4c>)
        parking_enable = false;
  204b74:	4e0e      	ldr	r6, [pc, #56]	; (204bb0 <EXT_CB_PARK_ENABLE+0x50>)
        palClearLine( LINE_LED2 );
  204b76:	2180      	movs	r1, #128	; 0x80
        I = 0;
  204b78:	480e      	ldr	r0, [pc, #56]	; (204bb4 <EXT_CB_PARK_ENABLE+0x54>)
            turn_enable = false;
  204b7a:	7013      	strb	r3, [r2, #0]
        palClearLine( LINE_LED2 );
  204b7c:	4a0e      	ldr	r2, [pc, #56]	; (204bb8 <EXT_CB_PARK_ENABLE+0x58>)
        drive_enable = false;
  204b7e:	703b      	strb	r3, [r7, #0]
        parking_enable = false;
  204b80:	7033      	strb	r3, [r6, #0]
        I = 0;
  204b82:	e9c0 4500 	strd	r4, r5, [r0]
        palClearLine( LINE_LED2 );
  204b86:	8351      	strh	r1, [r2, #26]
}
  204b88:	bcf0      	pop	{r4, r5, r6, r7}
  204b8a:	4770      	bx	lr
        turn_enable = true;
  204b8c:	2301      	movs	r3, #1
  204b8e:	4d06      	ldr	r5, [pc, #24]	; (204ba8 <EXT_CB_PARK_ENABLE+0x48>)
        drive_enable = true;
  204b90:	4c06      	ldr	r4, [pc, #24]	; (204bac <EXT_CB_PARK_ENABLE+0x4c>)
        palSetLine( LINE_LED2 );
  204b92:	2180      	movs	r1, #128	; 0x80
        parking_enable = true;
  204b94:	4806      	ldr	r0, [pc, #24]	; (204bb0 <EXT_CB_PARK_ENABLE+0x50>)
        palSetLine( LINE_LED2 );
  204b96:	4a08      	ldr	r2, [pc, #32]	; (204bb8 <EXT_CB_PARK_ENABLE+0x58>)
        turn_enable = true;
  204b98:	702b      	strb	r3, [r5, #0]
        drive_enable = true;
  204b9a:	7023      	strb	r3, [r4, #0]
        parking_enable = true;
  204b9c:	7003      	strb	r3, [r0, #0]
        palSetLine( LINE_LED2 );
  204b9e:	8311      	strh	r1, [r2, #24]
}
  204ba0:	bcf0      	pop	{r4, r5, r6, r7}
  204ba2:	4770      	bx	lr
  204ba4:	40021800 	.word	0x40021800
  204ba8:	200200c4 	.word	0x200200c4
  204bac:	20000e7c 	.word	0x20000e7c
  204bb0:	20000ebd 	.word	0x20000ebd
  204bb4:	20000ca0 	.word	0x20000ca0
  204bb8:	40020400 	.word	0x40020400
  204bbc:	00000000 	.word	0x00000000

00204bc0 <EXT_CB_A>:
    if(palReadLine(ENC_CH_B))
  204bc0:	4b05      	ldr	r3, [pc, #20]	; (204bd8 <EXT_CB_A+0x18>)
        encoderTicks--;
  204bc2:	4a06      	ldr	r2, [pc, #24]	; (204bdc <EXT_CB_A+0x1c>)
    if(palReadLine(ENC_CH_B))
  204bc4:	691b      	ldr	r3, [r3, #16]
  204bc6:	f013 0f20 	tst.w	r3, #32
        encoderTicks--;
  204bca:	6813      	ldr	r3, [r2, #0]
  204bcc:	bf14      	ite	ne
  204bce:	f103 33ff 	addne.w	r3, r3, #4294967295
        encoderTicks++;
  204bd2:	3301      	addeq	r3, #1
  204bd4:	6013      	str	r3, [r2, #0]
  204bd6:	4770      	bx	lr
  204bd8:	40021800 	.word	0x40021800
  204bdc:	20000e80 	.word	0x20000e80

00204be0 <brakeSensorIsPressed>:
    isInitialized = true;
}

bool brakeSensorIsPressed ( void )
{
    return palReadLine( brakeSensorClickLine );
  204be0:	4b02      	ldr	r3, [pc, #8]	; (204bec <brakeSensorIsPressed+0xc>)
  204be2:	6918      	ldr	r0, [r3, #16]
}
  204be4:	f000 0001 	and.w	r0, r0, #1
  204be8:	4770      	bx	lr
  204bea:	bf00      	nop
  204bec:	40020000 	.word	0x40020000

00204bf0 <brakeSensorInit>:
{
  204bf0:	b510      	push	{r4, lr}
    if ( isInitialized )
  204bf2:	4c08      	ldr	r4, [pc, #32]	; (204c14 <brakeSensorInit+0x24>)
  204bf4:	7823      	ldrb	r3, [r4, #0]
  204bf6:	b103      	cbz	r3, 204bfa <brakeSensorInit+0xa>
  204bf8:	bd10      	pop	{r4, pc}
    if ( adcInitialized )
  204bfa:	4b07      	ldr	r3, [pc, #28]	; (204c18 <brakeSensorInit+0x28>)
  204bfc:	781b      	ldrb	r3, [r3, #0]
  204bfe:	b90b      	cbnz	r3, 204c04 <brakeSensorInit+0x14>
  204c00:	f7ff fe66 	bl	2048d0 <commonADC1UnitInit.part.2>
    palSetLineMode( brakeSensorClickLine, PAL_MODE_INPUT_PULLUP );
  204c04:	2220      	movs	r2, #32
  204c06:	2101      	movs	r1, #1
  204c08:	4804      	ldr	r0, [pc, #16]	; (204c1c <brakeSensorInit+0x2c>)
  204c0a:	f7ff f809 	bl	203c20 <_pal_lld_setgroupmode>
    isInitialized = true;
  204c0e:	2301      	movs	r3, #1
  204c10:	7023      	strb	r3, [r4, #0]
  204c12:	e7f1      	b.n	204bf8 <brakeSensorInit+0x8>
  204c14:	20000ebc 	.word	0x20000ebc
  204c18:	20000d52 	.word	0x20000d52
  204c1c:	40020000 	.word	0x40020000

00204c20 <get_wheel_pos>:
}



int16_t get_wheel_pos(void)        //WORKING
{
  204c20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    return filtered_buffer[ch];
  204c22:	4b15      	ldr	r3, [pc, #84]	; (204c78 <get_wheel_pos+0x58>)
    DinADC[1] = (commonADC1UnitGetValue(1)-2000)/5.4; // 
  204c24:	4c15      	ldr	r4, [pc, #84]	; (204c7c <get_wheel_pos+0x5c>)
  204c26:	8898      	ldrh	r0, [r3, #4]
  204c28:	f5a0 60fa 	sub.w	r0, r0, #2000	; 0x7d0
  204c2c:	f7fb fcb8 	bl	2005a0 <__aeabi_i2d>
  204c30:	a30f      	add	r3, pc, #60	; (adr r3, 204c70 <get_wheel_pos+0x50>)
  204c32:	e9d3 2300 	ldrd	r2, r3, [r3]
  204c36:	f7fb fe43 	bl	2008c0 <__aeabi_ddiv>
  204c3a:	f7fb ffb1 	bl	200ba0 <__aeabi_d2iz>
//    DinADC[1] = (value-3010)/10;
    DinADC[0] = DinADC[0] - (LPF_K_POS*(DinADC[0]-DinADC[1]));
  204c3e:	f9b4 6000 	ldrsh.w	r6, [r4]
    DinADC[1] = (commonADC1UnitGetValue(1)-2000)/5.4; // 
  204c42:	b205      	sxth	r5, r0
    DinADC[0] = DinADC[0] - (LPF_K_POS*(DinADC[0]-DinADC[1]));
  204c44:	4630      	mov	r0, r6
    DinADC[1] = (commonADC1UnitGetValue(1)-2000)/5.4; // 
  204c46:	8065      	strh	r5, [r4, #2]
    DinADC[0] = DinADC[0] - (LPF_K_POS*(DinADC[0]-DinADC[1]));
  204c48:	f7fc f8fc 	bl	200e44 <__aeabi_i2f>
  204c4c:	4607      	mov	r7, r0
  204c4e:	1b70      	subs	r0, r6, r5
  204c50:	f7fc f8f8 	bl	200e44 <__aeabi_i2f>
  204c54:	f04f 517a 	mov.w	r1, #1048576000	; 0x3e800000
  204c58:	f7fc f948 	bl	200eec <__aeabi_fmul>
  204c5c:	4601      	mov	r1, r0
  204c5e:	4638      	mov	r0, r7
  204c60:	f7fc f83a 	bl	200cd8 <__aeabi_fsub>
  204c64:	f7fc fb08 	bl	201278 <__aeabi_f2iz>
  204c68:	b200      	sxth	r0, r0
  204c6a:	8020      	strh	r0, [r4, #0]
    return DinADC[0];
//    return DoutADC;
}
  204c6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  204c6e:	bf00      	nop
  204c70:	9999999a 	.word	0x9999999a
  204c74:	40159999 	.word	0x40159999
  204c78:	20000e84 	.word	0x20000e84
  204c7c:	20000eb4 	.word	0x20000eb4

00204c80 <get_current>:
{
  204c80:	b538      	push	{r3, r4, r5, lr}
  204c82:	4b19      	ldr	r3, [pc, #100]	; (204ce8 <get_current+0x68>)
    DinCur[1] = abs(((commonADC1UnitGetValue(2) - 1875)*100)/7)-600;
  204c84:	2164      	movs	r1, #100	; 0x64
  204c86:	4a19      	ldr	r2, [pc, #100]	; (204cec <get_current+0x6c>)
  204c88:	891b      	ldrh	r3, [r3, #8]
        DinCur[1] = 0;
  204c8a:	4c19      	ldr	r4, [pc, #100]	; (204cf0 <get_current+0x70>)
    DinCur[1] = abs(((commonADC1UnitGetValue(2) - 1875)*100)/7)-600;
  204c8c:	f2a3 7353 	subw	r3, r3, #1875	; 0x753
  204c90:	fb01 f103 	mul.w	r1, r1, r3
  204c94:	fb82 3201 	smull	r3, r2, r2, r1
  204c98:	17cb      	asrs	r3, r1, #31
  204c9a:	440a      	add	r2, r1
  204c9c:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
  204ca0:	2b00      	cmp	r3, #0
  204ca2:	bfb8      	it	lt
  204ca4:	425b      	neglt	r3, r3
  204ca6:	f5a3 7316 	sub.w	r3, r3, #600	; 0x258
  204caa:	b21b      	sxth	r3, r3
    if(DinCur[1]<0)
  204cac:	2b00      	cmp	r3, #0
  204cae:	db16      	blt.n	204cde <get_current+0x5e>
  204cb0:	4618      	mov	r0, r3
    DinCur[1] = abs(((commonADC1UnitGetValue(2) - 1875)*100)/7)-600;
  204cb2:	8063      	strh	r3, [r4, #2]
  204cb4:	f7fc f8c6 	bl	200e44 <__aeabi_i2f>
  204cb8:	490e      	ldr	r1, [pc, #56]	; (204cf4 <get_current+0x74>)
  204cba:	f7fc f917 	bl	200eec <__aeabi_fmul>
  204cbe:	4605      	mov	r5, r0
    DinCur[0] = DinCur[1]*LPF_K_CUR + (1 - LPF_K_CUR)*DinCur[0];
  204cc0:	f9b4 0000 	ldrsh.w	r0, [r4]
  204cc4:	f7fc f8be 	bl	200e44 <__aeabi_i2f>
  204cc8:	490b      	ldr	r1, [pc, #44]	; (204cf8 <get_current+0x78>)
  204cca:	f7fc f90f 	bl	200eec <__aeabi_fmul>
  204cce:	4629      	mov	r1, r5
  204cd0:	f7fc f804 	bl	200cdc <__addsf3>
  204cd4:	f7fc fad0 	bl	201278 <__aeabi_f2iz>
  204cd8:	b200      	sxth	r0, r0
  204cda:	8020      	strh	r0, [r4, #0]
}
  204cdc:	bd38      	pop	{r3, r4, r5, pc}
        DinCur[1] = 0;
  204cde:	2300      	movs	r3, #0
  204ce0:	2500      	movs	r5, #0
  204ce2:	8063      	strh	r3, [r4, #2]
  204ce4:	e7ec      	b.n	204cc0 <get_current+0x40>
  204ce6:	bf00      	nop
  204ce8:	20000e84 	.word	0x20000e84
  204cec:	92492493 	.word	0x92492493
  204cf0:	20000eb8 	.word	0x20000eb8
  204cf4:	3f19999a 	.word	0x3f19999a
  204cf8:	3ecccccc 	.word	0x3ecccccc

00204cfc <atoi>:
  204cfc:	220a      	movs	r2, #10
  204cfe:	2100      	movs	r1, #0
  204d00:	f000 b894 	b.w	204e2c <strtol>

00204d04 <_strtol_l.isra.0>:
  204d04:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  204d08:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
  204d0c:	460f      	mov	r7, r1
  204d0e:	4680      	mov	r8, r0
  204d10:	4616      	mov	r6, r2
  204d12:	461d      	mov	r5, r3
  204d14:	468a      	mov	sl, r1
  204d16:	e000      	b.n	204d1a <_strtol_l.isra.0+0x16>
  204d18:	46a2      	mov	sl, r4
  204d1a:	4654      	mov	r4, sl
  204d1c:	4648      	mov	r0, r9
  204d1e:	f814 bb01 	ldrb.w	fp, [r4], #1
  204d22:	f000 f899 	bl	204e58 <__locale_ctype_ptr_l>
  204d26:	4458      	add	r0, fp
  204d28:	7842      	ldrb	r2, [r0, #1]
  204d2a:	f012 0208 	ands.w	r2, r2, #8
  204d2e:	d1f3      	bne.n	204d18 <_strtol_l.isra.0+0x14>
  204d30:	f1bb 0f2d 	cmp.w	fp, #45	; 0x2d
  204d34:	d04f      	beq.n	204dd6 <_strtol_l.isra.0+0xd2>
  204d36:	f1bb 0f2b 	cmp.w	fp, #43	; 0x2b
  204d3a:	bf04      	itt	eq
  204d3c:	f894 b000 	ldrbeq.w	fp, [r4]
  204d40:	f10a 0402 	addeq.w	r4, sl, #2
  204d44:	b11d      	cbz	r5, 204d4e <_strtol_l.isra.0+0x4a>
  204d46:	2d10      	cmp	r5, #16
  204d48:	d056      	beq.n	204df8 <_strtol_l.isra.0+0xf4>
  204d4a:	46ac      	mov	ip, r5
  204d4c:	e004      	b.n	204d58 <_strtol_l.isra.0+0x54>
  204d4e:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
  204d52:	d060      	beq.n	204e16 <_strtol_l.isra.0+0x112>
  204d54:	250a      	movs	r5, #10
  204d56:	46ac      	mov	ip, r5
  204d58:	2a00      	cmp	r2, #0
  204d5a:	bf0c      	ite	eq
  204d5c:	f06f 4900 	mvneq.w	r9, #2147483648	; 0x80000000
  204d60:	f04f 4900 	movne.w	r9, #2147483648	; 0x80000000
  204d64:	2100      	movs	r1, #0
  204d66:	fbb9 fefc 	udiv	lr, r9, ip
  204d6a:	4608      	mov	r0, r1
  204d6c:	fb0c 9a1e 	mls	sl, ip, lr, r9
  204d70:	e005      	b.n	204d7e <_strtol_l.isra.0+0x7a>
  204d72:	d029      	beq.n	204dc8 <_strtol_l.isra.0+0xc4>
  204d74:	fb0c 3000 	mla	r0, ip, r0, r3
  204d78:	2101      	movs	r1, #1
  204d7a:	f814 bb01 	ldrb.w	fp, [r4], #1
  204d7e:	f1ab 0330 	sub.w	r3, fp, #48	; 0x30
  204d82:	2b09      	cmp	r3, #9
  204d84:	d905      	bls.n	204d92 <_strtol_l.isra.0+0x8e>
  204d86:	f1ab 0341 	sub.w	r3, fp, #65	; 0x41
  204d8a:	2b19      	cmp	r3, #25
  204d8c:	d80b      	bhi.n	204da6 <_strtol_l.isra.0+0xa2>
  204d8e:	f1ab 0337 	sub.w	r3, fp, #55	; 0x37
  204d92:	429d      	cmp	r5, r3
  204d94:	dd0f      	ble.n	204db6 <_strtol_l.isra.0+0xb2>
  204d96:	f1b1 3fff 	cmp.w	r1, #4294967295
  204d9a:	d0ee      	beq.n	204d7a <_strtol_l.isra.0+0x76>
  204d9c:	4586      	cmp	lr, r0
  204d9e:	d2e8      	bcs.n	204d72 <_strtol_l.isra.0+0x6e>
  204da0:	f04f 31ff 	mov.w	r1, #4294967295
  204da4:	e7e9      	b.n	204d7a <_strtol_l.isra.0+0x76>
  204da6:	f1ab 0361 	sub.w	r3, fp, #97	; 0x61
  204daa:	2b19      	cmp	r3, #25
  204dac:	d803      	bhi.n	204db6 <_strtol_l.isra.0+0xb2>
  204dae:	f1ab 0357 	sub.w	r3, fp, #87	; 0x57
  204db2:	429d      	cmp	r5, r3
  204db4:	dcef      	bgt.n	204d96 <_strtol_l.isra.0+0x92>
  204db6:	1c4b      	adds	r3, r1, #1
  204db8:	d013      	beq.n	204de2 <_strtol_l.isra.0+0xde>
  204dba:	b102      	cbz	r2, 204dbe <_strtol_l.isra.0+0xba>
  204dbc:	4240      	negs	r0, r0
  204dbe:	b146      	cbz	r6, 204dd2 <_strtol_l.isra.0+0xce>
  204dc0:	b9c1      	cbnz	r1, 204df4 <_strtol_l.isra.0+0xf0>
  204dc2:	6037      	str	r7, [r6, #0]
  204dc4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  204dc8:	459a      	cmp	sl, r3
  204dca:	dad3      	bge.n	204d74 <_strtol_l.isra.0+0x70>
  204dcc:	f04f 31ff 	mov.w	r1, #4294967295
  204dd0:	e7d3      	b.n	204d7a <_strtol_l.isra.0+0x76>
  204dd2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  204dd6:	f894 b000 	ldrb.w	fp, [r4]
  204dda:	2201      	movs	r2, #1
  204ddc:	f10a 0402 	add.w	r4, sl, #2
  204de0:	e7b0      	b.n	204d44 <_strtol_l.isra.0+0x40>
  204de2:	2322      	movs	r3, #34	; 0x22
  204de4:	f8c8 3000 	str.w	r3, [r8]
  204de8:	b1ee      	cbz	r6, 204e26 <_strtol_l.isra.0+0x122>
  204dea:	1e67      	subs	r7, r4, #1
  204dec:	4648      	mov	r0, r9
  204dee:	6037      	str	r7, [r6, #0]
  204df0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  204df4:	4681      	mov	r9, r0
  204df6:	e7f8      	b.n	204dea <_strtol_l.isra.0+0xe6>
  204df8:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
  204dfc:	d1a5      	bne.n	204d4a <_strtol_l.isra.0+0x46>
  204dfe:	7823      	ldrb	r3, [r4, #0]
  204e00:	f003 03df 	and.w	r3, r3, #223	; 0xdf
  204e04:	2b58      	cmp	r3, #88	; 0x58
  204e06:	d1a0      	bne.n	204d4a <_strtol_l.isra.0+0x46>
  204e08:	f04f 0c10 	mov.w	ip, #16
  204e0c:	f894 b001 	ldrb.w	fp, [r4, #1]
  204e10:	4665      	mov	r5, ip
  204e12:	3402      	adds	r4, #2
  204e14:	e7a0      	b.n	204d58 <_strtol_l.isra.0+0x54>
  204e16:	7823      	ldrb	r3, [r4, #0]
  204e18:	f003 03df 	and.w	r3, r3, #223	; 0xdf
  204e1c:	2b58      	cmp	r3, #88	; 0x58
  204e1e:	d0f3      	beq.n	204e08 <_strtol_l.isra.0+0x104>
  204e20:	2508      	movs	r5, #8
  204e22:	46ac      	mov	ip, r5
  204e24:	e798      	b.n	204d58 <_strtol_l.isra.0+0x54>
  204e26:	4648      	mov	r0, r9
  204e28:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00204e2c <strtol>:
  204e2c:	b530      	push	{r4, r5, lr}
  204e2e:	4c08      	ldr	r4, [pc, #32]	; (204e50 <strtol+0x24>)
  204e30:	4b08      	ldr	r3, [pc, #32]	; (204e54 <strtol+0x28>)
  204e32:	6825      	ldr	r5, [r4, #0]
  204e34:	6b6c      	ldr	r4, [r5, #52]	; 0x34
  204e36:	b083      	sub	sp, #12
  204e38:	2c00      	cmp	r4, #0
  204e3a:	bf08      	it	eq
  204e3c:	461c      	moveq	r4, r3
  204e3e:	9400      	str	r4, [sp, #0]
  204e40:	4613      	mov	r3, r2
  204e42:	460a      	mov	r2, r1
  204e44:	4601      	mov	r1, r0
  204e46:	4628      	mov	r0, r5
  204e48:	f7ff ff5c 	bl	204d04 <_strtol_l.isra.0>
  204e4c:	b003      	add	sp, #12
  204e4e:	bd30      	pop	{r4, r5, pc}
  204e50:	200200c8 	.word	0x200200c8
  204e54:	200204f8 	.word	0x200204f8

00204e58 <__locale_ctype_ptr_l>:
  204e58:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
  204e5c:	4770      	bx	lr
  204e5e:	bf00      	nop

00204e60 <__ascii_mbtowc>:
  204e60:	b082      	sub	sp, #8
  204e62:	b149      	cbz	r1, 204e78 <__ascii_mbtowc+0x18>
  204e64:	b15a      	cbz	r2, 204e7e <__ascii_mbtowc+0x1e>
  204e66:	b16b      	cbz	r3, 204e84 <__ascii_mbtowc+0x24>
  204e68:	7813      	ldrb	r3, [r2, #0]
  204e6a:	600b      	str	r3, [r1, #0]
  204e6c:	7812      	ldrb	r2, [r2, #0]
  204e6e:	1c10      	adds	r0, r2, #0
  204e70:	bf18      	it	ne
  204e72:	2001      	movne	r0, #1
  204e74:	b002      	add	sp, #8
  204e76:	4770      	bx	lr
  204e78:	a901      	add	r1, sp, #4
  204e7a:	2a00      	cmp	r2, #0
  204e7c:	d1f3      	bne.n	204e66 <__ascii_mbtowc+0x6>
  204e7e:	4610      	mov	r0, r2
  204e80:	b002      	add	sp, #8
  204e82:	4770      	bx	lr
  204e84:	f06f 0001 	mvn.w	r0, #1
  204e88:	e7f4      	b.n	204e74 <__ascii_mbtowc+0x14>
  204e8a:	bf00      	nop

00204e8c <__ascii_wctomb>:
  204e8c:	b121      	cbz	r1, 204e98 <__ascii_wctomb+0xc>
  204e8e:	2aff      	cmp	r2, #255	; 0xff
  204e90:	d804      	bhi.n	204e9c <__ascii_wctomb+0x10>
  204e92:	700a      	strb	r2, [r1, #0]
  204e94:	2001      	movs	r0, #1
  204e96:	4770      	bx	lr
  204e98:	4608      	mov	r0, r1
  204e9a:	4770      	bx	lr
  204e9c:	238a      	movs	r3, #138	; 0x8a
  204e9e:	6003      	str	r3, [r0, #0]
  204ea0:	f04f 30ff 	mov.w	r0, #4294967295
  204ea4:	4770      	bx	lr
  204ea6:	bf00      	nop
